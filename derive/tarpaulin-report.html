<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <style>html, body {
  margin: 0;
  padding: 0;
}

.app {
  margin: 10px;
  padding: 0;
}

.files-list {
  margin: 10px 0 0;
  width: 100%;
  border-collapse: collapse;
}
.files-list__head {
  border: 1px solid #999;
}
.files-list__head > tr > th {
  padding: 10px;
  border: 1px solid #999;
  text-align: left;
  font-weight: normal;
  background: #ddd;
}
.files-list__body {
}
.files-list__file {
  cursor: pointer;
}
.files-list__file:hover {
  background: #ccf;
}
.files-list__file > td {
  padding: 10px;
  border: 1px solid #999;
}
.files-list__file > td:first-child::before {
  content: '\01F4C4';
  margin-right: 1em;
}
.files-list__file_low {
  background: #fcc;
}
.files-list__file_medium {
  background: #ffc;
}
.files-list__file_high {
  background: #cfc;
}
.files-list__file_folder > td:first-child::before {
  content: '\01F4C1';
  margin-right: 1em;
}

.file-header {
  border: 1px solid #999;
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.file-header__back {
  margin: 10px;
  cursor: pointer;
  flex-shrink: 0;
  flex-grow: 0;
  text-decoration: underline;
  color: #338;
}

.file-header__name {
  margin: 10px;
  flex-shrink: 2;
  flex-grow: 2;
}

.file-header__stat {
  margin: 10px;
  flex-shrink: 0;
  flex-grow: 0;
}

.file-content {
  margin: 10px 0 0;
  border: 1px solid #999;
  padding: 10px;
}

.code-line {
  margin: 0;
  padding: 0.3em;
  height: 1em;
}
.code-line_covered {
  background: #cfc;
}
.code-line_uncovered {
  background: #fcc;
}
</style>
</head>
<body>
    <div id="root"></div>
    <script>
        var data = {"files":[{"path":["/","home","trangar","development","rust","bincode","derive","src","derive_enum.rs"],"content":"use crate::Result;\nuse proc_macro::TokenStream;\nuse proc_macro2::{Span, TokenStream as TokenStream2};\nuse quote::{quote, ToTokens};\nuse syn::{\n    spanned::Spanned, Fields, GenericParam, Generics, Ident, Index, Lifetime, LifetimeDef, Variant,\n};\npub struct DeriveEnum {\n    name: Ident,\n    generics: Generics,\n    variants: Vec\u003cVariant\u003e,\n}\n\nimpl DeriveEnum {\n    pub fn parse(name: Ident, generics: Generics, en: syn::DataEnum) -\u003e Result\u003cSelf\u003e {\n        let variants = en.variants.into_iter().collect();\n\n        Ok(DeriveEnum {\n            name,\n            generics,\n            variants,\n        })\n    }\n\n    pub fn generate_encodable(self) -\u003e Result\u003cTokenStream\u003e {\n        let DeriveEnum {\n            name,\n            generics,\n            variants,\n        } = self;\n\n        let (impl_generics, ty_generics, where_clause) = generics.split_for_impl();\n\n        let match_arms = variants.iter().enumerate().map(|(index, variant)| {\n            let fields_section = fields_to_match_arm(\u0026variant.fields);\n            let encode_statements = field_names_to_encodable(\u0026fields_to_names(\u0026variant.fields));\n            let variant_name = variant.ident.clone();\n            quote! {\n                #name :: #variant_name #fields_section =\u003e {\n                    encoder.encode_u32(#index as u32)?;\n                    #(#encode_statements)*\n                }\n            }\n        });\n        let result = quote! {\n            impl #impl_generics bincode::enc::Encodeable for #name #ty_generics #where_clause {\n                fn encode\u003cE: bincode::enc::Encode\u003e(\u0026self, mut encoder: E) -\u003e Result\u003c(), bincode::error::EncodeError\u003e {\n                    match self {\n                        #(#match_arms)*\n                    }\n                    Ok(())\n                }\n\n            }\n        };\n\n        Ok(result.into())\n    }\n\n    pub fn generate_decodable(self) -\u003e Result\u003cTokenStream\u003e {\n        let DeriveEnum {\n            name,\n            generics,\n            variants,\n        } = self;\n\n        let (mut impl_generics, ty_generics, where_clause) = generics.split_for_impl();\n\n        // check if the type has lifetimes\n        let mut should_insert_lifetime = false;\n\n        for param in \u0026generics.params {\n            if let GenericParam::Lifetime(_) = param {\n                should_insert_lifetime = true;\n                break;\n            }\n        }\n\n        // if we don't have a '__de lifetime, insert it\n        let mut generics_with_decode_lifetime;\n        if should_insert_lifetime {\n            generics_with_decode_lifetime = generics.clone();\n\n            let mut new_lifetime = LifetimeDef::new(Lifetime::new(\"'__de\", Span::call_site()));\n\n            for param in \u0026generics.params {\n                if let GenericParam::Lifetime(lt) = param {\n                    new_lifetime.bounds.push(lt.lifetime.clone())\n                }\n            }\n\n            generics_with_decode_lifetime\n                .params\n                .push(GenericParam::Lifetime(new_lifetime));\n\n            impl_generics = generics_with_decode_lifetime.split_for_impl().0;\n        }\n\n        let max_variant = (variants.len() - 1) as u32;\n        let match_arms = variants.iter().enumerate().map(|(index, variant)| {\n            let index = index as u32;\n            let decode_statements = field_names_to_decodable(\n                \u0026fields_to_constructable_names(\u0026variant.fields),\n                should_insert_lifetime,\n            );\n            let variant_name = variant.ident.clone();\n            quote! {\n                #index =\u003e {\n                    #name :: #variant_name {\n                        #(#decode_statements)*\n                    }\n                }\n            }\n        });\n        let result = if should_insert_lifetime {\n            quote! {\n                impl #impl_generics bincode::de::BorrowDecodable\u003c'__de\u003e for #name #ty_generics #where_clause {\n                    fn borrow_decode\u003cD: bincode::de::BorrowDecode\u003c'__de\u003e\u003e(mut decoder: D) -\u003e Result\u003cSelf, bincode::error::DecodeError\u003e {\n                        let i = decoder.decode_u32()?;\n                        Ok(match i {\n                            #(#match_arms)*\n                            variant =\u003e return Err(bincode::error::DecodeError::UnexpectedVariant{\n                                min: 0,\n                                max: #max_variant,\n                                found: variant,\n                            })\n                        })\n                    }\n\n                }\n            }\n        } else {\n            quote! {\n                impl #impl_generics bincode::de::Decodable for #name #ty_generics #where_clause {\n                    fn decode\u003cD: bincode::de::Decode\u003e(mut decoder: D) -\u003e Result\u003cSelf, bincode::error::DecodeError\u003e {\n                        let i = decoder.decode_u32()?;\n                        Ok(match i {\n                            #(#match_arms)*\n                            variant =\u003e return Err(bincode::error::DecodeError::UnexpectedVariant{\n                                min: 0,\n                                max: #max_variant,\n                                found: variant,\n                            })\n                        })\n                    }\n\n                }\n            }\n        };\n\n        Ok(result.into())\n    }\n}\n\nfn fields_to_match_arm(fields: \u0026Fields) -\u003e TokenStream2 {\n    match fields {\n        syn::Fields::Named(fields) =\u003e {\n            let fields: Vec\u003c_\u003e = fields\n                .named\n                .iter()\n                .map(|f| f.ident.clone().unwrap().to_token_stream())\n                .collect();\n            quote! {\n                {#(#fields),*}\n            }\n        }\n        syn::Fields::Unnamed(fields) =\u003e {\n            let fields: Vec\u003c_\u003e = fields\n                .unnamed\n                .iter()\n                .enumerate()\n                .map(|(i, f)| Ident::new(\u0026format!(\"_{}\", i), f.span()))\n                .collect();\n            quote! {\n                (#(#fields),*)\n            }\n        }\n        syn::Fields::Unit =\u003e quote! {},\n    }\n}\n\nfn fields_to_names(fields: \u0026Fields) -\u003e Vec\u003cTokenStream2\u003e {\n    match fields {\n        syn::Fields::Named(fields) =\u003e fields\n            .named\n            .iter()\n            .map(|f| f.ident.clone().unwrap().to_token_stream())\n            .collect(),\n        syn::Fields::Unnamed(fields) =\u003e fields\n            .unnamed\n            .iter()\n            .enumerate()\n            .map(|(i, f)| Ident::new(\u0026format!(\"_{}\", i), f.span()).to_token_stream())\n            .collect(),\n        syn::Fields::Unit =\u003e Vec::new(),\n    }\n}\n\nfn field_names_to_encodable(names: \u0026[TokenStream2]) -\u003e Vec\u003cTokenStream2\u003e {\n    names\n        .iter()\n        .map(|field| {\n            quote! {\n                bincode::enc::Encodeable::encode(#field, \u0026mut encoder)?;\n            }\n        })\n        .collect::\u003cVec\u003c_\u003e\u003e()\n}\n\nfn fields_to_constructable_names(fields: \u0026Fields) -\u003e Vec\u003cTokenStream2\u003e {\n    match fields {\n        syn::Fields::Named(fields) =\u003e fields\n            .named\n            .iter()\n            .map(|f| f.ident.clone().unwrap().to_token_stream())\n            .collect(),\n        syn::Fields::Unnamed(fields) =\u003e fields\n            .unnamed\n            .iter()\n            .enumerate()\n            .map(|(i, _)| Index::from(i).to_token_stream())\n            .collect(),\n        syn::Fields::Unit =\u003e Vec::new(),\n    }\n}\n\nfn field_names_to_decodable(names: \u0026[TokenStream2], borrowed: bool) -\u003e Vec\u003cTokenStream2\u003e {\n    names\n        .iter()\n        .map(|field| {\n            if borrowed {\n                quote! {\n                    #field: bincode::de::BorrowDecodable::borrow_decode(\u0026mut decoder)?,\n                }\n            } else {\n                quote! {\n                    #field: bincode::de::Decodable::decode(\u0026mut decoder)?,\n                }\n            }\n        })\n        .collect::\u003cVec\u003c_\u003e\u003e()\n}\n","traces":[{"line":15,"address":[212448,212883],"length":1,"stats":{"Line":0},"fn_name":"parse"},{"line":16,"address":[212478],"length":1,"stats":{"Line":0},"fn_name":null},{"line":18,"address":[212703],"length":1,"stats":{"Line":0},"fn_name":null},{"line":19,"address":[212607],"length":1,"stats":{"Line":0},"fn_name":null},{"line":20,"address":[212638],"length":1,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[212664],"length":1,"stats":{"Line":0},"fn_name":null},{"line":25,"address":[212912,215972],"length":1,"stats":{"Line":0},"fn_name":"generate_encodable"},{"line":26,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[212924],"length":1,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[212950],"length":1,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[213019],"length":1,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[213049],"length":1,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[213202,213129],"length":1,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[281901],"length":1,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[282026,281920],"length":1,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[282090],"length":1,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[282154,282232],"length":1,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[213294],"length":1,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[215745],"length":1,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[216016,225146],"length":1,"stats":{"Line":0},"fn_name":"generate_decodable"},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[216031],"length":1,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[216082],"length":1,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[216154],"length":1,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[216184],"length":1,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[216259],"length":1,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[216275,216478,216354,216526,216474],"length":1,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[216510],"length":1,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[216516],"length":1,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[217524,216550],"length":1,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[216565],"length":1,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[216758,216696],"length":1,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[216861,217054,216953,217078,217179],"length":1,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[217115,217177],"length":1,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[217141,217197],"length":1,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[217466],"length":1,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[217206],"length":1,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[217473],"length":1,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[217632,217553],"length":1,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[217609,217674],"length":1,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[283184],"length":1,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[283258],"length":1,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[283190],"length":1,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[283247],"length":1,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[283331],"length":1,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[283464,283389],"length":1,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[224907,217793],"length":1,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[217825],"length":1,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[217803,221471],"length":1,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[221399,224916],"length":1,"stats":{"Line":0},"fn_name":null},{"line":155,"address":[225200,226032],"length":1,"stats":{"Line":0},"fn_name":"fields_to_match_arm"},{"line":156,"address":[225272],"length":1,"stats":{"Line":0},"fn_name":null},{"line":157,"address":[225236,225279],"length":1,"stats":{"Line":0},"fn_name":null},{"line":158,"address":[225291,226057],"length":1,"stats":{"Line":0},"fn_name":null},{"line":161,"address":[284112,284150],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":163,"address":[226178,226095],"length":1,"stats":{"Line":0},"fn_name":null},{"line":167,"address":[225317],"length":1,"stats":{"Line":0},"fn_name":null},{"line":168,"address":[225329,225387],"length":1,"stats":{"Line":0},"fn_name":null},{"line":172,"address":[284329,284288],"length":1,"stats":{"Line":0},"fn_name":"{closure#1}"},{"line":174,"address":[225442,225528],"length":1,"stats":{"Line":0},"fn_name":null},{"line":178,"address":[225355],"length":1,"stats":{"Line":0},"fn_name":null},{"line":182,"address":[226688],"length":1,"stats":{"Line":0},"fn_name":"fields_to_names"},{"line":183,"address":[226748],"length":1,"stats":{"Line":0},"fn_name":null},{"line":184,"address":[226755,226718,226905],"length":1,"stats":{"Line":0},"fn_name":null},{"line":187,"address":[284758,284720],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":189,"address":[226790,226853],"length":1,"stats":{"Line":0},"fn_name":null},{"line":193,"address":[284937,284896],"length":1,"stats":{"Line":0},"fn_name":"{closure#1}"},{"line":195,"address":[226825],"length":1,"stats":{"Line":0},"fn_name":null},{"line":199,"address":[226944],"length":1,"stats":{"Line":0},"fn_name":"field_names_to_encodable"},{"line":200,"address":[226994],"length":1,"stats":{"Line":0},"fn_name":null},{"line":202,"address":[285905,285424],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":203,"address":[285453],"length":1,"stats":{"Line":0},"fn_name":null},{"line":210,"address":[227072],"length":1,"stats":{"Line":0},"fn_name":"fields_to_constructable_names"},{"line":211,"address":[227132],"length":1,"stats":{"Line":0},"fn_name":null},{"line":212,"address":[227139,227102,227289],"length":1,"stats":{"Line":0},"fn_name":null},{"line":215,"address":[285920,285958],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":217,"address":[227237,227174],"length":1,"stats":{"Line":0},"fn_name":null},{"line":221,"address":[286136,286096],"length":1,"stats":{"Line":0},"fn_name":"{closure#1}"},{"line":223,"address":[227209],"length":1,"stats":{"Line":0},"fn_name":null},{"line":227,"address":[227328],"length":1,"stats":{"Line":0},"fn_name":"field_names_to_decodable"},{"line":228,"address":[227384,227419],"length":1,"stats":{"Line":0},"fn_name":null},{"line":230,"address":[227409],"length":1,"stats":{"Line":0},"fn_name":null},{"line":231,"address":[286222,287317,286736],"length":1,"stats":{"Line":0},"fn_name":null},{"line":232,"address":[286249],"length":1,"stats":{"Line":0},"fn_name":null},{"line":236,"address":[286779,286230],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":119},{"path":["/","home","trangar","development","rust","bincode","derive","src","derive_struct.rs"],"content":"use crate::Result;\nuse proc_macro::TokenStream;\nuse proc_macro2::{Span, TokenStream as TokenStream2};\nuse quote::{quote, ToTokens};\nuse syn::{GenericParam, Generics, Ident, Index, Lifetime, LifetimeDef};\n\npub struct DeriveStruct {\n    name: Ident,\n    generics: Generics,\n    fields: Vec\u003cTokenStream2\u003e,\n}\n\nimpl DeriveStruct {\n    pub fn parse(name: Ident, generics: Generics, str: syn::DataStruct) -\u003e Result\u003cSelf\u003e {\n        let fields = match str.fields {\n            syn::Fields::Named(fields) =\u003e fields\n                .named\n                .iter()\n                .map(|f| f.ident.clone().unwrap().to_token_stream())\n                .collect(),\n            syn::Fields::Unnamed(fields) =\u003e fields\n                .unnamed\n                .iter()\n                .enumerate()\n                .map(|(i, _)| Index::from(i).to_token_stream())\n                .collect(),\n            syn::Fields::Unit =\u003e Vec::new(),\n        };\n\n        Ok(Self {\n            name,\n            generics,\n            fields,\n        })\n    }\n\n    pub fn generate_encodable(self) -\u003e Result\u003cTokenStream\u003e {\n        let DeriveStruct {\n            name,\n            generics,\n            fields,\n        } = self;\n\n        let (impl_generics, ty_generics, where_clause) = generics.split_for_impl();\n\n        let fields = fields\n            .into_iter()\n            .map(|field| {\n                quote! {\n                    bincode::enc::Encodeable::encode(\u0026self. #field, \u0026mut encoder)?;\n                }\n            })\n            .collect::\u003cVec\u003c_\u003e\u003e();\n\n        let result = quote! {\n            impl #impl_generics bincode::enc::Encodeable for #name #ty_generics #where_clause {\n                fn encode\u003cE: bincode::enc::Encode\u003e(\u0026self, mut encoder: E) -\u003e Result\u003c(), bincode::error::EncodeError\u003e {\n                    #(#fields)*\n                    Ok(())\n                }\n\n            }\n        };\n        Ok(result.into())\n    }\n\n    pub fn generate_decodable(self) -\u003e Result\u003cTokenStream\u003e {\n        let DeriveStruct {\n            name,\n            generics,\n            fields,\n        } = self;\n\n        let (mut impl_generics, ty_generics, where_clause) = generics.split_for_impl();\n\n        // check if the type has lifetimes\n        let mut should_insert_lifetime = false;\n\n        for param in \u0026generics.params {\n            if let GenericParam::Lifetime(_) = param {\n                should_insert_lifetime = true;\n                break;\n            }\n        }\n\n        // if the type has lifetimes, insert '__de and bound it to the lifetimes\n        let mut generics_with_decode_lifetime;\n        if should_insert_lifetime {\n            generics_with_decode_lifetime = generics.clone();\n            let mut new_lifetime = LifetimeDef::new(Lifetime::new(\"'__de\", Span::call_site()));\n\n            for param in \u0026generics.params {\n                if let GenericParam::Lifetime(lt) = param {\n                    new_lifetime.bounds.push(lt.lifetime.clone())\n                }\n            }\n            generics_with_decode_lifetime\n                .params\n                .push(GenericParam::Lifetime(new_lifetime));\n\n            impl_generics = generics_with_decode_lifetime.split_for_impl().0;\n        }\n\n        let fields = fields\n            .into_iter()\n            .map(|field| {\n                if should_insert_lifetime {\n                    quote! {\n                        #field: bincode::de::BorrowDecodable::borrow_decode(\u0026mut decoder)?,\n                    }\n                } else {\n                    quote! {\n                        #field: bincode::de::Decodable::decode(\u0026mut decoder)?,\n                    }\n                }\n            })\n            .collect::\u003cVec\u003c_\u003e\u003e();\n\n        let result = if should_insert_lifetime {\n            quote! {\n                impl #impl_generics bincode::de::BorrowDecodable\u003c'__de\u003e for #name #ty_generics #where_clause {\n                    fn borrow_decode\u003cD: bincode::de::BorrowDecode\u003c'__de\u003e\u003e(mut decoder: D) -\u003e Result\u003cSelf, bincode::error::DecodeError\u003e {\n                        Ok(#name {\n                            #(#fields)*\n                        })\n                    }\n\n                }\n            }\n        } else {\n            quote! {\n                impl #impl_generics bincode::de::Decodable for #name #ty_generics #where_clause {\n                    fn decode\u003cD: bincode::de::Decode\u003e(mut decoder: D) -\u003e Result\u003cSelf, bincode::error::DecodeError\u003e {\n                        Ok(#name {\n                            #(#fields)*\n                        })\n                    }\n\n                }\n            }\n        };\n\n        Ok(result.into())\n    }\n}\n","traces":[{"line":14,"address":[171146,170304],"length":1,"stats":{"Line":0},"fn_name":"parse"},{"line":15,"address":[170401,170336],"length":1,"stats":{"Line":0},"fn_name":null},{"line":16,"address":[170408,171013,171092,170368],"length":1,"stats":{"Line":0},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":19,"address":[334694,334656],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":21,"address":[170487,170890,170954],"length":1,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":25,"address":[334872,334832],"length":1,"stats":{"Line":0},"fn_name":"{closure#1}"},{"line":27,"address":[170566],"length":1,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[170717],"length":1,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[170621],"length":1,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[170652],"length":1,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[170678],"length":1,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[171184,173868],"length":1,"stats":{"Line":0},"fn_name":"generate_encodable"},{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[171196],"length":1,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[171230],"length":1,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[171299],"length":1,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[171337],"length":1,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[171409,171529],"length":1,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[335521,334928],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":49,"address":[334960,335038],"length":1,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[171559,171649],"length":1,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[173640],"length":1,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[180134,173904],"length":1,"stats":{"Line":0},"fn_name":"generate_decodable"},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[173919],"length":1,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[173978],"length":1,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[174050],"length":1,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[174088],"length":1,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[174163],"length":1,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[174179,174383,174431,174379,174259],"length":1,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[174415],"length":1,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[174421],"length":1,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[174455,175429],"length":1,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[174470],"length":1,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[174601,174663],"length":1,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[174983,174959,174766,175084,174858],"length":1,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[175020,175082],"length":1,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[175046,175102],"length":1,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[175371],"length":1,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[175111],"length":1,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[175378],"length":1,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[175450,175529],"length":1,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[175521],"length":1,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[336717,335582],"length":1,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[335687,335612],"length":1,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[336164,335590],"length":1,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[175583,179894],"length":1,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[175615,175705],"length":1,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[175593,177878],"length":1,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":143,"address":[179903,177806],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":72},{"path":["/","home","trangar","development","rust","bincode","derive","src","error.rs"],"content":"use proc_macro2::*;\nuse std::fmt;\n\n#[derive(Debug)]\npub enum Error {\n    UnknownVisibility(Span),\n    UnknownDataType(Span),\n    InvalidRustSyntax(Span),\n    ExpectedIdent(Span),\n    UnionNotSupported,\n}\n\nimpl PartialEq for Error {\n    fn eq(\u0026self, other: \u0026Error) -\u003e bool {\n        match (self, other) {\n            (Error::UnknownVisibility(_), Error::UnknownVisibility(_)) =\u003e true,\n            (Error::UnknownDataType(_), Error::UnknownDataType(_)) =\u003e true,\n            (Error::UnionNotSupported, Error::UnionNotSupported) =\u003e true,\n            (Error::InvalidRustSyntax(_), Error::InvalidRustSyntax(_)) =\u003e true,\n            (Error::ExpectedIdent(_), Error::ExpectedIdent(_)) =\u003e true,\n            _ =\u003e false,\n        }\n    }\n}\n\n// helper functions for the unit tests\n#[cfg(test)]\nimpl Error {\n    pub fn is_unknown_visibility(\u0026self) -\u003e bool {\n        matches!(self, Error::UnknownVisibility(_))\n    }\n\n    pub fn is_unknown_data_type(\u0026self) -\u003e bool {\n        matches!(self, Error::UnknownDataType(_))\n    }\n\n    pub fn is_invalid_rust_syntax(\u0026self) -\u003e bool {\n        matches!(self, Error::InvalidRustSyntax(_))\n    }\n\n    pub fn is_expected_ident(\u0026self) -\u003e bool {\n        matches!(self, Error::ExpectedIdent(_))\n    }\n}\n\nimpl fmt::Display for Error {\n    fn fmt(\u0026self, fmt: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        match self {\n            Self::UnknownVisibility(_) =\u003e write!(fmt, \"Unknown visibility\"),\n            Self::UnknownDataType(_) =\u003e {\n                write!(fmt, \"Unknown data type, only enum and struct are supported\")\n            }\n            Self::UnionNotSupported =\u003e write!(fmt, \"Unions are not supported\"),\n            Self::InvalidRustSyntax(_) =\u003e write!(fmt, \"Invalid rust syntax\"),\n            Self::ExpectedIdent(_) =\u003e write!(fmt, \"Expected ident\"),\n        }\n    }\n}\n\nimpl Error {\n    pub fn into_token_stream(self) -\u003e TokenStream {\n        let maybe_span = match \u0026self {\n            Error::UnknownVisibility(span)\n            | Error::UnknownDataType(span)\n            | Error::ExpectedIdent(span)\n            | Error::InvalidRustSyntax(span) =\u003e Some(span.clone()),\n\n            Error::UnionNotSupported =\u003e None,\n        };\n        self.throw_with_span(maybe_span.unwrap_or_else(Span::call_site))\n    }\n\n    pub fn throw_with_span(self, span: Span) -\u003e TokenStream {\n        // compile_error!($message)\n        vec![\n            TokenTree::Ident(Ident::new(\"compile_error\", span)),\n            TokenTree::Punct({\n                let mut punct = Punct::new('!', Spacing::Alone);\n                punct.set_span(span);\n                punct\n            }),\n            TokenTree::Group({\n                let mut group = Group::new(Delimiter::Brace, {\n                    TokenTree::Literal({\n                        let mut string = Literal::string(\u0026self.to_string());\n                        string.set_span(span);\n                        string\n                    })\n                    .into()\n                });\n                group.set_span(span);\n                group\n            }),\n        ]\n        .into_iter()\n        .collect()\n    }\n}\n","traces":[{"line":14,"address":[185904],"length":1,"stats":{"Line":0},"fn_name":"eq"},{"line":15,"address":[186076,186083,186090,185918,185970,186069],"length":1,"stats":{"Line":0},"fn_name":null},{"line":16,"address":[185972,186085,185928],"length":1,"stats":{"Line":0},"fn_name":null},{"line":17,"address":[185987,186078],"length":1,"stats":{"Line":0},"fn_name":null},{"line":18,"address":[186032],"length":1,"stats":{"Line":0},"fn_name":null},{"line":19,"address":[186071,186002],"length":1,"stats":{"Line":0},"fn_name":null},{"line":20,"address":[186064,186017],"length":1,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[185965],"length":1,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[186096],"length":1,"stats":{"Line":1},"fn_name":"is_unknown_visibility"},{"line":30,"address":[186105],"length":1,"stats":{"Line":1},"fn_name":null},{"line":33,"address":[186144],"length":1,"stats":{"Line":1},"fn_name":"is_unknown_data_type"},{"line":34,"address":[186153],"length":1,"stats":{"Line":1},"fn_name":null},{"line":37,"address":[186192],"length":1,"stats":{"Line":1},"fn_name":"is_invalid_rust_syntax"},{"line":38,"address":[186201],"length":1,"stats":{"Line":1},"fn_name":null},{"line":41,"address":[186240],"length":1,"stats":{"Line":0},"fn_name":"is_expected_ident"},{"line":42,"address":[186249],"length":1,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[186288],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":48,"address":[186343],"length":1,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[186345,186655,186315],"length":1,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[186384,186632],"length":1,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[186504],"length":1,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[186423,186606],"length":1,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[186580,186465],"length":1,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[186688],"length":1,"stats":{"Line":0},"fn_name":"into_token_stream"},{"line":62,"address":[186795,186811,186904,186779,186763,186747],"length":1,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[186717,186749],"length":1,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[186813],"length":1,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[186911,186821],"length":1,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[188050,186944],"length":1,"stats":{"Line":0},"fn_name":"throw_with_span"},{"line":75,"address":[186998,187468,187914,188065,187173,187298],"length":1,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[187011],"length":1,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[187369],"length":1,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[187120,187216],"length":1,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[187261],"length":1,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[187339],"length":1,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[187868],"length":1,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[187410,187770],"length":1,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[187704],"length":1,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[187518,187431],"length":1,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[187594],"length":1,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[187672],"length":1,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[187805],"length":1,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[187842],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":6,"coverable":48},{"path":["/","home","trangar","development","rust","bincode","derive","src","lib.rs"],"content":"extern crate proc_macro;\n\nmod derive_enum;\nmod derive_struct;\nmod error;\nmod parse;\n\nuse error::Error;\nuse proc_macro2::TokenStream;\n\ntype Result\u003cT = ()\u003e = std::result::Result\u003cT, Error\u003e;\n\n#[proc_macro_derive(Encodable)]\npub fn derive_encodable(input: proc_macro::TokenStream) -\u003e proc_macro::TokenStream {\n    derive_encodable_inner(input.into())\n        .unwrap_or_else(|e| e.into_token_stream())\n        .into()\n}\n\nfn derive_encodable_inner(input: TokenStream) -\u003e Result\u003cTokenStream\u003e {\n    let mut source = input.into_iter().peekable();\n    let source = \u0026mut source;\n    let _visibility = parse::Visibility::try_take(source)?;\n    let _datatype = parse::DataType::take(source)?;\n    let _generics = parse::Generics::try_take(source)?;\n\n    dbg!(_visibility);\n    dbg!(_datatype);\n    dbg!(_generics);\n\n    unimplemented!();\n}\n\n/*\n#[proc_macro_derive(Decodable)]\npub fn derive_decodable(input: TokenStream) -\u003e TokenStream {\n    let input = parse_macro_input!(input as DeriveInput);\n    derive_decodable_inner(input).unwrap_or_else(|e| e.into_token_stream())\n}\n\nfn derive_decodable_inner(input: DeriveInput) -\u003e Result\u003cTokenStream\u003e {\n    match input.data {\n        syn::Data::Struct(struct_definition) =\u003e {\n            DeriveStruct::parse(input.ident, input.generics, struct_definition)\n                .and_then(|str| str.generate_decodable())\n        }\n        syn::Data::Enum(enum_definition) =\u003e {\n            DeriveEnum::parse(input.ident, input.generics, enum_definition)\n                .and_then(|str| str.generate_decodable())\n        }\n        syn::Data::Union(_) =\u003e Err(Error::UnionNotSupported),\n    }\n}\n*/\n\n#[cfg(test)]\npub(crate) fn token_stream(\n    s: \u0026str,\n) -\u003e std::iter::Peekable\u003cimpl Iterator\u003cItem = proc_macro2::TokenTree\u003e\u003e {\n    use std::str::FromStr;\n\n    let stream = proc_macro2::TokenStream::from_str(s)\n        .unwrap_or_else(|e| panic!(\"Could not parse code: {:?}\\n{:?}\", s, e));\n    stream.into_iter().peekable()\n}\n","traces":[{"line":14,"address":[267296],"length":1,"stats":{"Line":0},"fn_name":"derive_encodable"},{"line":15,"address":[267314],"length":1,"stats":{"Line":0},"fn_name":null},{"line":16,"address":[166170,166144],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":20,"address":[267424,270792],"length":1,"stats":{"Line":0},"fn_name":"derive_encodable_inner"},{"line":21,"address":[267447],"length":1,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[267533],"length":1,"stats":{"Line":0},"fn_name":null},{"line":23,"address":[267855,267541,267733],"length":1,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[267840,268101,268150,267938],"length":1,"stats":{"Line":0},"fn_name":null},{"line":25,"address":[268254,268606,268679,268206,268086],"length":1,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[268762,268386,268883],"length":1,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[269204],"length":1,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[270009],"length":1,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[270816],"length":1,"stats":{"Line":2},"fn_name":"token_stream"},{"line":62,"address":[270877,270843],"length":1,"stats":{"Line":4},"fn_name":null},{"line":63,"address":[166208,166231],"length":1,"stats":{"Line":4},"fn_name":"{closure#0}"},{"line":64,"address":[270900],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":4,"coverable":16},{"path":["/","home","trangar","development","rust","bincode","derive","src","parse.rs"],"content":"use crate::{Error, Result};\nuse proc_macro2::{Ident, Span, TokenTree};\nuse std::iter::Peekable;\n\n#[derive(Debug, PartialEq, Copy, Clone)]\npub enum Visibility {\n    Pub,\n    PubCrate,\n}\n\nimpl Visibility {\n    pub fn try_take(input: \u0026mut Peekable\u003cimpl Iterator\u003cItem = TokenTree\u003e\u003e) -\u003e Result\u003cOption\u003cSelf\u003e\u003e {\n        if let Some(TokenTree::Ident(ident)) = input.peek() {\n            if ident.to_string() == \"pub\" {\n                // Consume this token\n                let ident = assume_ident(input.next());\n\n                // check if the next token is `pub(crate)`\n                if let Some(TokenTree::Group(_)) = input.peek() {\n                    let group = assume_group(input.next());\n                    let mut group_stream = group.stream().into_iter();\n                    return match (group_stream.next(), group_stream.next()) {\n                        (Some(TokenTree::Ident(ident)), None) =\u003e {\n                            if ident.to_string() == \"crate\" {\n                                return Ok(Some(Visibility::PubCrate));\n                            } else {\n                                Err(Error::UnknownVisibility(ident.span()))\n                            }\n                        }\n                        _ =\u003e Err(Error::UnknownVisibility(ident.span())),\n                    };\n                }\n\n                return Ok(Some(Visibility::Pub));\n            }\n        }\n        Ok(None)\n    }\n}\n\n#[test]\nfn test_visibility_try_take() {\n    use crate::token_stream;\n\n    assert_eq!(Ok(None), Visibility::try_take(\u0026mut token_stream(\"\")));\n    assert_eq!(\n        Ok(Some(Visibility::Pub)),\n        Visibility::try_take(\u0026mut token_stream(\"pub\"))\n    );\n    assert_eq!(\n        Ok(Some(Visibility::Pub)),\n        Visibility::try_take(\u0026mut token_stream(\" pub \"))\n    );\n    assert_eq!(\n        Ok(Some(Visibility::Pub)),\n        Visibility::try_take(\u0026mut token_stream(\"\\tpub\\t\"))\n    );\n    assert_eq!(\n        Ok(Some(Visibility::PubCrate)),\n        Visibility::try_take(\u0026mut token_stream(\"pub(crate)\"))\n    );\n    assert_eq!(\n        Ok(Some(Visibility::PubCrate)),\n        Visibility::try_take(\u0026mut token_stream(\" pub ( crate ) \"))\n    );\n    assert_eq!(\n        Ok(Some(Visibility::PubCrate)),\n        Visibility::try_take(\u0026mut token_stream(\"\\tpub\\t(\\tcrate\\t)\\t\"))\n    );\n\n    assert!(Visibility::try_take(\u0026mut token_stream(\"pub(foo)\"))\n        .unwrap_err()\n        .is_unknown_visibility());\n\n    assert!(Visibility::try_take(\u0026mut token_stream(\"pub(,)\"))\n        .unwrap_err()\n        .is_unknown_visibility());\n\n    assert_eq!(Ok(None), Visibility::try_take(\u0026mut token_stream(\"pb\")));\n}\n\n#[derive(Debug, Clone)]\npub enum DataType {\n    Enum(Ident),\n    Struct(Ident),\n}\n\nimpl DataType {\n    pub fn take(input: \u0026mut Peekable\u003cimpl Iterator\u003cItem = TokenTree\u003e\u003e) -\u003e Result\u003cSelf\u003e {\n        if let Some(TokenTree::Ident(ident)) = input.peek() {\n            let result = match ident.to_string().as_str() {\n                \"struct\" =\u003e DataType::Struct,\n                \"enum\" =\u003e DataType::Enum,\n                _ =\u003e return Err(Error::UnknownDataType(ident.span())),\n            };\n            let ident = assume_ident(input.next());\n            return match input.next() {\n                Some(TokenTree::Ident(ident)) =\u003e Ok((result)(ident)),\n                Some(t) =\u003e Err(Error::InvalidRustSyntax(t.span())),\n                None =\u003e Err(Error::InvalidRustSyntax(ident.span())),\n            };\n        }\n        let span = input\n            .peek()\n            .map(|t| t.span())\n            .unwrap_or_else(Span::call_site);\n        Err(Error::InvalidRustSyntax(span))\n    }\n\n    // pub fn ident(\u0026self) -\u003e String {\n    //     match self {\n    //         Self::Enum(ident) =\u003e ident,\n    //         Self::Struct(ident) =\u003e ident,\n    //     }\n    //     .to_string()\n    // }\n}\n\n#[cfg(test)]\nimpl DataType {\n    fn is_enum(\u0026self, ident: \u0026str) -\u003e bool {\n        if let Self::Enum(i) = self {\n            i.to_string() == ident\n        } else {\n            false\n        }\n    }\n    fn is_struct(\u0026self, ident: \u0026str) -\u003e bool {\n        if let Self::Struct(i) = self {\n            i.to_string() == ident\n        } else {\n            false\n        }\n    }\n}\n\n#[test]\nfn test_datatype_take() {\n    use crate::token_stream;\n\n    assert!(DataType::take(\u0026mut token_stream(\"enum\"))\n        .unwrap_err()\n        .is_invalid_rust_syntax());\n    assert!(DataType::take(\u0026mut token_stream(\"enum Foo\"))\n        .unwrap()\n        .is_enum(\"Foo\"));\n    assert!(DataType::take(\u0026mut token_stream(\"enum Foo { }\"))\n        .unwrap()\n        .is_enum(\"Foo\"));\n    assert!(DataType::take(\u0026mut token_stream(\"enum Foo { bar, baz }\"))\n        .unwrap()\n        .is_enum(\"Foo\"));\n    assert!(\n        DataType::take(\u0026mut token_stream(\"enum Foo\u003c'a, T\u003e { bar, baz }\"))\n            .unwrap()\n            .is_enum(\"Foo\")\n    );\n\n    assert!(DataType::take(\u0026mut token_stream(\"struct\"))\n        .unwrap_err()\n        .is_invalid_rust_syntax());\n    assert!(DataType::take(\u0026mut token_stream(\"struct Foo { }\"))\n        .unwrap()\n        .is_struct(\"Foo\"));\n    assert!(\n        DataType::take(\u0026mut token_stream(\"struct Foo { bar: u32, baz: u32 }\"))\n            .unwrap()\n            .is_struct(\"Foo\")\n    );\n    assert!(\n        DataType::take(\u0026mut token_stream(\"struct Foo\u003c'a, T\u003e { bar: \u0026'a T }\"))\n            .unwrap()\n            .is_struct(\"Foo\")\n    );\n\n    assert!(DataType::take(\u0026mut token_stream(\"fn foo() {}\"))\n        .unwrap_err()\n        .is_unknown_data_type());\n\n    assert!(DataType::take(\u0026mut token_stream(\"() {}\"))\n        .unwrap_err()\n        .is_invalid_rust_syntax());\n\n    assert!(DataType::take(\u0026mut token_stream(\"\"))\n        .unwrap_err()\n        .is_invalid_rust_syntax());\n}\n\n#[derive(Debug)]\npub struct Generics {\n    lifetimes: Vec\u003cLifetime\u003e,\n    generics: Vec\u003cGeneric\u003e,\n}\nimpl Generics {\n    pub fn try_take(input: \u0026mut Peekable\u003cimpl Iterator\u003cItem = TokenTree\u003e\u003e) -\u003e Result\u003cOption\u003cSelf\u003e\u003e {\n        let maybe_punct = input.peek();\n        if let Some(TokenTree::Punct(punct)) = maybe_punct {\n            if punct.as_char() == '\u003c' {\n                let punct = assume_punct(input.next(), '\u003c');\n                let mut result = Generics {\n                    lifetimes: Vec::new(),\n                    generics: Vec::new(),\n                };\n                loop {\n                    match input.peek() {\n                        Some(TokenTree::Punct(punct)) if punct.as_char() == '\\'' =\u003e {\n                            result.lifetimes.push(Lifetime::take(input)?);\n                            consume_punct_if(input, \",\");\n                        }\n                        Some(TokenTree::Punct(punct)) if punct.as_char() == '\u003e' =\u003e {\n                            break;\n                        }\n                        Some(TokenTree::Ident(_)) =\u003e {\n                            result.generics.push(Generic::take(input)?);\n                            consume_punct_if(input, \",\");\n                        }\n                        x =\u003e {\n                            return Err(Error::InvalidRustSyntax(\n                                x.map(|x| x.span()).unwrap_or_else(|| punct.span()),\n                            ));\n                        }\n                    }\n                }\n                return Ok(Some(result));\n            }\n        }\n        Ok(None)\n    }\n}\n\n#[test]\nfn test_generics_try_take() {\n    use crate::token_stream;\n\n    assert!(Generics::try_take(\u0026mut token_stream(\"\")).unwrap().is_none());\n    assert!(Generics::try_take(\u0026mut token_stream(\"foo\"))\n        .unwrap()\n        .is_none());\n    assert!(Generics::try_take(\u0026mut token_stream(\"()\"))\n        .unwrap()\n        .is_none());\n\n    let mut stream = token_stream(\"struct Foo\u003c'a, T\u003e()\");\n    assert!(DataType::take(\u0026mut stream).unwrap().is_struct(\"Foo\"));\n    let generics = Generics::try_take(\u0026mut stream).unwrap().unwrap();\n    assert_eq!(generics.lifetimes.len(), 1);\n    assert_eq!(generics.generics.len(), 1);\n    assert!(generics.lifetimes[0].is_ident(\"a\"));\n    assert!(generics.generics[0].is_ident(\"T\"));\n\n    let mut stream = token_stream(\"struct Foo\u003cA, B\u003e()\");\n    assert!(DataType::take(\u0026mut stream).unwrap().is_struct(\"Foo\"));\n    let generics = Generics::try_take(\u0026mut stream).unwrap().unwrap();\n    assert_eq!(generics.lifetimes.len(), 0);\n    assert_eq!(generics.generics.len(), 2);\n    assert!(generics.generics[0].is_ident(\"A\"));\n    assert!(generics.generics[1].is_ident(\"B\"));\n\n    let mut stream = token_stream(\"struct Foo\u003c'a, T: Display\u003e()\");\n    assert!(DataType::take(\u0026mut stream).unwrap().is_struct(\"Foo\"));\n    let generics = Generics::try_take(\u0026mut stream).unwrap().unwrap();\n    dbg!(\u0026generics);\n    assert_eq!(generics.lifetimes.len(), 1);\n    assert_eq!(generics.generics.len(), 1);\n    assert!(generics.lifetimes[0].is_ident(\"a\"));\n    assert!(generics.generics[0].is_ident(\"T\"));\n\n    let mut stream = token_stream(\"struct Foo\u003c'a, T: for\u003c'a\u003e Bar\u003c'a\u003e + 'static\u003e()\");\n    assert!(DataType::take(\u0026mut stream).unwrap().is_struct(\"Foo\"));\n    let generics = Generics::try_take(\u0026mut stream).unwrap().unwrap();\n    dbg!(\u0026generics);\n    assert_eq!(generics.lifetimes.len(), 1);\n    assert_eq!(generics.generics.len(), 1);\n    assert!(generics.lifetimes[0].is_ident(\"a\"));\n    assert!(generics.generics[0].is_ident(\"T\"));\n\n    let mut stream =\n        token_stream(\"struct Baz\u003cT: for\u003c'a\u003e Bar\u003c'a, for\u003c'b\u003e Bar\u003c'b, for\u003c'c\u003e Bar\u003c'c, u32\u003e\u003e\u003e\u003e {}\");\n    assert!(DataType::take(\u0026mut stream).unwrap().is_struct(\"Baz\"));\n    let generics = Generics::try_take(\u0026mut stream).unwrap().unwrap();\n    dbg!(\u0026generics);\n    assert_eq!(generics.lifetimes.len(), 0);\n    assert_eq!(generics.generics.len(), 1);\n    assert!(generics.generics[0].is_ident(\"T\"));\n\n    let mut stream = token_stream(\"struct Baz\u003c()\u003e {}\");\n    assert!(DataType::take(\u0026mut stream).unwrap().is_struct(\"Baz\"));\n    assert!(Generics::try_take(\u0026mut stream)\n        .unwrap_err()\n        .is_invalid_rust_syntax());\n}\n\nfn assume_group(t: Option\u003cTokenTree\u003e) -\u003e proc_macro2::Group {\n    match t {\n        Some(TokenTree::Group(group)) =\u003e group,\n        _ =\u003e unreachable!(),\n    }\n}\nfn assume_ident(t: Option\u003cTokenTree\u003e) -\u003e proc_macro2::Ident {\n    match t {\n        Some(TokenTree::Ident(ident)) =\u003e ident,\n        _ =\u003e unreachable!(),\n    }\n}\nfn assume_punct(t: Option\u003cTokenTree\u003e, punct: char) -\u003e proc_macro2::Punct {\n    match t {\n        Some(TokenTree::Punct(p)) =\u003e {\n            debug_assert_eq!(punct, p.as_char());\n            p\n        }\n        _ =\u003e unreachable!(),\n    }\n}\n\nfn consume_punct_if(input: \u0026mut Peekable\u003cimpl Iterator\u003cItem = TokenTree\u003e\u003e, punct: \u0026str) {\n    if let Some(TokenTree::Punct(p)) = input.peek() {\n        if p.to_string() == punct {\n            input.next();\n        }\n    }\n}\n\n#[derive(Debug)]\nstruct Lifetime {\n    ident: Ident,\n}\n\nimpl Lifetime {\n    pub fn take(input: \u0026mut Peekable\u003cimpl Iterator\u003cItem = TokenTree\u003e\u003e) -\u003e Result\u003cSelf\u003e {\n        let start = assume_punct(input.next(), '\\'');\n        match input.peek() {\n            Some(TokenTree::Ident(_)) =\u003e {\n                let ident = assume_ident(input.next());\n                Ok(Lifetime { ident })\n            }\n            Some(t) =\u003e Err(Error::ExpectedIdent(t.span())),\n            None =\u003e Err(Error::ExpectedIdent(start.span())),\n        }\n    }\n\n    #[cfg(test)]\n    fn is_ident(\u0026self, s: \u0026str) -\u003e bool {\n        self.ident.to_string() == s\n    }\n}\n\n#[test]\nfn test_lifetime_take() {\n    use crate::token_stream;\n    use std::panic::catch_unwind;\n    assert!(Lifetime::take(\u0026mut token_stream(\"'a\"))\n        .unwrap()\n        .is_ident(\"a\"));\n    assert!(catch_unwind(|| Lifetime::take(\u0026mut token_stream(\"\"))).is_err());\n    assert!(catch_unwind(|| Lifetime::take(\u0026mut token_stream(\"'0\"))).is_err());\n    assert!(catch_unwind(|| Lifetime::take(\u0026mut token_stream(\"'(\"))).is_err());\n    assert!(catch_unwind(|| Lifetime::take(\u0026mut token_stream(\"')\"))).is_err());\n    assert!(catch_unwind(|| Lifetime::take(\u0026mut token_stream(\"'0'\"))).is_err());\n}\n\n#[derive(Debug)]\nstruct Generic {\n    ident: Ident,\n    constraints: Vec\u003cTokenTree\u003e,\n}\n\nimpl Generic {\n    pub fn take(input: \u0026mut Peekable\u003cimpl Iterator\u003cItem = TokenTree\u003e\u003e) -\u003e Result\u003cSelf\u003e {\n        let ident = assume_ident(input.next());\n        let mut constraints = Vec::new();\n        if let Some(TokenTree::Punct(punct)) = input.peek() {\n            if punct.as_char() == ':' {\n                assume_punct(input.next(), ':');\n                let mut open_brackets = Vec::\u003cchar\u003e::new();\n                loop {\n                    match input.peek() {\n                        Some(TokenTree::Punct(punct)) =\u003e {\n                            dbg!(punct);\n                            if ['\u003c', '(', '[', '{'].contains(\u0026punct.as_char()) {\n                                open_brackets.push(punct.as_char());\n                            } else if ['\u003e', ')', ']', '}'].contains(\u0026punct.as_char()) {\n                                let last_bracket = match open_brackets.pop() {\n                                    Some(bracket) =\u003e bracket,\n                                    None if punct.as_char() == '\u003e' =\u003e {\n                                        // we're done but we encountered the closing bracket of the entire generic\n                                        break;\n                                    }\n                                    None =\u003e {\n                                        return Err(Error::InvalidRustSyntax(punct.span()));\n                                    }\n                                };\n                                let expected = match last_bracket {\n                                    '\u003c' =\u003e '\u003e',\n                                    '{' =\u003e '}',\n                                    '(' =\u003e ')',\n                                    '[' =\u003e ']',\n                                    _ =\u003e unreachable!(),\n                                };\n                                assert_eq!(\n                                    expected,\n                                    punct.as_char(),\n                                    \"Unexpected closing bracket: found {}, expected {}\",\n                                    punct.as_char(),\n                                    expected\n                                );\n                            } else if punct.as_char() == ',' \u0026\u0026 open_brackets.is_empty() {\n                                break;\n                            }\n                            constraints.push(input.next().unwrap());\n                        }\n                        Some(_) =\u003e constraints.push(input.next().unwrap()),\n                        None =\u003e {\n                            return Err(Error::InvalidRustSyntax(\n                                constraints\n                                    .last()\n                                    .map(|c| c.span())\n                                    .unwrap_or_else(|| ident.span()),\n                            ))\n                        }\n                    }\n                }\n            }\n        }\n        Ok(Generic { ident, constraints })\n    }\n\n    #[cfg(test)]\n    fn is_ident(\u0026self, i: \u0026str) -\u003e bool {\n        self.ident.to_string() == i\n    }\n}\n","traces":[{"line":12,"address":[308162,307968],"length":1,"stats":{"Line":1},"fn_name":"try_take\u003cproc_macro2::token_stream::IntoIter\u003e"},{"line":13,"address":[308187,307988],"length":1,"stats":{"Line":2},"fn_name":null},{"line":14,"address":[308089,308181,308061],"length":1,"stats":{"Line":3},"fn_name":null},{"line":16,"address":[308194],"length":1,"stats":{"Line":1},"fn_name":null},{"line":19,"address":[308230,308324],"length":1,"stats":{"Line":2},"fn_name":null},{"line":20,"address":[308365,308404],"length":1,"stats":{"Line":2},"fn_name":null},{"line":21,"address":[308411],"length":1,"stats":{"Line":1},"fn_name":null},{"line":22,"address":[308506,308598,308694,308954],"length":1,"stats":{"Line":3},"fn_name":null},{"line":23,"address":[308662,308787,308735],"length":1,"stats":{"Line":3},"fn_name":null},{"line":24,"address":[309125,308856,309056],"length":1,"stats":{"Line":3},"fn_name":null},{"line":25,"address":[309217],"length":1,"stats":{"Line":1},"fn_name":null},{"line":27,"address":[309253,309192],"length":1,"stats":{"Line":2},"fn_name":null},{"line":30,"address":[308890,308765],"length":1,"stats":{"Line":2},"fn_name":null},{"line":34,"address":[308340],"length":1,"stats":{"Line":1},"fn_name":null},{"line":37,"address":[308074],"length":1,"stats":{"Line":1},"fn_name":null},{"line":42,"address":[289520,289871],"length":1,"stats":{"Line":3},"fn_name":"test_visibility_try_take"},{"line":45,"address":[289527],"length":1,"stats":{"Line":1},"fn_name":null},{"line":46,"address":[290009],"length":1,"stats":{"Line":1},"fn_name":null},{"line":48,"address":[289886],"length":1,"stats":{"Line":1},"fn_name":null},{"line":50,"address":[290358],"length":1,"stats":{"Line":1},"fn_name":null},{"line":52,"address":[290235],"length":1,"stats":{"Line":1},"fn_name":null},{"line":54,"address":[290707],"length":1,"stats":{"Line":1},"fn_name":null},{"line":56,"address":[290584],"length":1,"stats":{"Line":1},"fn_name":null},{"line":58,"address":[291056],"length":1,"stats":{"Line":1},"fn_name":null},{"line":60,"address":[290933],"length":1,"stats":{"Line":1},"fn_name":null},{"line":62,"address":[291405],"length":1,"stats":{"Line":1},"fn_name":null},{"line":64,"address":[291282],"length":1,"stats":{"Line":1},"fn_name":null},{"line":66,"address":[291754],"length":1,"stats":{"Line":1},"fn_name":null},{"line":68,"address":[291631],"length":1,"stats":{"Line":1},"fn_name":null},{"line":71,"address":[292268,291968],"length":1,"stats":{"Line":1},"fn_name":null},{"line":75,"address":[292573,292306,292241],"length":1,"stats":{"Line":2},"fn_name":null},{"line":79,"address":[292611,292546],"length":1,"stats":{"Line":2},"fn_name":null},{"line":89,"address":[309632,311014],"length":1,"stats":{"Line":1},"fn_name":"take\u003cproc_macro2::token_stream::IntoIter\u003e"},{"line":90,"address":[309741,309670],"length":1,"stats":{"Line":2},"fn_name":null},{"line":91,"address":[310157,309763,309928],"length":1,"stats":{"Line":3},"fn_name":null},{"line":92,"address":[310085,310044,309977],"length":1,"stats":{"Line":3},"fn_name":null},{"line":93,"address":[310060,310114,310145],"length":1,"stats":{"Line":3},"fn_name":null},{"line":94,"address":[310125,311038],"length":1,"stats":{"Line":2},"fn_name":null},{"line":96,"address":[310164],"length":1,"stats":{"Line":1},"fn_name":null},{"line":97,"address":[310211,310803,310878,310289],"length":1,"stats":{"Line":3},"fn_name":null},{"line":98,"address":[310319,310770,310226],"length":1,"stats":{"Line":3},"fn_name":null},{"line":99,"address":[310456],"length":1,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[310291,310814],"length":1,"stats":{"Line":2},"fn_name":null},{"line":103,"address":[309784,309729],"length":1,"stats":{"Line":2},"fn_name":null},{"line":105,"address":[311129,311120],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}\u003cproc_macro2::token_stream::IntoIter\u003e"},{"line":106,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[309853],"length":1,"stats":{"Line":1},"fn_name":null},{"line":121,"address":[287815,287664],"length":1,"stats":{"Line":1},"fn_name":"is_enum"},{"line":122,"address":[287688],"length":1,"stats":{"Line":1},"fn_name":null},{"line":123,"address":[287708,287750],"length":1,"stats":{"Line":2},"fn_name":null},{"line":125,"address":[287721],"length":1,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[287991,287840],"length":1,"stats":{"Line":1},"fn_name":"is_struct"},{"line":129,"address":[287864],"length":1,"stats":{"Line":1},"fn_name":null},{"line":130,"address":[287884,287926],"length":1,"stats":{"Line":2},"fn_name":null},{"line":132,"address":[287897],"length":1,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[293705,293520],"length":1,"stats":{"Line":3},"fn_name":"test_datatype_take"},{"line":141,"address":[293757,293527,293724],"length":1,"stats":{"Line":2},"fn_name":null},{"line":144,"address":[293730,294026,293803],"length":1,"stats":{"Line":2},"fn_name":null},{"line":147,"address":[294072,293999,294295],"length":1,"stats":{"Line":2},"fn_name":null},{"line":150,"address":[294268,294341,294564],"length":1,"stats":{"Line":2},"fn_name":null},{"line":153,"address":[294647,294724,294833],"length":1,"stats":{"Line":1},"fn_name":null},{"line":154,"address":[294537,294610,294687],"length":1,"stats":{"Line":3},"fn_name":null},{"line":159,"address":[294806,294879,295066],"length":1,"stats":{"Line":2},"fn_name":null},{"line":162,"address":[295039,295335,295112],"length":1,"stats":{"Line":2},"fn_name":null},{"line":165,"address":[295495,295418,295604],"length":1,"stats":{"Line":1},"fn_name":null},{"line":166,"address":[295381,295458,295308],"length":1,"stats":{"Line":3},"fn_name":null},{"line":170,"address":[295687,295873,295764],"length":1,"stats":{"Line":1},"fn_name":null},{"line":171,"address":[295577,295650,295727],"length":1,"stats":{"Line":3},"fn_name":null},{"line":176,"address":[295846,296106,295919],"length":1,"stats":{"Line":2},"fn_name":null},{"line":180,"address":[296079,296152,296338],"length":1,"stats":{"Line":2},"fn_name":null},{"line":184,"address":[296384,296312,296552],"length":1,"stats":{"Line":2},"fn_name":null},{"line":195,"address":[311168,311611],"length":1,"stats":{"Line":1},"fn_name":"try_take\u003cproc_macro2::token_stream::IntoIter\u003e"},{"line":196,"address":[311206],"length":1,"stats":{"Line":1},"fn_name":null},{"line":197,"address":[311369,311224],"length":1,"stats":{"Line":1},"fn_name":null},{"line":198,"address":[311347,311279],"length":1,"stats":{"Line":2},"fn_name":null},{"line":199,"address":[311394,311357],"length":1,"stats":{"Line":2},"fn_name":null},{"line":201,"address":[311440],"length":1,"stats":{"Line":1},"fn_name":null},{"line":202,"address":[311461],"length":1,"stats":{"Line":1},"fn_name":null},{"line":204,"address":[311572],"length":1,"stats":{"Line":1},"fn_name":null},{"line":205,"address":[312872,311631,312539],"length":1,"stats":{"Line":3},"fn_name":null},{"line":206,"address":[311659,311830,311724],"length":1,"stats":{"Line":3},"fn_name":null},{"line":207,"address":[312488,311926,312290],"length":1,"stats":{"Line":2},"fn_name":null},{"line":208,"address":[312520],"length":1,"stats":{"Line":1},"fn_name":null},{"line":210,"address":[311936],"length":1,"stats":{"Line":1},"fn_name":null},{"line":211,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":214,"address":[311799,312560,312793],"length":1,"stats":{"Line":2},"fn_name":null},{"line":215,"address":[312853],"length":1,"stats":{"Line":1},"fn_name":null},{"line":217,"address":[311760],"length":1,"stats":{"Line":1},"fn_name":null},{"line":218,"address":[312212],"length":1,"stats":{"Line":1},"fn_name":null},{"line":219,"address":[312928,312889,312880,311776,312937,312118],"length":1,"stats":{"Line":4},"fn_name":"{closure#0}\u003cproc_macro2::token_stream::IntoIter\u003e"},{"line":224,"address":[312010],"length":1,"stats":{"Line":1},"fn_name":null},{"line":227,"address":[311296],"length":1,"stats":{"Line":1},"fn_name":null},{"line":232,"address":[297070,296832],"length":1,"stats":{"Line":3},"fn_name":"test_generics_try_take"},{"line":235,"address":[297125,296845,297092],"length":1,"stats":{"Line":2},"fn_name":null},{"line":236,"address":[297171,297098,297394],"length":1,"stats":{"Line":2},"fn_name":null},{"line":239,"address":[297440,297663,297367],"length":1,"stats":{"Line":2},"fn_name":null},{"line":243,"address":[297636],"length":1,"stats":{"Line":1},"fn_name":null},{"line":244,"address":[297786,297927,297709],"length":1,"stats":{"Line":2},"fn_name":null},{"line":245,"address":[297959,297920],"length":1,"stats":{"Line":2},"fn_name":null},{"line":246,"address":[298027,298237],"length":1,"stats":{"Line":1},"fn_name":null},{"line":247,"address":[298195,298450,298297],"length":1,"stats":{"Line":2},"fn_name":null},{"line":248,"address":[298588,298510,298397],"length":1,"stats":{"Line":2},"fn_name":null},{"line":249,"address":[298697,298629,298551],"length":1,"stats":{"Line":2},"fn_name":null},{"line":251,"address":[298670],"length":1,"stats":{"Line":1},"fn_name":null},{"line":252,"address":[298964,298823,298746],"length":1,"stats":{"Line":2},"fn_name":null},{"line":253,"address":[298957,298997],"length":1,"stats":{"Line":2},"fn_name":null},{"line":254,"address":[299275,299065],"length":1,"stats":{"Line":1},"fn_name":null},{"line":255,"address":[299335,299488,299233],"length":1,"stats":{"Line":2},"fn_name":null},{"line":256,"address":[299627,299435,299548],"length":1,"stats":{"Line":2},"fn_name":null},{"line":257,"address":[299589,299668,299736],"length":1,"stats":{"Line":2},"fn_name":null},{"line":259,"address":[299709],"length":1,"stats":{"Line":1},"fn_name":null},{"line":260,"address":[299785,300003,299862],"length":1,"stats":{"Line":2},"fn_name":null},{"line":261,"address":[299996,300036],"length":1,"stats":{"Line":2},"fn_name":null},{"line":262,"address":[300104,300477],"length":1,"stats":{"Line":2},"fn_name":null},{"line":263,"address":[300806,300974],"length":1,"stats":{"Line":1},"fn_name":null},{"line":264,"address":[301034,301187,300932],"length":1,"stats":{"Line":2},"fn_name":null},{"line":265,"address":[301134,301247,301325],"length":1,"stats":{"Line":2},"fn_name":null},{"line":266,"address":[301434,301288,301366],"length":1,"stats":{"Line":2},"fn_name":null},{"line":268,"address":[301407],"length":1,"stats":{"Line":1},"fn_name":null},{"line":269,"address":[301701,301483,301560],"length":1,"stats":{"Line":2},"fn_name":null},{"line":270,"address":[301734,301694],"length":1,"stats":{"Line":2},"fn_name":null},{"line":271,"address":[301802,302175],"length":1,"stats":{"Line":2},"fn_name":null},{"line":272,"address":[302504,302672],"length":1,"stats":{"Line":1},"fn_name":null},{"line":273,"address":[302732,302885,302630],"length":1,"stats":{"Line":2},"fn_name":null},{"line":274,"address":[303023,302945,302832],"length":1,"stats":{"Line":2},"fn_name":null},{"line":275,"address":[303064,303132,302986],"length":1,"stats":{"Line":2},"fn_name":null},{"line":279,"address":[303258,303399,303181],"length":1,"stats":{"Line":2},"fn_name":null},{"line":280,"address":[303392,303432],"length":1,"stats":{"Line":2},"fn_name":null},{"line":281,"address":[303500,303870],"length":1,"stats":{"Line":2},"fn_name":null},{"line":282,"address":[304172,304319],"length":1,"stats":{"Line":1},"fn_name":null},{"line":283,"address":[304286,304514,304376],"length":1,"stats":{"Line":2},"fn_name":null},{"line":284,"address":[304633,304571,304470],"length":1,"stats":{"Line":2},"fn_name":null},{"line":286,"address":[304606],"length":1,"stats":{"Line":1},"fn_name":null},{"line":287,"address":[304888,304682,304759],"length":1,"stats":{"Line":2},"fn_name":null},{"line":288,"address":[304881,304921,305026],"length":1,"stats":{"Line":2},"fn_name":null},{"line":293,"address":[288210,288016],"length":1,"stats":{"Line":1},"fn_name":"assume_group"},{"line":295,"address":[288108,288035],"length":1,"stats":{"Line":2},"fn_name":null},{"line":299,"address":[288466,288272],"length":1,"stats":{"Line":1},"fn_name":"assume_ident"},{"line":301,"address":[288364,288291],"length":1,"stats":{"Line":2},"fn_name":null},{"line":305,"address":[288528,288906],"length":1,"stats":{"Line":2},"fn_name":"assume_punct"},{"line":307,"address":[288617,288544],"length":1,"stats":{"Line":2},"fn_name":null},{"line":308,"address":[288633,288855,288722],"length":1,"stats":{"Line":2},"fn_name":null},{"line":309,"address":[288800],"length":1,"stats":{"Line":1},"fn_name":null},{"line":315,"address":[313159,312976],"length":1,"stats":{"Line":1},"fn_name":"consume_punct_if\u003cproc_macro2::token_stream::IntoIter\u003e"},{"line":316,"address":[313003],"length":1,"stats":{"Line":1},"fn_name":null},{"line":317,"address":[313068,313178,313212,313098],"length":1,"stats":{"Line":4},"fn_name":null},{"line":318,"address":[313191],"length":1,"stats":{"Line":1},"fn_name":null},{"line":329,"address":[313232],"length":1,"stats":{"Line":1},"fn_name":"take\u003cproc_macro2::token_stream::IntoIter\u003e"},{"line":330,"address":[313262],"length":1,"stats":{"Line":1},"fn_name":null},{"line":331,"address":[313363,313691,313333,313641],"length":1,"stats":{"Line":2},"fn_name":null},{"line":332,"address":[313402,313343],"length":1,"stats":{"Line":2},"fn_name":null},{"line":333,"address":[313536,313420],"length":1,"stats":{"Line":2},"fn_name":null},{"line":334,"address":[313554],"length":1,"stats":{"Line":1},"fn_name":null},{"line":336,"address":[313435],"length":1,"stats":{"Line":0},"fn_name":null},{"line":337,"address":[313648,313365],"length":1,"stats":{"Line":0},"fn_name":null},{"line":342,"address":[288992,289093],"length":1,"stats":{"Line":1},"fn_name":"is_ident"},{"line":343,"address":[289017],"length":1,"stats":{"Line":1},"fn_name":null},{"line":348,"address":[305595,305392],"length":1,"stats":{"Line":3},"fn_name":"test_lifetime_take"},{"line":351,"address":[305399,305635,305614],"length":1,"stats":{"Line":2},"fn_name":null},{"line":354,"address":[305620,305673,305776],"length":1,"stats":{"Line":4},"fn_name":null},{"line":355,"address":[305814,305917,305761],"length":1,"stats":{"Line":4},"fn_name":null},{"line":356,"address":[305902,306058,305955],"length":1,"stats":{"Line":4},"fn_name":null},{"line":357,"address":[306096,306043,306199],"length":1,"stats":{"Line":4},"fn_name":null},{"line":358,"address":[306184,306237,306333],"length":1,"stats":{"Line":4},"fn_name":null},{"line":368,"address":[316886,313696],"length":1,"stats":{"Line":1},"fn_name":"take\u003cproc_macro2::token_stream::IntoIter\u003e"},{"line":369,"address":[313735],"length":1,"stats":{"Line":1},"fn_name":null},{"line":370,"address":[313769],"length":1,"stats":{"Line":1},"fn_name":null},{"line":371,"address":[313937,313863,313796],"length":1,"stats":{"Line":3},"fn_name":null},{"line":372,"address":[314230,314202,313975],"length":1,"stats":{"Line":3},"fn_name":null},{"line":373,"address":[314223,314248],"length":1,"stats":{"Line":2},"fn_name":null},{"line":374,"address":[314346],"length":1,"stats":{"Line":1},"fn_name":null},{"line":375,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":376,"address":[314363,314460,316637],"length":1,"stats":{"Line":2},"fn_name":null},{"line":377,"address":[314397,314506],"length":1,"stats":{"Line":2},"fn_name":null},{"line":378,"address":[314554,314896],"length":1,"stats":{"Line":2},"fn_name":null},{"line":379,"address":[315466,315305],"length":1,"stats":{"Line":2},"fn_name":null},{"line":380,"address":[315424],"length":1,"stats":{"Line":1},"fn_name":null},{"line":381,"address":[315501,315955,315396,316553],"length":1,"stats":{"Line":4},"fn_name":null},{"line":382,"address":[315596,315650],"length":1,"stats":{"Line":1},"fn_name":null},{"line":383,"address":[315626,315683],"length":1,"stats":{"Line":2},"fn_name":null},{"line":384,"address":[315660,316341],"length":1,"stats":{"Line":2},"fn_name":null},{"line":386,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":388,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":389,"address":[316356],"length":1,"stats":{"Line":0},"fn_name":null},{"line":392,"address":[315789,315828,315802,315815],"length":1,"stats":{"Line":1},"fn_name":null},{"line":393,"address":[315778,315708],"length":1,"stats":{"Line":2},"fn_name":null},{"line":394,"address":[315791],"length":1,"stats":{"Line":0},"fn_name":null},{"line":395,"address":[315804],"length":1,"stats":{"Line":0},"fn_name":null},{"line":396,"address":[315817],"length":1,"stats":{"Line":0},"fn_name":null},{"line":399,"address":[315868,316012,315968],"length":1,"stats":{"Line":1},"fn_name":null},{"line":400,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":401,"address":[315840],"length":1,"stats":{"Line":1},"fn_name":null},{"line":403,"address":[315976],"length":1,"stats":{"Line":0},"fn_name":null},{"line":404,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":406,"address":[315565,316492],"length":1,"stats":{"Line":2},"fn_name":null},{"line":407,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":409,"address":[315484,316576],"length":1,"stats":{"Line":2},"fn_name":null},{"line":411,"address":[314783],"length":1,"stats":{"Line":1},"fn_name":null},{"line":412,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":413,"address":[316800],"length":1,"stats":{"Line":0},"fn_name":null},{"line":414,"address":[316738,314462,316658],"length":1,"stats":{"Line":0},"fn_name":null},{"line":415,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":416,"address":[316912,316921],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}\u003cproc_macro2::token_stream::IntoIter\u003e"},{"line":417,"address":[316960,316969,316730],"length":1,"stats":{"Line":0},"fn_name":"{closure#1}\u003cproc_macro2::token_stream::IntoIter\u003e"},{"line":424,"address":[313998],"length":1,"stats":{"Line":1},"fn_name":null},{"line":428,"address":[289221,289120],"length":1,"stats":{"Line":1},"fn_name":"is_ident"},{"line":429,"address":[289145],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":183,"coverable":208},{"path":["/","home","trangar","development","rust","bincode","rust-proc-macro-without-dependencies","default_derive","src","lib.rs"],"content":"extern crate proc_macro;\nuse proc_macro::{Delimiter, Group, Ident, Punct, TokenStream, TokenTree};\n\nuse std::iter::Peekable;\n\n#[derive(Debug)]\nenum VisibilityModifier {\n    Pub,\n    PubCrate,\n}\n\n#[derive(Debug)]\nenum DataType {\n    Enum,\n    Struct(Struct),\n}\n\n#[derive(Debug)]\nstruct Struct {\n    pub name: Ident,\n    pub fields: Vec\u003cField\u003e,\n}\n\n#[derive(Debug)]\nstruct Field {\n    pub visibility: Option\u003cVisibilityModifier\u003e,\n    pub name: Ident,\n    pub typ: Ident,\n}\n\n/// Parses a visibility modifier such as `pub`. This function will panic if it encounters\n/// a visibility modifier with an additional group specifier like `pub(crate)`\nfn next_visibility_modifier(\n    input: \u0026mut Peekable\u003cimpl Iterator\u003cItem = TokenTree\u003e\u003e,\n) -\u003e Option\u003cVisibilityModifier\u003e {\n    if let Some(TokenTree::Ident(ident)) = input.peek() {\n        if ident.to_string() == \"pub\" {\n            // Consume this token\n            input.next();\n\n            // TODO: We do not handle any modifiers besides `pub`\n            if let Some(TokenTree::Group(_)) = input.peek() {\n                panic!(\"Visibility modifies like pub(crate) are not yet handled\");\n            }\n\n            return Some(VisibilityModifier::Pub);\n        }\n    }\n\n    None\n}\n\n/// Parses a data type such as `struct` or `enum`.\nfn next_data_type\u003c'a\u003e(input: \u0026'a mut Peekable\u003cimpl Iterator\u003cItem = TokenTree\u003e\u003e) -\u003e DataType {\n    // The next token should either be a `struct` or `enum`\n    if let Some(TokenTree::Ident(ident)) = input.peek() {\n        if ident.to_string() != \"struct\" {\n            panic!(\"Data type `{}` is not yet supported\", ident);\n        }\n\n        // Consume the data type identifier\n        input.next();\n\n        let struct_name = next_ident(input).unwrap_or_else(|| {\n            let next = input.peek();\n            panic!(\"Expected a struct name, got {:?}\", next);\n        });\n\n        // TODO: Handle unit struct (`struct Foo;`)\n        let group = next_group(input)\n            .unwrap_or_else(|| panic!(\"Expected a struct group, got {:?}\", input.peek()));\n\n        // Examine the group delimiter to determine if this is a named or unnamed struct\n        match group.delimiter() {\n            Delimiter::Brace =\u003e {}\n            delim =\u003e panic!(\"Unsupported group delimiter: {:?}. Currently only braces (named structs) are supported\", delim)\n        }\n\n        let mut group_body = group.stream().into_iter().peekable();\n\n        return DataType::Struct(Struct {\n            name: struct_name,\n            fields: next_fields(\u0026mut group_body),\n        });\n    }\n\n    panic!(\"Unexpected token: {:?}\", input.next());\n}\n\nfn next_fields\u003c'a\u003e(input: \u0026'a mut Peekable\u003cimpl Iterator\u003cItem = TokenTree\u003e\u003e) -\u003e Vec\u003cField\u003e {\n    let mut fields = Vec::new();\n\n    // Loop until we reach EOF of this group we're in\n    while !next_eof(input) {\n        // At the beginning of this loop we should expect one of the following:\n        // `pub name: Type`\n        // `name: Type`\n\n        // Try to parse a visibility modifier\n        let visibility_modifier = next_visibility_modifier(input);\n\n        // Parse out the field name\n        let name = next_ident(input)\n            .unwrap_or_else(|| panic!(\"failed to parse field name (got: {:?})\", input.peek()));\n\n        // Parse the literal colon `:`\n        next_matching_punct(input, \":\").unwrap_or_else(|| {\n            panic!(\n                \"expected a colon following a struct field name, got: {:?}\",\n                input.peek()\n            )\n        });\n\n        // Parse the field type.\n        // TODO: This does not handle generics, lifetimes, references, or `fully::qualified::path::Names`.\n        let typ = next_ident(input).expect(\"failed to parse field type\");\n\n        // Finally, parse out trailing commas if they exist\n        next_matching_punct(input, \",\");\n\n        fields.push(Field {\n            visibility: visibility_modifier,\n            name,\n            typ,\n        });\n    }\n\n    fields\n}\n\n/// Consumes and returns the next `[proc_macro::Ident]`. Panics if the next token is\n/// empty or not an `Ident`.\nfn next_ident(input: \u0026mut Peekable\u003cimpl Iterator\u003cItem = TokenTree\u003e\u003e) -\u003e Option\u003cIdent\u003e {\n    if let Some(TokenTree::Ident(_)) = input.peek() {\n        // consume this token\n        if let Some(TokenTree::Ident(token)) = input.next() {\n            return Some(token);\n        }\n    }\n\n    None\n}\n\n/// Consumes and returns the next `[proc_macro::Group]`. This is something like: `(crate)`, `{stuff_in_braces}`,\n/// `[stuff_in_brackets]`.\nfn next_group\u003c'a\u003e(input: \u0026'a mut Peekable\u003cimpl Iterator\u003cItem = TokenTree\u003e\u003e) -\u003e Option\u003cGroup\u003e {\n    if let Some(TokenTree::Group(_)) = input.peek() {\n        // consume this token\n        if let Some(TokenTree::Group(group)) = input.next() {\n            return Some(group);\n        }\n    }\n\n    None\n}\n\n/// Returns whether the `input` has reached end-of-file\nfn next_eof(input: \u0026mut Peekable\u003cimpl Iterator\u003cItem = TokenTree\u003e\u003e) -\u003e bool {\n    input.peek().is_none()\n}\n\n/// Consumes and returns the next `[proc_macro::Punct]` if it matches the given string.\nfn next_matching_punct\u003c'a\u003e(\n    input: \u0026'a mut Peekable\u003cimpl Iterator\u003cItem = TokenTree\u003e\u003e,\n    matching_str: \u0026str,\n) -\u003e Option\u003cPunct\u003e {\n    if let Some(TokenTree::Punct(punct)) = input.peek() {\n        if punct.to_string() != matching_str {\n            return None;\n        }\n\n        // Consume this token\n        if let Some(TokenTree::Punct(punct)) = input.next() {\n            return Some(punct);\n        }\n    }\n\n    None\n}\n\n#[proc_macro_derive(OurDefault)]\npub fn default_derive(input: TokenStream) -\u003e TokenStream {\n    // We assume an input that looks loosely like the following:\n    //\n    // pub struct Foo {\n    //    pub a: String,\n    //    b: usize,\n    // }\n    //\n    // At this times enums, lifetime specifiers, unnamed fields, and generic parameters\n    // are not supported.\n\n    // Convert the input to an iterator so we can start peeking tokens\n    let mut source = input.into_iter().peekable();\n\n    // We assume that the first token is going to be either a keyword like `pub`\n    // or `pub(crate), or the data type.\n    let _visibility = next_visibility_modifier(\u0026mut source);\n\n    // Parse the struct\n    let parsed_data_type = next_data_type(\u0026mut source);\n\n    let result_text = match parsed_data_type {\n        DataType::Struct(s) =\u003e {\n            // Map each field to the form of:\n            // `field_name: Default::default(),`\n            let field_initializers = s\n                .fields\n                .iter()\n                .map(|field| format!(\"{}: Default::default()\", field.name))\n                .collect::\u003cVec\u003cString\u003e\u003e()\n                .join(\"\\n,\");\n\n            // Struct has been parsed -- let's emit our impl\n            format!(\n                \"#[automatically_derived] \\\n                impl crate::OurDefault for {} {{ \\\n                    fn our_default() -\u003e Self {{ \\\n                        {} {{\n                            {}\n                        }}\n                    }}\n                }}\",\n                s.name, s.name, field_initializers\n            )\n        }\n        _ =\u003e panic!(\"Only structs are currently supported\"),\n    };\n\n    result_text\n        .parse::\u003cTokenStream\u003e()\n        .expect(\"proc macro generated invalid tokens\")\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","trangar","development","rust","bincode","rust-proc-macro-without-dependencies","default_derive_tester","src","main.rs"],"content":"use default_derive::OurDefault;\n\ntrait OurDefault {\n    fn our_default() -\u003e Self;\n}\n\nfn main() {\n    #[derive(Debug, PartialEq, Eq, OurDefault, Default)]\n    pub struct TestStruct {\n        foo: String,\n        pub bar: usize,\n    }\n\n    assert_eq!(TestStruct::our_default(), TestStruct::default())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","trangar","development","rust","bincode","src","config.rs"],"content":"pub(crate) use self::internal::*;\nuse core::marker::PhantomData;\n\npub trait Config: InternalConfig + Copy + Clone + Sized {\n    fn with_big_endian(self) -\u003e BigEndian\u003cSelf\u003e {\n        BigEndian { _pd: PhantomData }\n    }\n    fn with_little_endian(self) -\u003e LittleEndian\u003cSelf\u003e {\n        LittleEndian { _pd: PhantomData }\n    }\n    fn with_variable_int_encoding(self) -\u003e Varint\u003cSelf\u003e {\n        Varint { _pd: PhantomData }\n    }\n    fn with_fixed_int_encoding(self) -\u003e Fixint\u003cSelf\u003e {\n        Fixint { _pd: PhantomData }\n    }\n}\n\nimpl\u003cT: InternalConfig\u003e Config for T {}\n\n#[derive(Copy, Clone)]\npub struct Default;\n\nimpl InternalConfig for Default {\n    const ENDIAN: Endian = Endian::Little;\n    const INT_ENCODING: IntEncoding = IntEncoding::Variable;\n    const LIMIT: Option\u003cu64\u003e = None;\n    const ALLOW_TRAILING: bool = true;\n}\n\n#[derive(Copy, Clone)]\npub struct BigEndian\u003cC: Config\u003e {\n    _pd: PhantomData\u003cC\u003e,\n}\n\nimpl\u003cC: InternalConfig\u003e InternalConfig for BigEndian\u003cC\u003e {\n    const ENDIAN: Endian = Endian::Big;\n    const INT_ENCODING: IntEncoding = C::INT_ENCODING;\n    const LIMIT: Option\u003cu64\u003e = C::LIMIT;\n    const ALLOW_TRAILING: bool = C::ALLOW_TRAILING;\n}\n\n#[derive(Copy, Clone)]\npub struct LittleEndian\u003cC: Config\u003e {\n    _pd: PhantomData\u003cC\u003e,\n}\n\nimpl\u003cC: InternalConfig\u003e InternalConfig for LittleEndian\u003cC\u003e {\n    const ENDIAN: Endian = Endian::Little;\n    const INT_ENCODING: IntEncoding = C::INT_ENCODING;\n    const LIMIT: Option\u003cu64\u003e = C::LIMIT;\n    const ALLOW_TRAILING: bool = C::ALLOW_TRAILING;\n}\n\n#[derive(Copy, Clone)]\npub struct Fixint\u003cC: Config\u003e {\n    _pd: PhantomData\u003cC\u003e,\n}\n\nimpl\u003cC: InternalConfig\u003e InternalConfig for Fixint\u003cC\u003e {\n    const ENDIAN: Endian = C::ENDIAN;\n    const INT_ENCODING: IntEncoding = IntEncoding::Fixed;\n    const LIMIT: Option\u003cu64\u003e = C::LIMIT;\n    const ALLOW_TRAILING: bool = C::ALLOW_TRAILING;\n}\n\n#[derive(Copy, Clone)]\npub struct Varint\u003cC: Config\u003e {\n    _pd: PhantomData\u003cC\u003e,\n}\n\nimpl\u003cC: InternalConfig\u003e InternalConfig for Varint\u003cC\u003e {\n    const ENDIAN: Endian = C::ENDIAN;\n    const INT_ENCODING: IntEncoding = IntEncoding::Variable;\n    const LIMIT: Option\u003cu64\u003e = C::LIMIT;\n    const ALLOW_TRAILING: bool = C::ALLOW_TRAILING;\n}\n\nmod internal {\n    pub trait InternalConfig: Copy + Clone {\n        const ENDIAN: Endian;\n        const INT_ENCODING: IntEncoding;\n        const LIMIT: Option\u003cu64\u003e;\n        const ALLOW_TRAILING: bool;\n    }\n\n    #[derive(PartialEq, Eq)]\n    pub enum Endian {\n        Little,\n        Big,\n    }\n\n    #[derive(PartialEq, Eq)]\n    pub enum IntEncoding {\n        Fixed,\n        Variable,\n    }\n\n    impl\u003c'a, C: InternalConfig\u003e InternalConfig for \u0026'a mut C\n    where\n        \u0026'a mut C: Copy + Clone,\n    {\n        const ENDIAN: Endian = C::ENDIAN;\n        const INT_ENCODING: IntEncoding = C::INT_ENCODING;\n        const LIMIT: Option\u003cu64\u003e = C::LIMIT;\n        const ALLOW_TRAILING: bool = C::ALLOW_TRAILING;\n    }\n}\n","traces":[{"line":5,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":6,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":8,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":9,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":11,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":12,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":14,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":8},{"path":["/","home","trangar","development","rust","bincode","src","de","decoder.rs"],"content":"use super::{\n    read::{BorrowReader, Reader},\n    BorrowDecode, Decode,\n};\nuse crate::{\n    config::{Config, Endian, IntEncoding},\n    error::DecodeError,\n};\nuse core::marker::PhantomData;\n\npub struct Decoder\u003cR, C: Config\u003e {\n    reader: R,\n    config: PhantomData\u003cC\u003e,\n}\n\nimpl\u003c'de, R: Reader\u003c'de\u003e, C: Config\u003e Decoder\u003cR, C\u003e {\n    pub fn new(reader: R, _config: C) -\u003e Decoder\u003cR, C\u003e {\n        Decoder {\n            reader,\n            config: PhantomData,\n        }\n    }\n\n    pub fn into_reader(self) -\u003e R {\n        self.reader\n    }\n}\n\nimpl\u003c'a, 'de, R: BorrowReader\u003c'de\u003e, C: Config\u003e BorrowDecode\u003c'de\u003e for \u0026'a mut Decoder\u003cR, C\u003e {\n    fn decode_slice(\u0026mut self, len: usize) -\u003e Result\u003c\u0026'de [u8], DecodeError\u003e {\n        self.reader.take_bytes(len)\n    }\n}\n\nimpl\u003c'a, 'de, R: Reader\u003c'de\u003e, C: Config\u003e Decode for \u0026'a mut Decoder\u003cR, C\u003e {\n    fn decode_u8(\u0026mut self) -\u003e Result\u003cu8, DecodeError\u003e {\n        let mut bytes = [0u8; 1];\n        self.reader.read(\u0026mut bytes)?;\n        Ok(bytes[0])\n    }\n\n    fn decode_u16(\u0026mut self) -\u003e Result\u003cu16, DecodeError\u003e {\n        match C::INT_ENCODING {\n            IntEncoding::Variable =\u003e crate::varint::varint_decode_u16(\u0026mut self.reader, C::ENDIAN),\n            IntEncoding::Fixed =\u003e {\n                let mut bytes = [0u8; 2];\n                self.reader.read(\u0026mut bytes)?;\n                Ok(match C::ENDIAN {\n                    Endian::Little =\u003e u16::from_le_bytes(bytes),\n                    Endian::Big =\u003e u16::from_be_bytes(bytes),\n                })\n            }\n        }\n    }\n\n    fn decode_u32(\u0026mut self) -\u003e Result\u003cu32, DecodeError\u003e {\n        match C::INT_ENCODING {\n            IntEncoding::Variable =\u003e crate::varint::varint_decode_u32(\u0026mut self.reader, C::ENDIAN),\n            IntEncoding::Fixed =\u003e {\n                let mut bytes = [0u8; 4];\n                self.reader.read(\u0026mut bytes)?;\n                Ok(match C::ENDIAN {\n                    Endian::Little =\u003e u32::from_le_bytes(bytes),\n                    Endian::Big =\u003e u32::from_be_bytes(bytes),\n                })\n            }\n        }\n    }\n\n    fn decode_u64(\u0026mut self) -\u003e Result\u003cu64, DecodeError\u003e {\n        match C::INT_ENCODING {\n            IntEncoding::Variable =\u003e crate::varint::varint_decode_u64(\u0026mut self.reader, C::ENDIAN),\n            IntEncoding::Fixed =\u003e {\n                let mut bytes = [0u8; 8];\n                self.reader.read(\u0026mut bytes)?;\n                Ok(match C::ENDIAN {\n                    Endian::Little =\u003e u64::from_le_bytes(bytes),\n                    Endian::Big =\u003e u64::from_be_bytes(bytes),\n                })\n            }\n        }\n    }\n\n    fn decode_u128(\u0026mut self) -\u003e Result\u003cu128, DecodeError\u003e {\n        match C::INT_ENCODING {\n            IntEncoding::Variable =\u003e crate::varint::varint_decode_u128(\u0026mut self.reader, C::ENDIAN),\n            IntEncoding::Fixed =\u003e {\n                let mut bytes = [0u8; 16];\n                self.reader.read(\u0026mut bytes)?;\n                Ok(match C::ENDIAN {\n                    Endian::Little =\u003e u128::from_le_bytes(bytes),\n                    Endian::Big =\u003e u128::from_be_bytes(bytes),\n                })\n            }\n        }\n    }\n\n    fn decode_usize(\u0026mut self) -\u003e Result\u003cusize, DecodeError\u003e {\n        match C::INT_ENCODING {\n            IntEncoding::Variable =\u003e {\n                crate::varint::varint_decode_usize(\u0026mut self.reader, C::ENDIAN)\n            }\n            IntEncoding::Fixed =\u003e {\n                let mut bytes = [0u8; 8];\n                self.reader.read(\u0026mut bytes)?;\n                Ok(match C::ENDIAN {\n                    Endian::Little =\u003e u64::from_le_bytes(bytes),\n                    Endian::Big =\u003e u64::from_be_bytes(bytes),\n                } as usize)\n            }\n        }\n    }\n\n    fn decode_i8(\u0026mut self) -\u003e Result\u003ci8, DecodeError\u003e {\n        let mut bytes = [0u8; 1];\n        self.reader.read(\u0026mut bytes)?;\n        Ok(bytes[0] as i8)\n    }\n\n    fn decode_i16(\u0026mut self) -\u003e Result\u003ci16, DecodeError\u003e {\n        match C::INT_ENCODING {\n            IntEncoding::Variable =\u003e crate::varint::varint_decode_i16(\u0026mut self.reader, C::ENDIAN),\n            IntEncoding::Fixed =\u003e {\n                let mut bytes = [0u8; 2];\n                self.reader.read(\u0026mut bytes)?;\n                Ok(match C::ENDIAN {\n                    Endian::Little =\u003e i16::from_le_bytes(bytes),\n                    Endian::Big =\u003e i16::from_be_bytes(bytes),\n                })\n            }\n        }\n    }\n\n    fn decode_i32(\u0026mut self) -\u003e Result\u003ci32, DecodeError\u003e {\n        match C::INT_ENCODING {\n            IntEncoding::Variable =\u003e crate::varint::varint_decode_i32(\u0026mut self.reader, C::ENDIAN),\n            IntEncoding::Fixed =\u003e {\n                let mut bytes = [0u8; 4];\n                self.reader.read(\u0026mut bytes)?;\n                Ok(match C::ENDIAN {\n                    Endian::Little =\u003e i32::from_le_bytes(bytes),\n                    Endian::Big =\u003e i32::from_be_bytes(bytes),\n                })\n            }\n        }\n    }\n\n    fn decode_i64(\u0026mut self) -\u003e Result\u003ci64, DecodeError\u003e {\n        match C::INT_ENCODING {\n            IntEncoding::Variable =\u003e crate::varint::varint_decode_i64(\u0026mut self.reader, C::ENDIAN),\n            IntEncoding::Fixed =\u003e {\n                let mut bytes = [0u8; 8];\n                self.reader.read(\u0026mut bytes)?;\n                Ok(match C::ENDIAN {\n                    Endian::Little =\u003e i64::from_le_bytes(bytes),\n                    Endian::Big =\u003e i64::from_be_bytes(bytes),\n                })\n            }\n        }\n    }\n\n    fn decode_i128(\u0026mut self) -\u003e Result\u003ci128, DecodeError\u003e {\n        match C::INT_ENCODING {\n            IntEncoding::Variable =\u003e crate::varint::varint_decode_i128(\u0026mut self.reader, C::ENDIAN),\n            IntEncoding::Fixed =\u003e {\n                let mut bytes = [0u8; 16];\n                self.reader.read(\u0026mut bytes)?;\n                Ok(match C::ENDIAN {\n                    Endian::Little =\u003e i128::from_le_bytes(bytes),\n                    Endian::Big =\u003e i128::from_be_bytes(bytes),\n                })\n            }\n        }\n    }\n\n    fn decode_isize(\u0026mut self) -\u003e Result\u003cisize, DecodeError\u003e {\n        match C::INT_ENCODING {\n            IntEncoding::Variable =\u003e {\n                crate::varint::varint_decode_isize(\u0026mut self.reader, C::ENDIAN)\n            }\n            IntEncoding::Fixed =\u003e {\n                let mut bytes = [0u8; 8];\n                self.reader.read(\u0026mut bytes)?;\n                Ok(match C::ENDIAN {\n                    Endian::Little =\u003e i64::from_le_bytes(bytes),\n                    Endian::Big =\u003e i64::from_be_bytes(bytes),\n                } as isize)\n            }\n        }\n    }\n\n    fn decode_f32(\u0026mut self) -\u003e Result\u003cf32, DecodeError\u003e {\n        let mut bytes = [0u8; 4];\n        self.reader.read(\u0026mut bytes)?;\n        Ok(match C::ENDIAN {\n            Endian::Little =\u003e f32::from_le_bytes(bytes),\n            Endian::Big =\u003e f32::from_be_bytes(bytes),\n        })\n    }\n\n    fn decode_f64(\u0026mut self) -\u003e Result\u003cf64, DecodeError\u003e {\n        let mut bytes = [0u8; 8];\n        self.reader.read(\u0026mut bytes)?;\n        Ok(match C::ENDIAN {\n            Endian::Little =\u003e f64::from_le_bytes(bytes),\n            Endian::Big =\u003e f64::from_be_bytes(bytes),\n        })\n    }\n\n    fn decode_array\u003cconst N: usize\u003e(\u0026mut self) -\u003e Result\u003c[u8; N], DecodeError\u003e {\n        let mut array = [0u8; N];\n        self.reader.read(\u0026mut array)?;\n        Ok(array)\n    }\n}\n","traces":[{"line":17,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":182,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":186,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":193,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":194,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":195,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":196,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":203,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":204,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":210,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":211,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":123},{"path":["/","home","trangar","development","rust","bincode","src","de","impls.rs"],"content":"use super::{BorrowDecodable, BorrowDecode, Decodable, Decode};\nuse crate::error::DecodeError;\n\nimpl\u003c'de\u003e Decodable for u8 {\n    fn decode\u003cD: Decode\u003e(mut decoder: D) -\u003e Result\u003cSelf, DecodeError\u003e {\n        decoder.decode_u8()\n    }\n}\n\nimpl\u003c'de\u003e Decodable for u16 {\n    fn decode\u003cD: Decode\u003e(mut decoder: D) -\u003e Result\u003cSelf, DecodeError\u003e {\n        decoder.decode_u16()\n    }\n}\n\nimpl\u003c'de\u003e Decodable for u32 {\n    fn decode\u003cD: Decode\u003e(mut decoder: D) -\u003e Result\u003cSelf, DecodeError\u003e {\n        decoder.decode_u32()\n    }\n}\n\nimpl\u003c'de\u003e Decodable for u64 {\n    fn decode\u003cD: Decode\u003e(mut decoder: D) -\u003e Result\u003cSelf, DecodeError\u003e {\n        decoder.decode_u64()\n    }\n}\n\nimpl\u003c'de\u003e Decodable for u128 {\n    fn decode\u003cD: Decode\u003e(mut decoder: D) -\u003e Result\u003cSelf, DecodeError\u003e {\n        decoder.decode_u128()\n    }\n}\n\nimpl\u003c'de\u003e Decodable for usize {\n    fn decode\u003cD: Decode\u003e(mut decoder: D) -\u003e Result\u003cSelf, DecodeError\u003e {\n        decoder.decode_usize()\n    }\n}\n\nimpl\u003c'de\u003e Decodable for i8 {\n    fn decode\u003cD: Decode\u003e(mut decoder: D) -\u003e Result\u003cSelf, DecodeError\u003e {\n        decoder.decode_i8()\n    }\n}\n\nimpl\u003c'de\u003e Decodable for i16 {\n    fn decode\u003cD: Decode\u003e(mut decoder: D) -\u003e Result\u003cSelf, DecodeError\u003e {\n        decoder.decode_i16()\n    }\n}\n\nimpl\u003c'de\u003e Decodable for i32 {\n    fn decode\u003cD: Decode\u003e(mut decoder: D) -\u003e Result\u003cSelf, DecodeError\u003e {\n        decoder.decode_i32()\n    }\n}\n\nimpl\u003c'de\u003e Decodable for i64 {\n    fn decode\u003cD: Decode\u003e(mut decoder: D) -\u003e Result\u003cSelf, DecodeError\u003e {\n        decoder.decode_i64()\n    }\n}\n\nimpl\u003c'de\u003e Decodable for i128 {\n    fn decode\u003cD: Decode\u003e(mut decoder: D) -\u003e Result\u003cSelf, DecodeError\u003e {\n        decoder.decode_i128()\n    }\n}\n\nimpl\u003c'de\u003e Decodable for isize {\n    fn decode\u003cD: Decode\u003e(mut decoder: D) -\u003e Result\u003cSelf, DecodeError\u003e {\n        decoder.decode_isize()\n    }\n}\n\nimpl\u003c'de\u003e Decodable for f32 {\n    fn decode\u003cD: Decode\u003e(mut decoder: D) -\u003e Result\u003cSelf, DecodeError\u003e {\n        decoder.decode_f32()\n    }\n}\n\nimpl\u003c'de\u003e Decodable for f64 {\n    fn decode\u003cD: Decode\u003e(mut decoder: D) -\u003e Result\u003cSelf, DecodeError\u003e {\n        decoder.decode_f64()\n    }\n}\n\nimpl\u003c'a, 'de: 'a\u003e BorrowDecodable\u003c'de\u003e for \u0026'a [u8] {\n    fn borrow_decode\u003cD: BorrowDecode\u003c'de\u003e\u003e(mut decoder: D) -\u003e Result\u003cSelf, DecodeError\u003e {\n        let len = usize::decode(\u0026mut decoder)?;\n        decoder.decode_slice(len)\n    }\n}\n\nimpl\u003c'a, 'de: 'a\u003e BorrowDecodable\u003c'de\u003e for \u0026'a str {\n    fn borrow_decode\u003cD: BorrowDecode\u003c'de\u003e\u003e(decoder: D) -\u003e Result\u003cSelf, DecodeError\u003e {\n        let slice: \u0026[u8] = BorrowDecodable::borrow_decode(decoder)?;\n        core::str::from_utf8(slice).map_err(DecodeError::Utf8)\n    }\n}\n\nimpl\u003c'de, const N: usize\u003e Decodable for [u8; N] {\n    fn decode\u003cD: Decode\u003e(mut decoder: D) -\u003e Result\u003cSelf, DecodeError\u003e {\n        decoder.decode_array()\n    }\n}\n\nimpl\u003c'de, T\u003e Decodable for core::marker::PhantomData\u003cT\u003e {\n    fn decode\u003cD: Decode\u003e(_: D) -\u003e Result\u003cSelf, DecodeError\u003e {\n        Ok(core::marker::PhantomData)\n    }\n}\n\nimpl\u003c'a, 'de, T\u003e Decode for \u0026'a mut T\nwhere\n    T: Decode,\n{\n    fn decode_u8(\u0026mut self) -\u003e Result\u003cu8, DecodeError\u003e {\n        T::decode_u8(self)\n    }\n\n    fn decode_u16(\u0026mut self) -\u003e Result\u003cu16, DecodeError\u003e {\n        T::decode_u16(self)\n    }\n\n    fn decode_u32(\u0026mut self) -\u003e Result\u003cu32, DecodeError\u003e {\n        T::decode_u32(self)\n    }\n\n    fn decode_u64(\u0026mut self) -\u003e Result\u003cu64, DecodeError\u003e {\n        T::decode_u64(self)\n    }\n\n    fn decode_u128(\u0026mut self) -\u003e Result\u003cu128, DecodeError\u003e {\n        T::decode_u128(self)\n    }\n\n    fn decode_usize(\u0026mut self) -\u003e Result\u003cusize, DecodeError\u003e {\n        T::decode_usize(self)\n    }\n\n    fn decode_i8(\u0026mut self) -\u003e Result\u003ci8, DecodeError\u003e {\n        T::decode_i8(self)\n    }\n\n    fn decode_i16(\u0026mut self) -\u003e Result\u003ci16, DecodeError\u003e {\n        T::decode_i16(self)\n    }\n\n    fn decode_i32(\u0026mut self) -\u003e Result\u003ci32, DecodeError\u003e {\n        T::decode_i32(self)\n    }\n\n    fn decode_i64(\u0026mut self) -\u003e Result\u003ci64, DecodeError\u003e {\n        T::decode_i64(self)\n    }\n\n    fn decode_i128(\u0026mut self) -\u003e Result\u003ci128, DecodeError\u003e {\n        T::decode_i128(self)\n    }\n\n    fn decode_isize(\u0026mut self) -\u003e Result\u003cisize, DecodeError\u003e {\n        T::decode_isize(self)\n    }\n\n    fn decode_f32(\u0026mut self) -\u003e Result\u003cf32, DecodeError\u003e {\n        T::decode_f32(self)\n    }\n\n    fn decode_f64(\u0026mut self) -\u003e Result\u003cf64, DecodeError\u003e {\n        T::decode_f64(self)\n    }\n\n    fn decode_array\u003cconst N: usize\u003e(\u0026mut self) -\u003e Result\u003c[u8; N], DecodeError\u003e {\n        T::decode_array::\u003cN\u003e(self)\n    }\n}\n\nimpl\u003c'a, 'de, T\u003e BorrowDecode\u003c'de\u003e for \u0026'a mut T\nwhere\n    T: BorrowDecode\u003c'de\u003e,\n{\n    fn decode_slice(\u0026mut self, len: usize) -\u003e Result\u003c\u0026'de [u8], DecodeError\u003e {\n        T::decode_slice(self, len)\n    }\n}\n","traces":[{"line":5,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":6,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":11,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":12,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":70},{"path":["/","home","trangar","development","rust","bincode","src","de","mod.rs"],"content":"use crate::error::DecodeError;\n\nmod decoder;\nmod impls;\n\npub mod read;\npub use self::decoder::Decoder;\n\npub trait Decodable: for\u003c'de\u003e BorrowDecodable\u003c'de\u003e {\n    fn decode\u003cD: Decode\u003e(decoder: D) -\u003e Result\u003cSelf, DecodeError\u003e;\n}\n\npub trait BorrowDecodable\u003c'de\u003e: Sized {\n    fn borrow_decode\u003cD: BorrowDecode\u003c'de\u003e\u003e(decoder: D) -\u003e Result\u003cSelf, DecodeError\u003e;\n}\n\nimpl\u003c'de, T: Decodable\u003e BorrowDecodable\u003c'de\u003e for T {\n    fn borrow_decode\u003cD: Decode\u003e(decoder: D) -\u003e Result\u003cSelf, DecodeError\u003e {\n        Decodable::decode(decoder)\n    }\n}\n\npub trait Decode {\n    fn decode_u8(\u0026mut self) -\u003e Result\u003cu8, DecodeError\u003e;\n    fn decode_u16(\u0026mut self) -\u003e Result\u003cu16, DecodeError\u003e;\n    fn decode_u32(\u0026mut self) -\u003e Result\u003cu32, DecodeError\u003e;\n    fn decode_u64(\u0026mut self) -\u003e Result\u003cu64, DecodeError\u003e;\n    fn decode_u128(\u0026mut self) -\u003e Result\u003cu128, DecodeError\u003e;\n    fn decode_usize(\u0026mut self) -\u003e Result\u003cusize, DecodeError\u003e;\n\n    fn decode_i8(\u0026mut self) -\u003e Result\u003ci8, DecodeError\u003e;\n    fn decode_i16(\u0026mut self) -\u003e Result\u003ci16, DecodeError\u003e;\n    fn decode_i32(\u0026mut self) -\u003e Result\u003ci32, DecodeError\u003e;\n    fn decode_i64(\u0026mut self) -\u003e Result\u003ci64, DecodeError\u003e;\n    fn decode_i128(\u0026mut self) -\u003e Result\u003ci128, DecodeError\u003e;\n    fn decode_isize(\u0026mut self) -\u003e Result\u003cisize, DecodeError\u003e;\n\n    fn decode_f32(\u0026mut self) -\u003e Result\u003cf32, DecodeError\u003e;\n    fn decode_f64(\u0026mut self) -\u003e Result\u003cf64, DecodeError\u003e;\n    fn decode_array\u003cconst N: usize\u003e(\u0026mut self) -\u003e Result\u003c[u8; N], DecodeError\u003e;\n}\n\npub trait BorrowDecode\u003c'de\u003e: Decode {\n    fn decode_slice(\u0026mut self, len: usize) -\u003e Result\u003c\u0026'de [u8], DecodeError\u003e;\n}\n","traces":[{"line":18,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":2},{"path":["/","home","trangar","development","rust","bincode","src","de","read.rs"],"content":"use crate::error::DecodeError;\n\npub trait Reader\u003c'storage\u003e {\n    fn read(\u0026mut self, bytes: \u0026mut [u8]) -\u003e Result\u003c(), DecodeError\u003e;\n}\n\npub trait BorrowReader\u003c'storage\u003e: Reader\u003c'storage\u003e {\n    fn take_bytes(\u0026mut self, length: usize) -\u003e Result\u003c\u0026'storage [u8], DecodeError\u003e;\n}\n\npub struct SliceReader\u003c'storage\u003e {\n    slice: \u0026'storage [u8],\n}\n\nimpl\u003c'storage\u003e SliceReader\u003c'storage\u003e {\n    /// Constructs a slice reader\n    pub(crate) fn new(bytes: \u0026'storage [u8]) -\u003e SliceReader\u003c'storage\u003e {\n        SliceReader { slice: bytes }\n    }\n\n    #[inline(always)]\n    fn get_byte_slice(\u0026mut self, length: usize) -\u003e Result\u003c\u0026'storage [u8], DecodeError\u003e {\n        if length \u003e self.slice.len() {\n            return Err(DecodeError::UnexpectedEnd);\n        }\n        let (read_slice, remaining) = self.slice.split_at(length);\n        self.slice = remaining;\n        Ok(read_slice)\n    }\n}\n\nimpl\u003c'storage\u003e Reader\u003c'storage\u003e for SliceReader\u003c'storage\u003e {\n    #[inline(always)]\n    fn read(\u0026mut self, bytes: \u0026mut [u8]) -\u003e Result\u003c(), DecodeError\u003e {\n        if bytes.len() \u003e self.slice.len() {\n            return Err(DecodeError::UnexpectedEnd);\n        }\n        let (read_slice, remaining) = self.slice.split_at(bytes.len());\n        bytes.copy_from_slice(read_slice);\n        self.slice = remaining;\n\n        Ok(())\n    }\n}\n\nimpl\u003c'storage\u003e BorrowReader\u003c'storage\u003e for SliceReader\u003c'storage\u003e {\n    #[inline(always)]\n    fn take_bytes(\u0026mut self, length: usize) -\u003e Result\u003c\u0026'storage [u8], DecodeError\u003e {\n        self.get_byte_slice(length)\n    }\n}\n","traces":[{"line":17,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":16},{"path":["/","home","trangar","development","rust","bincode","src","enc","encoder.rs"],"content":"use super::{write::Writer, Encode};\nuse crate::{\n    config::{Config, Endian, IntEncoding},\n    error::EncodeError,\n};\nuse core::marker::PhantomData;\n\npub struct Encoder\u003cW: Writer, C: Config\u003e {\n    writer: W,\n    config: PhantomData\u003cC\u003e,\n}\n\nimpl\u003cW: Writer, C: Config\u003e Encoder\u003cW, C\u003e {\n    pub fn new(writer: W) -\u003e Encoder\u003cW, C\u003e {\n        Encoder {\n            writer,\n            config: PhantomData,\n        }\n    }\n\n    pub fn into_writer(self) -\u003e W {\n        self.writer\n    }\n}\n\nimpl\u003c'a, W: Writer, C: Config\u003e Encode for \u0026'a mut Encoder\u003cW, C\u003e {\n    fn encode_u8(\u0026mut self, val: u8) -\u003e Result\u003c(), EncodeError\u003e {\n        self.writer.write(\u0026[val])\n    }\n\n    fn encode_u16(\u0026mut self, val: u16) -\u003e Result\u003c(), EncodeError\u003e {\n        match C::INT_ENCODING {\n            IntEncoding::Variable =\u003e {\n                crate::varint::varint_encode_u16(\u0026mut self.writer, C::ENDIAN, val)\n            }\n            IntEncoding::Fixed =\u003e match C::ENDIAN {\n                Endian::Big =\u003e self.writer.write(\u0026val.to_be_bytes()),\n                Endian::Little =\u003e self.writer.write(\u0026val.to_le_bytes()),\n            },\n        }\n    }\n\n    fn encode_u32(\u0026mut self, val: u32) -\u003e Result\u003c(), EncodeError\u003e {\n        match C::INT_ENCODING {\n            IntEncoding::Variable =\u003e {\n                crate::varint::varint_encode_u32(\u0026mut self.writer, C::ENDIAN, val)\n            }\n            IntEncoding::Fixed =\u003e match C::ENDIAN {\n                Endian::Big =\u003e self.writer.write(\u0026val.to_be_bytes()),\n                Endian::Little =\u003e self.writer.write(\u0026val.to_le_bytes()),\n            },\n        }\n    }\n\n    fn encode_u64(\u0026mut self, val: u64) -\u003e Result\u003c(), EncodeError\u003e {\n        match C::INT_ENCODING {\n            IntEncoding::Variable =\u003e {\n                crate::varint::varint_encode_u64(\u0026mut self.writer, C::ENDIAN, val)\n            }\n            IntEncoding::Fixed =\u003e match C::ENDIAN {\n                Endian::Big =\u003e self.writer.write(\u0026val.to_be_bytes()),\n                Endian::Little =\u003e self.writer.write(\u0026val.to_le_bytes()),\n            },\n        }\n    }\n\n    fn encode_u128(\u0026mut self, val: u128) -\u003e Result\u003c(), EncodeError\u003e {\n        match C::INT_ENCODING {\n            IntEncoding::Variable =\u003e {\n                crate::varint::varint_encode_u128(\u0026mut self.writer, C::ENDIAN, val)\n            }\n            IntEncoding::Fixed =\u003e match C::ENDIAN {\n                Endian::Big =\u003e self.writer.write(\u0026val.to_be_bytes()),\n                Endian::Little =\u003e self.writer.write(\u0026val.to_le_bytes()),\n            },\n        }\n    }\n\n    fn encode_usize(\u0026mut self, val: usize) -\u003e Result\u003c(), EncodeError\u003e {\n        match C::INT_ENCODING {\n            IntEncoding::Variable =\u003e {\n                crate::varint::varint_encode_usize(\u0026mut self.writer, C::ENDIAN, val)\n            }\n            IntEncoding::Fixed =\u003e match C::ENDIAN {\n                Endian::Big =\u003e self.writer.write(\u0026val.to_be_bytes()),\n                Endian::Little =\u003e self.writer.write(\u0026val.to_le_bytes()),\n            },\n        }\n    }\n\n    fn encode_i8(\u0026mut self, val: i8) -\u003e Result\u003c(), EncodeError\u003e {\n        self.writer.write(\u0026[val as u8])\n    }\n\n    fn encode_i16(\u0026mut self, val: i16) -\u003e Result\u003c(), EncodeError\u003e {\n        match C::INT_ENCODING {\n            IntEncoding::Variable =\u003e {\n                crate::varint::varint_encode_i16(\u0026mut self.writer, C::ENDIAN, val)\n            }\n            IntEncoding::Fixed =\u003e match C::ENDIAN {\n                Endian::Big =\u003e self.writer.write(\u0026val.to_be_bytes()),\n                Endian::Little =\u003e self.writer.write(\u0026val.to_le_bytes()),\n            },\n        }\n    }\n\n    fn encode_i32(\u0026mut self, val: i32) -\u003e Result\u003c(), EncodeError\u003e {\n        match C::INT_ENCODING {\n            IntEncoding::Variable =\u003e {\n                crate::varint::varint_encode_i32(\u0026mut self.writer, C::ENDIAN, val)\n            }\n            IntEncoding::Fixed =\u003e match C::ENDIAN {\n                Endian::Big =\u003e self.writer.write(\u0026val.to_be_bytes()),\n                Endian::Little =\u003e self.writer.write(\u0026val.to_le_bytes()),\n            },\n        }\n    }\n\n    fn encode_i64(\u0026mut self, val: i64) -\u003e Result\u003c(), EncodeError\u003e {\n        match C::INT_ENCODING {\n            IntEncoding::Variable =\u003e {\n                crate::varint::varint_encode_i64(\u0026mut self.writer, C::ENDIAN, val)\n            }\n            IntEncoding::Fixed =\u003e match C::ENDIAN {\n                Endian::Big =\u003e self.writer.write(\u0026val.to_be_bytes()),\n                Endian::Little =\u003e self.writer.write(\u0026val.to_le_bytes()),\n            },\n        }\n    }\n\n    fn encode_i128(\u0026mut self, val: i128) -\u003e Result\u003c(), EncodeError\u003e {\n        match C::INT_ENCODING {\n            IntEncoding::Variable =\u003e {\n                crate::varint::varint_encode_i128(\u0026mut self.writer, C::ENDIAN, val)\n            }\n            IntEncoding::Fixed =\u003e match C::ENDIAN {\n                Endian::Big =\u003e self.writer.write(\u0026val.to_be_bytes()),\n                Endian::Little =\u003e self.writer.write(\u0026val.to_le_bytes()),\n            },\n        }\n    }\n\n    fn encode_isize(\u0026mut self, val: isize) -\u003e Result\u003c(), EncodeError\u003e {\n        match C::INT_ENCODING {\n            IntEncoding::Variable =\u003e {\n                crate::varint::varint_encode_isize(\u0026mut self.writer, C::ENDIAN, val)\n            }\n            IntEncoding::Fixed =\u003e match C::ENDIAN {\n                Endian::Big =\u003e self.writer.write(\u0026val.to_be_bytes()),\n                Endian::Little =\u003e self.writer.write(\u0026val.to_le_bytes()),\n            },\n        }\n    }\n\n    fn encode_f32(\u0026mut self, val: f32) -\u003e Result\u003c(), EncodeError\u003e {\n        match C::ENDIAN {\n            Endian::Big =\u003e self.writer.write(\u0026val.to_be_bytes()),\n            Endian::Little =\u003e self.writer.write(\u0026val.to_le_bytes()),\n        }\n    }\n\n    fn encode_f64(\u0026mut self, val: f64) -\u003e Result\u003c(), EncodeError\u003e {\n        match C::ENDIAN {\n            Endian::Big =\u003e self.writer.write(\u0026val.to_be_bytes()),\n            Endian::Little =\u003e self.writer.write(\u0026val.to_le_bytes()),\n        }\n    }\n\n    fn encode_slice(\u0026mut self, val: \u0026[u8]) -\u003e Result\u003c(), EncodeError\u003e {\n        self.encode_usize(val.len())?;\n        self.writer.write(val)\n    }\n\n    fn encode_array\u003cconst N: usize\u003e(\u0026mut self, val: [u8; N]) -\u003e Result\u003c(), EncodeError\u003e {\n        self.writer.write(\u0026val)\n    }\n}\n","traces":[{"line":14,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":90},{"path":["/","home","trangar","development","rust","bincode","src","enc","impls.rs"],"content":"use super::{Encode, Encodeable};\nuse crate::error::EncodeError;\n\nimpl Encodeable for u8 {\n    fn encode\u003cE: Encode\u003e(\u0026self, mut encoder: E) -\u003e Result\u003c(), EncodeError\u003e {\n        encoder.encode_u8(*self)\n    }\n}\n\nimpl Encodeable for u16 {\n    fn encode\u003cE: Encode\u003e(\u0026self, mut encoder: E) -\u003e Result\u003c(), EncodeError\u003e {\n        encoder.encode_u16(*self)\n    }\n}\n\nimpl Encodeable for u32 {\n    fn encode\u003cE: Encode\u003e(\u0026self, mut encoder: E) -\u003e Result\u003c(), EncodeError\u003e {\n        encoder.encode_u32(*self)\n    }\n}\n\nimpl Encodeable for u64 {\n    fn encode\u003cE: Encode\u003e(\u0026self, mut encoder: E) -\u003e Result\u003c(), EncodeError\u003e {\n        encoder.encode_u64(*self)\n    }\n}\n\nimpl Encodeable for u128 {\n    fn encode\u003cE: Encode\u003e(\u0026self, mut encoder: E) -\u003e Result\u003c(), EncodeError\u003e {\n        encoder.encode_u128(*self)\n    }\n}\n\nimpl Encodeable for usize {\n    fn encode\u003cE: Encode\u003e(\u0026self, mut encoder: E) -\u003e Result\u003c(), EncodeError\u003e {\n        encoder.encode_usize(*self)\n    }\n}\n\nimpl Encodeable for i8 {\n    fn encode\u003cE: Encode\u003e(\u0026self, mut encoder: E) -\u003e Result\u003c(), EncodeError\u003e {\n        encoder.encode_i8(*self)\n    }\n}\n\nimpl Encodeable for i16 {\n    fn encode\u003cE: Encode\u003e(\u0026self, mut encoder: E) -\u003e Result\u003c(), EncodeError\u003e {\n        encoder.encode_i16(*self)\n    }\n}\n\nimpl Encodeable for i32 {\n    fn encode\u003cE: Encode\u003e(\u0026self, mut encoder: E) -\u003e Result\u003c(), EncodeError\u003e {\n        encoder.encode_i32(*self)\n    }\n}\n\nimpl Encodeable for i64 {\n    fn encode\u003cE: Encode\u003e(\u0026self, mut encoder: E) -\u003e Result\u003c(), EncodeError\u003e {\n        encoder.encode_i64(*self)\n    }\n}\n\nimpl Encodeable for i128 {\n    fn encode\u003cE: Encode\u003e(\u0026self, mut encoder: E) -\u003e Result\u003c(), EncodeError\u003e {\n        encoder.encode_i128(*self)\n    }\n}\n\nimpl Encodeable for isize {\n    fn encode\u003cE: Encode\u003e(\u0026self, mut encoder: E) -\u003e Result\u003c(), EncodeError\u003e {\n        encoder.encode_isize(*self)\n    }\n}\n\nimpl Encodeable for f32 {\n    fn encode\u003cE: Encode\u003e(\u0026self, mut encoder: E) -\u003e Result\u003c(), EncodeError\u003e {\n        encoder.encode_f32(*self)\n    }\n}\n\nimpl Encodeable for f64 {\n    fn encode\u003cE: Encode\u003e(\u0026self, mut encoder: E) -\u003e Result\u003c(), EncodeError\u003e {\n        encoder.encode_f64(*self)\n    }\n}\n\nimpl Encodeable for \u0026'_ [u8] {\n    fn encode\u003cE: Encode\u003e(\u0026self, mut encoder: E) -\u003e Result\u003c(), EncodeError\u003e {\n        encoder.encode_slice(*self)\n    }\n}\n\nimpl Encodeable for \u0026'_ str {\n    fn encode\u003cE: Encode\u003e(\u0026self, mut encoder: E) -\u003e Result\u003c(), EncodeError\u003e {\n        encoder.encode_slice(self.as_bytes())\n    }\n}\n\nimpl\u003cconst N: usize\u003e Encodeable for [u8; N] {\n    fn encode\u003cE: Encode\u003e(\u0026self, mut encoder: E) -\u003e Result\u003c(), EncodeError\u003e {\n        encoder.encode_array(*self)\n    }\n}\n\nimpl\u003c'a, T\u003e Encode for \u0026'a mut T\nwhere\n    T: Encode,\n{\n    fn encode_u8(\u0026mut self, val: u8) -\u003e Result\u003c(), EncodeError\u003e {\n        T::encode_u8(self, val)\n    }\n    fn encode_u16(\u0026mut self, val: u16) -\u003e Result\u003c(), EncodeError\u003e {\n        T::encode_u16(self, val)\n    }\n    fn encode_u32(\u0026mut self, val: u32) -\u003e Result\u003c(), EncodeError\u003e {\n        T::encode_u32(self, val)\n    }\n    fn encode_u64(\u0026mut self, val: u64) -\u003e Result\u003c(), EncodeError\u003e {\n        T::encode_u64(self, val)\n    }\n    fn encode_u128(\u0026mut self, val: u128) -\u003e Result\u003c(), EncodeError\u003e {\n        T::encode_u128(self, val)\n    }\n    fn encode_usize(\u0026mut self, val: usize) -\u003e Result\u003c(), EncodeError\u003e {\n        T::encode_usize(self, val)\n    }\n\n    fn encode_i8(\u0026mut self, val: i8) -\u003e Result\u003c(), EncodeError\u003e {\n        T::encode_i8(self, val)\n    }\n    fn encode_i16(\u0026mut self, val: i16) -\u003e Result\u003c(), EncodeError\u003e {\n        T::encode_i16(self, val)\n    }\n    fn encode_i32(\u0026mut self, val: i32) -\u003e Result\u003c(), EncodeError\u003e {\n        T::encode_i32(self, val)\n    }\n    fn encode_i64(\u0026mut self, val: i64) -\u003e Result\u003c(), EncodeError\u003e {\n        T::encode_i64(self, val)\n    }\n    fn encode_i128(\u0026mut self, val: i128) -\u003e Result\u003c(), EncodeError\u003e {\n        T::encode_i128(self, val)\n    }\n    fn encode_isize(\u0026mut self, val: isize) -\u003e Result\u003c(), EncodeError\u003e {\n        T::encode_isize(self, val)\n    }\n\n    fn encode_f32(\u0026mut self, val: f32) -\u003e Result\u003c(), EncodeError\u003e {\n        T::encode_f32(self, val)\n    }\n    fn encode_f64(\u0026mut self, val: f64) -\u003e Result\u003c(), EncodeError\u003e {\n        T::encode_f64(self, val)\n    }\n    fn encode_slice(\u0026mut self, val: \u0026[u8]) -\u003e Result\u003c(), EncodeError\u003e {\n        T::encode_slice(self, val)\n    }\n    fn encode_array\u003cconst N: usize\u003e(\u0026mut self, val: [u8; N]) -\u003e Result\u003c(), EncodeError\u003e {\n        T::encode_array(self, val)\n    }\n}\n","traces":[{"line":5,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":6,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":11,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":12,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":66},{"path":["/","home","trangar","development","rust","bincode","src","enc","mod.rs"],"content":"mod encoder;\nmod impls;\n\nuse crate::error::EncodeError;\n\npub mod write;\n\npub use self::encoder::Encoder;\n\npub trait Encodeable {\n    fn encode\u003cE: Encode\u003e(\u0026self, encoder: E) -\u003e Result\u003c(), EncodeError\u003e;\n}\n\npub trait Encode {\n    fn encode_u8(\u0026mut self, val: u8) -\u003e Result\u003c(), EncodeError\u003e;\n    fn encode_u16(\u0026mut self, val: u16) -\u003e Result\u003c(), EncodeError\u003e;\n    fn encode_u32(\u0026mut self, val: u32) -\u003e Result\u003c(), EncodeError\u003e;\n    fn encode_u64(\u0026mut self, val: u64) -\u003e Result\u003c(), EncodeError\u003e;\n    fn encode_u128(\u0026mut self, val: u128) -\u003e Result\u003c(), EncodeError\u003e;\n    fn encode_usize(\u0026mut self, val: usize) -\u003e Result\u003c(), EncodeError\u003e;\n\n    fn encode_i8(\u0026mut self, val: i8) -\u003e Result\u003c(), EncodeError\u003e;\n    fn encode_i16(\u0026mut self, val: i16) -\u003e Result\u003c(), EncodeError\u003e;\n    fn encode_i32(\u0026mut self, val: i32) -\u003e Result\u003c(), EncodeError\u003e;\n    fn encode_i64(\u0026mut self, val: i64) -\u003e Result\u003c(), EncodeError\u003e;\n    fn encode_i128(\u0026mut self, val: i128) -\u003e Result\u003c(), EncodeError\u003e;\n    fn encode_isize(\u0026mut self, val: isize) -\u003e Result\u003c(), EncodeError\u003e;\n\n    fn encode_f32(\u0026mut self, val: f32) -\u003e Result\u003c(), EncodeError\u003e;\n    fn encode_f64(\u0026mut self, val: f64) -\u003e Result\u003c(), EncodeError\u003e;\n    fn encode_slice(\u0026mut self, val: \u0026[u8]) -\u003e Result\u003c(), EncodeError\u003e;\n    fn encode_array\u003cconst N: usize\u003e(\u0026mut self, val: [u8; N]) -\u003e Result\u003c(), EncodeError\u003e;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","trangar","development","rust","bincode","src","enc","write.rs"],"content":"use crate::error::EncodeError;\n\npub trait Writer {\n    fn write(\u0026mut self, bytes: \u0026[u8]) -\u003e Result\u003c(), EncodeError\u003e;\n}\n\npub struct SliceWriter\u003c'storage\u003e {\n    slice: \u0026'storage mut [u8],\n    idx: usize,\n}\n\nimpl\u003c'storage\u003e SliceWriter\u003c'storage\u003e {\n    pub(crate) fn new(bytes: \u0026'storage mut [u8]) -\u003e SliceWriter\u003c'storage\u003e {\n        SliceWriter {\n            slice: bytes,\n            idx: 0,\n        }\n    }\n\n    pub(crate) fn bytes_written(\u0026self) -\u003e usize {\n        self.idx\n    }\n}\n\nimpl\u003c'storage\u003e Writer for SliceWriter\u003c'storage\u003e {\n    fn write(\u0026mut self, bytes: \u0026[u8]) -\u003e Result\u003c(), EncodeError\u003e {\n        let remaining = \u0026mut self.slice[self.idx..];\n        if bytes.len() \u003e remaining.len() {\n            return Err(EncodeError::UnexpectedEnd);\n        }\n        self.idx += bytes.len();\n        let write_slice = \u0026mut remaining[..bytes.len()];\n        write_slice.copy_from_slice(bytes);\n        Ok(())\n    }\n}\n","traces":[{"line":13,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":11},{"path":["/","home","trangar","development","rust","bincode","src","error.rs"],"content":"#[non_exhaustive]\n#[derive(Debug)]\npub enum EncodeError {\n    InvalidIntEncoding,\n    UnexpectedEnd,\n}\n\n#[non_exhaustive]\n#[derive(Debug)]\npub enum DecodeError {\n    UnexpectedEnd,\n    /// Invalid type was found. The decoder tried to read type `expected`, but found type `found` instead.\n    InvalidIntegerType {\n        /// The type that was being read from the reader\n        expected: IntegerType,\n        /// The type that was encoded in the data\n        found: IntegerType,\n    },\n    UnexpectedVariant {\n        min: u32,\n        max: u32,\n        found: u32,\n    },\n\n    Utf8(core::str::Utf8Error),\n}\n\n#[non_exhaustive]\n#[derive(Debug)]\npub enum IntegerType {\n    U16,\n    U32,\n    U64,\n    U128,\n    USize,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","trangar","development","rust","bincode","src","features","derive.rs"],"content":"pub use bincode_derive::Encodable; // Decodable,\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","trangar","development","rust","bincode","src","features","impl_alloc.rs"],"content":"\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","trangar","development","rust","bincode","src","features","impl_std.rs"],"content":"use crate::{\n    config::{self, Config},\n    de::{read::Reader, Decodable, Decoder},\n    error::DecodeError,\n};\n\npub fn decode_from\u003cD: Decodable, R: std::io::Read\u003e(src: \u0026mut R) -\u003e Result\u003cD, DecodeError\u003e {\n    decode_from_with_config(src, config::Default)\n}\n\npub fn decode_from_with_config\u003cD: Decodable, C: Config, R: std::io::Read\u003e(\n    src: \u0026mut R,\n    _config: C,\n) -\u003e Result\u003cD, DecodeError\u003e {\n    let mut decoder = Decoder::\u003c_, C\u003e::new(src, _config);\n    D::decode(\u0026mut decoder)\n}\n\nimpl\u003c'storage, R: std::io::Read\u003e Reader\u003c'storage\u003e for R {\n    #[inline(always)]\n    fn read(\u0026mut self, bytes: \u0026mut [u8]) -\u003e Result\u003c(), DecodeError\u003e {\n        match self.read_exact(bytes) {\n            Ok(_) =\u003e Ok(()),\n            Err(_) =\u003e Err(DecodeError::UnexpectedEnd),\n        }\n    }\n}\n","traces":[{"line":21,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":4},{"path":["/","home","trangar","development","rust","bincode","src","features","mod.rs"],"content":"#[cfg(feature = \"alloc\")]\nmod impl_alloc;\n#[cfg(feature = \"alloc\")]\npub use self::impl_alloc::*;\n\n#[cfg(feature = \"std\")]\nmod impl_std;\n#[cfg(feature = \"std\")]\npub use self::impl_std::*;\n\n#[cfg(feature = \"derive\")]\nmod derive;\n#[cfg(feature = \"derive\")]\npub use self::derive::*;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","trangar","development","rust","bincode","src","lib.rs"],"content":"#![no_std]\n\n//! Bincode is a crate for encoding and decoding using a tiny binary\n//! serialization strategy.  Using it, you can easily go from having\n//! an object in memory, quickly serialize it to bytes, and then\n//! deserialize it back just as fast!\n\n#![doc(html_root_url = \"https://docs.rs/bincode/2.0.0-dev\")]\n#![crate_name = \"bincode\"]\n#![crate_type = \"rlib\"]\n#![crate_type = \"dylib\"]\n\n#[cfg(feature = \"alloc\")]\nextern crate alloc;\n#[cfg(any(feature = \"std\", test))]\nextern crate std;\n\nmod features;\npub(crate) mod varint;\n\npub use features::*;\n\npub mod config;\npub mod de;\npub mod enc;\npub mod error;\n\nuse config::Config;\n\npub fn encode_into_slice\u003cE: enc::Encodeable\u003e(\n    val: E,\n    dst: \u0026mut [u8],\n) -\u003e Result\u003cusize, error::EncodeError\u003e {\n    encode_into_slice_with_config(val, dst, config::Default)\n}\n\npub fn encode_into_slice_with_config\u003cE: enc::Encodeable, C: Config\u003e(\n    val: E,\n    dst: \u0026mut [u8],\n    _config: C,\n) -\u003e Result\u003cusize, error::EncodeError\u003e {\n    let writer = enc::write::SliceWriter::new(dst);\n    let mut encoder = enc::Encoder::\u003c_, C\u003e::new(writer);\n    val.encode(\u0026mut encoder)?;\n    Ok(encoder.into_writer().bytes_written())\n}\n\npub fn decode\u003c'__de, D: de::BorrowDecodable\u003c'__de\u003e\u003e(\n    src: \u0026'__de mut [u8],\n) -\u003e Result\u003cD, error::DecodeError\u003e {\n    decode_with_config(src, config::Default)\n}\n\npub fn decode_with_config\u003c'__de, D: de::BorrowDecodable\u003c'__de\u003e, C: Config\u003e(\n    src: \u0026'__de mut [u8],\n    _config: C,\n) -\u003e Result\u003cD, error::DecodeError\u003e {\n    let reader = de::read::SliceReader::new(src);\n    let mut decoder = de::Decoder::\u003c_, C\u003e::new(reader, _config);\n    D::borrow_decode(\u0026mut decoder)\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","trangar","development","rust","bincode","src","varint","decode_signed.rs"],"content":"use crate::{config::Endian, de::read::Reader, error::DecodeError};\n\npub fn varint_decode_i16\u003c'a, R: Reader\u003c'a\u003e\u003e(\n    read: \u0026mut R,\n    endian: Endian,\n) -\u003e Result\u003ci16, DecodeError\u003e {\n    let n = super::varint_decode_u16(read, endian)?;\n    Ok(if n % 2 == 0 {\n        // positive number\n        (n / 2) as _\n    } else {\n        // negative number\n        // !m * 2 + 1 = n\n        // !m * 2 = n - 1\n        // !m = (n - 1) / 2\n        // m = !((n - 1) / 2)\n        // since we have n is odd, we have floor(n / 2) = floor((n - 1) / 2)\n        !(n / 2) as _\n    })\n}\n\npub fn varint_decode_i32\u003c'a, R: Reader\u003c'a\u003e\u003e(\n    read: \u0026mut R,\n    endian: Endian,\n) -\u003e Result\u003ci32, DecodeError\u003e {\n    let n = super::varint_decode_u32(read, endian)?;\n    Ok(if n % 2 == 0 {\n        // positive number\n        (n / 2) as _\n    } else {\n        // negative number\n        // !m * 2 + 1 = n\n        // !m * 2 = n - 1\n        // !m = (n - 1) / 2\n        // m = !((n - 1) / 2)\n        // since we have n is odd, we have floor(n / 2) = floor((n - 1) / 2)\n        !(n / 2) as _\n    })\n}\n\npub fn varint_decode_i64\u003c'a, R: Reader\u003c'a\u003e\u003e(\n    read: \u0026mut R,\n    endian: Endian,\n) -\u003e Result\u003ci64, DecodeError\u003e {\n    let n = super::varint_decode_u64(read, endian)?;\n    Ok(if n % 2 == 0 {\n        // positive number\n        (n / 2) as _\n    } else {\n        // negative number\n        // !m * 2 + 1 = n\n        // !m * 2 = n - 1\n        // !m = (n - 1) / 2\n        // m = !((n - 1) / 2)\n        // since we have n is odd, we have floor(n / 2) = floor((n - 1) / 2)\n        !(n / 2) as _\n    })\n}\n\npub fn varint_decode_i128\u003c'a, R: Reader\u003c'a\u003e\u003e(\n    read: \u0026mut R,\n    endian: Endian,\n) -\u003e Result\u003ci128, DecodeError\u003e {\n    let n = super::varint_decode_u128(read, endian)?;\n    Ok(if n % 2 == 0 {\n        // positive number\n        (n / 2) as _\n    } else {\n        // negative number\n        // !m * 2 + 1 = n\n        // !m * 2 = n - 1\n        // !m = (n - 1) / 2\n        // m = !((n - 1) / 2)\n        // since we have n is odd, we have floor(n / 2) = floor((n - 1) / 2)\n        !(n / 2) as _\n    })\n}\n\npub fn varint_decode_isize\u003c'a, R: Reader\u003c'a\u003e\u003e(\n    read: \u0026mut R,\n    endian: Endian,\n) -\u003e Result\u003cisize, DecodeError\u003e {\n    varint_decode_i64(read, endian).map(|v| v as isize)\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","trangar","development","rust","bincode","src","varint","decode_unsigned.rs"],"content":"use super::{U128_BYTE, U16_BYTE, U32_BYTE, U64_BYTE};\nuse crate::{\n    config::Endian,\n    de::read::Reader,\n    error::{DecodeError, IntegerType},\n};\n\npub fn varint_decode_u16\u003c'a, R: Reader\u003c'a\u003e\u003e(\n    read: \u0026mut R,\n    endian: Endian,\n) -\u003e Result\u003cu16, DecodeError\u003e {\n    let mut byte = [0u8; 1];\n    read.read(\u0026mut byte)?;\n    match byte[0] {\n        U16_BYTE =\u003e {\n            let mut bytes = [0u8; 2];\n            read.read(\u0026mut bytes)?;\n            Ok(match endian {\n                Endian::Big =\u003e u16::from_be_bytes(bytes),\n                Endian::Little =\u003e u16::from_le_bytes(bytes),\n            })\n        }\n        U32_BYTE =\u003e Err(DecodeError::InvalidIntegerType {\n            expected: IntegerType::U16,\n            found: IntegerType::U32,\n        }),\n        U64_BYTE =\u003e Err(DecodeError::InvalidIntegerType {\n            expected: IntegerType::U16,\n            found: IntegerType::U64,\n        }),\n        U128_BYTE =\u003e Err(DecodeError::InvalidIntegerType {\n            expected: IntegerType::U16,\n            found: IntegerType::U128,\n        }),\n        x =\u003e Ok(x as u16),\n    }\n}\n\npub fn varint_decode_u32\u003c'a, R: Reader\u003c'a\u003e\u003e(\n    read: \u0026mut R,\n    endian: Endian,\n) -\u003e Result\u003cu32, DecodeError\u003e {\n    let mut byte = [0u8; 1];\n    read.read(\u0026mut byte)?;\n    match byte[0] {\n        U16_BYTE =\u003e {\n            let mut bytes = [0u8; 2];\n            read.read(\u0026mut bytes)?;\n            Ok(match endian {\n                Endian::Big =\u003e u16::from_be_bytes(bytes) as u32,\n                Endian::Little =\u003e u16::from_le_bytes(bytes) as u32,\n            })\n        }\n        U32_BYTE =\u003e {\n            let mut bytes = [0u8; 4];\n            read.read(\u0026mut bytes)?;\n            Ok(match endian {\n                Endian::Big =\u003e u32::from_be_bytes(bytes),\n                Endian::Little =\u003e u32::from_le_bytes(bytes),\n            })\n        }\n        U64_BYTE =\u003e Err(DecodeError::InvalidIntegerType {\n            expected: IntegerType::U32,\n            found: IntegerType::U64,\n        }),\n        U128_BYTE =\u003e Err(DecodeError::InvalidIntegerType {\n            expected: IntegerType::U32,\n            found: IntegerType::U128,\n        }),\n        x =\u003e Ok(x as u32),\n    }\n}\n\npub fn varint_decode_u64\u003c'a, R: Reader\u003c'a\u003e\u003e(\n    read: \u0026mut R,\n    endian: Endian,\n) -\u003e Result\u003cu64, DecodeError\u003e {\n    let mut byte = [0u8; 1];\n    read.read(\u0026mut byte)?;\n    match byte[0] {\n        U16_BYTE =\u003e {\n            let mut bytes = [0u8; 2];\n            read.read(\u0026mut bytes)?;\n            Ok(match endian {\n                Endian::Big =\u003e u16::from_be_bytes(bytes) as u64,\n                Endian::Little =\u003e u16::from_le_bytes(bytes) as u64,\n            })\n        }\n        U32_BYTE =\u003e {\n            let mut bytes = [0u8; 4];\n            read.read(\u0026mut bytes)?;\n            Ok(match endian {\n                Endian::Big =\u003e u32::from_be_bytes(bytes) as u64,\n                Endian::Little =\u003e u32::from_le_bytes(bytes) as u64,\n            })\n        }\n        U64_BYTE =\u003e {\n            let mut bytes = [0u8; 8];\n            read.read(\u0026mut bytes)?;\n            Ok(match endian {\n                Endian::Big =\u003e u64::from_be_bytes(bytes),\n                Endian::Little =\u003e u64::from_le_bytes(bytes),\n            })\n        }\n        U128_BYTE =\u003e Err(DecodeError::InvalidIntegerType {\n            expected: IntegerType::U64,\n            found: IntegerType::U128,\n        }),\n        x =\u003e Ok(x as u64),\n    }\n}\n\npub fn varint_decode_usize\u003c'a, R: Reader\u003c'a\u003e\u003e(\n    read: \u0026mut R,\n    endian: Endian,\n) -\u003e Result\u003cusize, DecodeError\u003e {\n    let mut byte = [0u8; 1];\n    read.read(\u0026mut byte)?;\n    match byte[0] {\n        U16_BYTE =\u003e {\n            let mut bytes = [0u8; 2];\n            read.read(\u0026mut bytes)?;\n            Ok(match endian {\n                Endian::Big =\u003e u16::from_be_bytes(bytes) as usize,\n                Endian::Little =\u003e u16::from_le_bytes(bytes) as usize,\n            })\n        }\n        U32_BYTE =\u003e {\n            let mut bytes = [0u8; 4];\n            read.read(\u0026mut bytes)?;\n            Ok(match endian {\n                Endian::Big =\u003e u32::from_be_bytes(bytes) as usize,\n                Endian::Little =\u003e u32::from_le_bytes(bytes) as usize,\n            })\n        }\n        U64_BYTE =\u003e {\n            let mut bytes = [0u8; 8];\n            read.read(\u0026mut bytes)?;\n            Ok(match endian {\n                Endian::Big =\u003e u64::from_be_bytes(bytes) as usize,\n                Endian::Little =\u003e u64::from_le_bytes(bytes) as usize,\n            })\n        }\n        U128_BYTE =\u003e Err(DecodeError::InvalidIntegerType {\n            expected: IntegerType::USize,\n            found: IntegerType::U128,\n        }),\n        x =\u003e Ok(x as usize),\n    }\n}\n\npub fn varint_decode_u128\u003c'a, R: Reader\u003c'a\u003e\u003e(\n    read: \u0026mut R,\n    endian: Endian,\n) -\u003e Result\u003cu128, DecodeError\u003e {\n    let mut byte = [0u8; 1];\n    read.read(\u0026mut byte)?;\n    match byte[0] {\n        U16_BYTE =\u003e {\n            let mut bytes = [0u8; 2];\n            read.read(\u0026mut bytes)?;\n            Ok(match endian {\n                Endian::Big =\u003e u16::from_be_bytes(bytes) as u128,\n                Endian::Little =\u003e u16::from_le_bytes(bytes) as u128,\n            })\n        }\n        U32_BYTE =\u003e {\n            let mut bytes = [0u8; 4];\n            read.read(\u0026mut bytes)?;\n            Ok(match endian {\n                Endian::Big =\u003e u32::from_be_bytes(bytes) as u128,\n                Endian::Little =\u003e u32::from_le_bytes(bytes) as u128,\n            })\n        }\n        U64_BYTE =\u003e {\n            let mut bytes = [0u8; 8];\n            read.read(\u0026mut bytes)?;\n            Ok(match endian {\n                Endian::Big =\u003e u64::from_be_bytes(bytes) as u128,\n                Endian::Little =\u003e u64::from_le_bytes(bytes) as u128,\n            })\n        }\n        U128_BYTE =\u003e {\n            let mut bytes = [0u8; 16];\n            read.read(\u0026mut bytes)?;\n            Ok(match endian {\n                Endian::Big =\u003e u128::from_be_bytes(bytes),\n                Endian::Little =\u003e u128::from_le_bytes(bytes),\n            })\n        }\n        x =\u003e Ok(x as u128),\n    }\n}\n\n#[test]\nfn test_decode_u16() {\n    let cases: \u0026[(\u0026[u8], u16, u16)] = \u0026[\n        (\u0026[0], 0, 0),\n        (\u0026[10], 10, 10),\n        (\u0026[U16_BYTE, 0, 10], 2560, 10),\n    ];\n    for \u0026(slice, expected_le, expected_be) in cases {\n        let mut reader = crate::de::read::SliceReader::new(slice);\n        let found = varint_decode_u16(\u0026mut reader, Endian::Little).unwrap();\n        assert_eq!(expected_le, found);\n\n        let mut reader = crate::de::read::SliceReader::new(slice);\n        let found = varint_decode_u16(\u0026mut reader, Endian::Big).unwrap();\n        assert_eq!(expected_be, found);\n    }\n\n    let errors: \u0026[(\u0026[u8], DecodeError)] = \u0026[\n        (\n            \u0026[U32_BYTE],\n            DecodeError::InvalidIntegerType {\n                expected: IntegerType::U16,\n                found: IntegerType::U32,\n            },\n        ),\n        (\n            \u0026[U64_BYTE],\n            DecodeError::InvalidIntegerType {\n                expected: IntegerType::U16,\n                found: IntegerType::U64,\n            },\n        ),\n        (\n            \u0026[U128_BYTE],\n            DecodeError::InvalidIntegerType {\n                expected: IntegerType::U16,\n                found: IntegerType::U128,\n            },\n        ),\n        (\u0026[U16_BYTE], DecodeError::UnexpectedEnd),\n        (\u0026[U16_BYTE, 0], DecodeError::UnexpectedEnd),\n    ];\n\n    for (slice, expected) in errors {\n        let mut reader = crate::de::read::SliceReader::new(slice);\n        let found = varint_decode_u16(\u0026mut reader, Endian::Little).unwrap_err();\n        assert_eq!(std::format!(\"{:?}\", expected), std::format!(\"{:?}\", found));\n    }\n}\n\n#[test]\nfn test_decode_u32() {\n    let cases: \u0026[(\u0026[u8], u32, u32)] = \u0026[\n        (\u0026[0], 0, 0),\n        (\u0026[10], 10, 10),\n        (\u0026[U16_BYTE, 0, 10], 2560, 10),\n        (\u0026[U32_BYTE, 0, 0, 0, 10], 167_772_160, 10),\n    ];\n    for \u0026(slice, expected_le, expected_be) in cases {\n        let mut reader = crate::de::read::SliceReader::new(slice);\n        let found = varint_decode_u32(\u0026mut reader, Endian::Little).unwrap();\n        assert_eq!(expected_le, found);\n\n        let mut reader = crate::de::read::SliceReader::new(slice);\n        let found = varint_decode_u32(\u0026mut reader, Endian::Big).unwrap();\n        assert_eq!(expected_be, found);\n    }\n\n    let errors: \u0026[(\u0026[u8], DecodeError)] = \u0026[\n        (\n            \u0026[U64_BYTE],\n            DecodeError::InvalidIntegerType {\n                expected: IntegerType::U32,\n                found: IntegerType::U64,\n            },\n        ),\n        (\n            \u0026[U128_BYTE],\n            DecodeError::InvalidIntegerType {\n                expected: IntegerType::U32,\n                found: IntegerType::U128,\n            },\n        ),\n        (\u0026[U16_BYTE], DecodeError::UnexpectedEnd),\n        (\u0026[U16_BYTE, 0], DecodeError::UnexpectedEnd),\n        (\u0026[U32_BYTE], DecodeError::UnexpectedEnd),\n        (\u0026[U32_BYTE, 0], DecodeError::UnexpectedEnd),\n        (\u0026[U32_BYTE, 0, 0], DecodeError::UnexpectedEnd),\n        (\u0026[U32_BYTE, 0, 0, 0], DecodeError::UnexpectedEnd),\n    ];\n\n    for (slice, expected) in errors {\n        let mut reader = crate::de::read::SliceReader::new(slice);\n        let found = varint_decode_u32(\u0026mut reader, Endian::Little).unwrap_err();\n        assert_eq!(std::format!(\"{:?}\", expected), std::format!(\"{:?}\", found));\n    }\n}\n\n#[test]\nfn test_decode_u64() {\n    let cases: \u0026[(\u0026[u8], u64, u64)] = \u0026[\n        (\u0026[0], 0, 0),\n        (\u0026[10], 10, 10),\n        (\u0026[U16_BYTE, 0, 10], 2560, 10),\n        (\u0026[U32_BYTE, 0, 0, 0, 10], 167_772_160, 10),\n        (\n            \u0026[U64_BYTE, 0, 0, 0, 0, 0, 0, 0, 10],\n            72_057_594_037_9279_360,\n            10,\n        ),\n    ];\n    for \u0026(slice, expected_le, expected_be) in cases {\n        let mut reader = crate::de::read::SliceReader::new(slice);\n        let found = varint_decode_u64(\u0026mut reader, Endian::Little).unwrap();\n        assert_eq!(expected_le, found);\n\n        let mut reader = crate::de::read::SliceReader::new(slice);\n        let found = varint_decode_u64(\u0026mut reader, Endian::Big).unwrap();\n        assert_eq!(expected_be, found);\n    }\n\n    let errors: \u0026[(\u0026[u8], DecodeError)] = \u0026[\n        (\n            \u0026[U128_BYTE],\n            DecodeError::InvalidIntegerType {\n                expected: IntegerType::U64,\n                found: IntegerType::U128,\n            },\n        ),\n        (\u0026[U16_BYTE], DecodeError::UnexpectedEnd),\n        (\u0026[U16_BYTE, 0], DecodeError::UnexpectedEnd),\n        (\u0026[U32_BYTE], DecodeError::UnexpectedEnd),\n        (\u0026[U32_BYTE, 0], DecodeError::UnexpectedEnd),\n        (\u0026[U32_BYTE, 0, 0], DecodeError::UnexpectedEnd),\n        (\u0026[U32_BYTE, 0, 0, 0], DecodeError::UnexpectedEnd),\n        (\u0026[U64_BYTE], DecodeError::UnexpectedEnd),\n        (\u0026[U64_BYTE, 0], DecodeError::UnexpectedEnd),\n        (\u0026[U64_BYTE, 0, 0], DecodeError::UnexpectedEnd),\n        (\u0026[U64_BYTE, 0, 0, 0], DecodeError::UnexpectedEnd),\n        (\u0026[U64_BYTE, 0, 0, 0, 0], DecodeError::UnexpectedEnd),\n        (\u0026[U64_BYTE, 0, 0, 0, 0, 0], DecodeError::UnexpectedEnd),\n        (\u0026[U64_BYTE, 0, 0, 0, 0, 0, 0], DecodeError::UnexpectedEnd),\n        (\u0026[U64_BYTE, 0, 0, 0, 0, 0, 0, 0], DecodeError::UnexpectedEnd),\n    ];\n\n    for (slice, expected) in errors {\n        let mut reader = crate::de::read::SliceReader::new(slice);\n        let found = varint_decode_u64(\u0026mut reader, Endian::Little).unwrap_err();\n        assert_eq!(std::format!(\"{:?}\", expected), std::format!(\"{:?}\", found));\n    }\n}\n\n#[test]\nfn test_decode_u128() {\n    let cases: \u0026[(\u0026[u8], u128, u128)] = \u0026[\n        (\u0026[0], 0, 0),\n        (\u0026[10], 10, 10),\n        (\u0026[U16_BYTE, 0, 10], 2560, 10),\n        (\u0026[U32_BYTE, 0, 0, 0, 10], 167_772_160, 10),\n        (\n            \u0026[U64_BYTE, 0, 0, 0, 0, 0, 0, 0, 10],\n            72_057_594_037_9279_360,\n            10,\n        ),\n        (\n            \u0026[U128_BYTE, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10],\n            13_292_279_957_849_158_729_038_070_602_803_445_760,\n            10,\n        ),\n    ];\n    for \u0026(slice, expected_le, expected_be) in cases {\n        let mut reader = crate::de::read::SliceReader::new(slice);\n        let found = varint_decode_u128(\u0026mut reader, Endian::Little).unwrap();\n        assert_eq!(expected_le, found);\n\n        let mut reader = crate::de::read::SliceReader::new(slice);\n        let found = varint_decode_u128(\u0026mut reader, Endian::Big).unwrap();\n        assert_eq!(expected_be, found);\n    }\n\n    let errors: \u0026[(\u0026[u8], DecodeError)] = \u0026[\n        (\u0026[U16_BYTE], DecodeError::UnexpectedEnd),\n        (\u0026[U16_BYTE, 0], DecodeError::UnexpectedEnd),\n        (\u0026[U32_BYTE], DecodeError::UnexpectedEnd),\n        (\u0026[U32_BYTE, 0], DecodeError::UnexpectedEnd),\n        (\u0026[U32_BYTE, 0, 0], DecodeError::UnexpectedEnd),\n        (\u0026[U32_BYTE, 0, 0, 0], DecodeError::UnexpectedEnd),\n        (\u0026[U64_BYTE], DecodeError::UnexpectedEnd),\n        (\u0026[U64_BYTE, 0], DecodeError::UnexpectedEnd),\n        (\u0026[U64_BYTE, 0, 0], DecodeError::UnexpectedEnd),\n        (\u0026[U64_BYTE, 0, 0, 0], DecodeError::UnexpectedEnd),\n        (\u0026[U64_BYTE, 0, 0, 0, 0], DecodeError::UnexpectedEnd),\n        (\u0026[U64_BYTE, 0, 0, 0, 0, 0], DecodeError::UnexpectedEnd),\n        (\u0026[U64_BYTE, 0, 0, 0, 0, 0, 0], DecodeError::UnexpectedEnd),\n        (\u0026[U64_BYTE, 0, 0, 0, 0, 0, 0, 0], DecodeError::UnexpectedEnd),\n        (\u0026[U128_BYTE], DecodeError::UnexpectedEnd),\n        (\u0026[U128_BYTE, 0], DecodeError::UnexpectedEnd),\n        (\u0026[U128_BYTE, 0, 0], DecodeError::UnexpectedEnd),\n        (\u0026[U128_BYTE, 0, 0, 0], DecodeError::UnexpectedEnd),\n        (\u0026[U128_BYTE, 0, 0, 0, 0], DecodeError::UnexpectedEnd),\n        (\u0026[U128_BYTE, 0, 0, 0, 0, 0], DecodeError::UnexpectedEnd),\n        (\u0026[U128_BYTE, 0, 0, 0, 0, 0, 0], DecodeError::UnexpectedEnd),\n        (\n            \u0026[U128_BYTE, 0, 0, 0, 0, 0, 0, 0],\n            DecodeError::UnexpectedEnd,\n        ),\n        (\n            \u0026[U128_BYTE, 0, 0, 0, 0, 0, 0, 0, 0],\n            DecodeError::UnexpectedEnd,\n        ),\n        (\n            \u0026[U128_BYTE, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n            DecodeError::UnexpectedEnd,\n        ),\n        (\n            \u0026[U128_BYTE, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n            DecodeError::UnexpectedEnd,\n        ),\n        (\n            \u0026[U128_BYTE, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n            DecodeError::UnexpectedEnd,\n        ),\n        (\n            \u0026[U128_BYTE, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n            DecodeError::UnexpectedEnd,\n        ),\n        (\n            \u0026[U128_BYTE, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n            DecodeError::UnexpectedEnd,\n        ),\n        (\n            \u0026[U128_BYTE, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n            DecodeError::UnexpectedEnd,\n        ),\n    ];\n\n    for (slice, expected) in errors {\n        let mut reader = crate::de::read::SliceReader::new(slice);\n        let found = varint_decode_u128(\u0026mut reader, Endian::Little).unwrap_err();\n        std::dbg!(slice);\n        assert_eq!(std::format!(\"{:?}\", expected), std::format!(\"{:?}\", found));\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","trangar","development","rust","bincode","src","varint","encode_signed.rs"],"content":"use super::{varint_encode_u128, varint_encode_u16, varint_encode_u32, varint_encode_u64};\nuse crate::{config::Endian, enc::write::Writer, error::EncodeError};\n\npub fn varint_encode_i16\u003cW: Writer\u003e(\n    writer: \u0026mut W,\n    endian: Endian,\n    val: i16,\n) -\u003e Result\u003c(), EncodeError\u003e {\n    varint_encode_u16(\n        writer,\n        endian,\n        if val \u003c 0 {\n            // let's avoid the edge case of i16::min_value()\n            // !n is equal to `-n - 1`, so this is:\n            // !n * 2 + 1 = 2(-n - 1) + 1 = -2n - 2 + 1 = -2n - 1\n            !(val as u16) * 2 + 1\n        } else {\n            (val as u16) * 2\n        },\n    )\n}\n\npub fn varint_encode_i32\u003cW: Writer\u003e(\n    writer: \u0026mut W,\n    endian: Endian,\n    val: i32,\n) -\u003e Result\u003c(), EncodeError\u003e {\n    varint_encode_u32(\n        writer,\n        endian,\n        if val \u003c 0 {\n            // let's avoid the edge case of i32::min_value()\n            // !n is equal to `-n - 1`, so this is:\n            // !n * 2 + 1 = 2(-n - 1) + 1 = -2n - 2 + 1 = -2n - 1\n            !(val as u32) * 2 + 1\n        } else {\n            (val as u32) * 2\n        },\n    )\n}\n\npub fn varint_encode_i64\u003cW: Writer\u003e(\n    writer: \u0026mut W,\n    endian: Endian,\n    val: i64,\n) -\u003e Result\u003c(), EncodeError\u003e {\n    varint_encode_u64(\n        writer,\n        endian,\n        if val \u003c 0 {\n            // let's avoid the edge case of i64::min_value()\n            // !n is equal to `-n - 1`, so this is:\n            // !n * 2 + 1 = 2(-n - 1) + 1 = -2n - 2 + 1 = -2n - 1\n            !(val as u64) * 2 + 1\n        } else {\n            (val as u64) * 2\n        },\n    )\n}\n\npub fn varint_encode_i128\u003cW: Writer\u003e(\n    writer: \u0026mut W,\n    endian: Endian,\n    val: i128,\n) -\u003e Result\u003c(), EncodeError\u003e {\n    varint_encode_u128(\n        writer,\n        endian,\n        if val \u003c 0 {\n            // let's avoid the edge case of i128::min_value()\n            // !n is equal to `-n - 1`, so this is:\n            // !n * 2 + 1 = 2(-n - 1) + 1 = -2n - 2 + 1 = -2n - 1\n            !(val as u128) * 2 + 1\n        } else {\n            (val as u128) * 2\n        },\n    )\n}\n\npub fn varint_encode_isize\u003cW: Writer\u003e(\n    writer: \u0026mut W,\n    endian: Endian,\n    val: isize,\n) -\u003e Result\u003c(), EncodeError\u003e {\n    // isize is being encoded as a i64\n    varint_encode_i64(writer, endian, val as i64)\n}\n\n#[test]\nfn test_encode_i16() {\n    let cases: \u0026[(i16, \u0026[u8], \u0026[u8])] = \u0026[\n        (0, \u0026[0], \u0026[0]),\n        (2, \u0026[4], \u0026[4]),\n        (256, \u0026[super::U16_BYTE, 0, 2], \u0026[super::U16_BYTE, 2, 0]),\n        (\n            16_000,\n            \u0026[super::U16_BYTE, 0, 125],\n            \u0026[super::U16_BYTE, 125, 0],\n        ),\n        (\n            i16::MAX - 1,\n            \u0026[super::U16_BYTE, 252, 255],\n            \u0026[super::U16_BYTE, 255, 252],\n        ),\n        (\n            i16::MAX,\n            \u0026[super::U16_BYTE, 254, 255],\n            \u0026[super::U16_BYTE, 255, 254],\n        ),\n    ];\n\n    use crate::enc::write::SliceWriter;\n    let mut buffer = [0u8; 20];\n    for \u0026(value, expected_le, expected_be) in cases {\n        std::dbg!(value);\n\n        // Little endian\n        let mut writer = SliceWriter::new(\u0026mut buffer);\n        varint_encode_i16(\u0026mut writer, Endian::Little, value).unwrap();\n\n        assert_eq!(writer.bytes_written(), expected_le.len());\n        assert_eq!(\u0026buffer[..expected_le.len()], expected_le);\n\n        // Big endian\n        let mut writer = SliceWriter::new(\u0026mut buffer);\n        varint_encode_i16(\u0026mut writer, Endian::Big, value).unwrap();\n\n        assert_eq!(writer.bytes_written(), expected_be.len());\n        assert_eq!(\u0026buffer[..expected_be.len()], expected_be);\n    }\n}\n\n#[test]\nfn test_encode_i32() {\n    let cases: \u0026[(i32, \u0026[u8], \u0026[u8])] = \u0026[\n        (0, \u0026[0], \u0026[0]),\n        (2, \u0026[4], \u0026[4]),\n        (256, \u0026[super::U16_BYTE, 0, 2], \u0026[super::U16_BYTE, 2, 0]),\n        (\n            16_000,\n            \u0026[super::U16_BYTE, 0, 125],\n            \u0026[super::U16_BYTE, 125, 0],\n        ),\n        (\n            40_000,\n            \u0026[super::U32_BYTE, 128, 56, 1, 0],\n            \u0026[super::U32_BYTE, 0, 1, 56, 128],\n        ),\n        (\n            i32::MAX - 1,\n            \u0026[super::U32_BYTE, 252, 255, 255, 255],\n            \u0026[super::U32_BYTE, 255, 255, 255, 252],\n        ),\n        (\n            i32::MAX,\n            \u0026[super::U32_BYTE, 254, 255, 255, 255],\n            \u0026[super::U32_BYTE, 255, 255, 255, 254],\n        ),\n    ];\n\n    use crate::enc::write::SliceWriter;\n    let mut buffer = [0u8; 20];\n    for \u0026(value, expected_le, expected_be) in cases {\n        std::dbg!(value);\n\n        // Little endian\n        let mut writer = SliceWriter::new(\u0026mut buffer);\n        varint_encode_i32(\u0026mut writer, Endian::Little, value).unwrap();\n\n        assert_eq!(writer.bytes_written(), expected_le.len());\n        assert_eq!(\u0026buffer[..expected_le.len()], expected_le);\n\n        // Big endian\n        let mut writer = SliceWriter::new(\u0026mut buffer);\n        varint_encode_i32(\u0026mut writer, Endian::Big, value).unwrap();\n\n        assert_eq!(writer.bytes_written(), expected_be.len());\n        assert_eq!(\u0026buffer[..expected_be.len()], expected_be);\n    }\n}\n\n#[test]\nfn test_encode_i64() {\n    let cases: \u0026[(i64, \u0026[u8], \u0026[u8])] = \u0026[\n        (0, \u0026[0], \u0026[0]),\n        (2, \u0026[4], \u0026[4]),\n        (256, \u0026[super::U16_BYTE, 0, 2], \u0026[super::U16_BYTE, 2, 0]),\n        (\n            16_000,\n            \u0026[super::U16_BYTE, 0, 125],\n            \u0026[super::U16_BYTE, 125, 0],\n        ),\n        (\n            40_000,\n            \u0026[super::U32_BYTE, 128, 56, 1, 0],\n            \u0026[super::U32_BYTE, 0, 1, 56, 128],\n        ),\n        (\n            3_000_000_000,\n            \u0026[super::U64_BYTE, 0, 188, 160, 101, 1, 0, 0, 0],\n            \u0026[super::U64_BYTE, 0, 0, 0, 1, 101, 160, 188, 0],\n        ),\n        (\n            i64::MAX - 1,\n            \u0026[super::U64_BYTE, 252, 255, 255, 255, 255, 255, 255, 255],\n            \u0026[super::U64_BYTE, 255, 255, 255, 255, 255, 255, 255, 252],\n        ),\n        (\n            i64::MAX,\n            \u0026[super::U64_BYTE, 254, 255, 255, 255, 255, 255, 255, 255],\n            \u0026[super::U64_BYTE, 255, 255, 255, 255, 255, 255, 255, 254],\n        ),\n    ];\n\n    use crate::enc::write::SliceWriter;\n    let mut buffer = [0u8; 20];\n    for \u0026(value, expected_le, expected_be) in cases {\n        std::dbg!(value);\n\n        // Little endian\n        let mut writer = SliceWriter::new(\u0026mut buffer);\n        varint_encode_i64(\u0026mut writer, Endian::Little, value).unwrap();\n\n        assert_eq!(writer.bytes_written(), expected_le.len());\n        assert_eq!(\u0026buffer[..expected_le.len()], expected_le);\n\n        // Big endian\n        let mut writer = SliceWriter::new(\u0026mut buffer);\n        varint_encode_i64(\u0026mut writer, Endian::Big, value).unwrap();\n\n        assert_eq!(writer.bytes_written(), expected_be.len());\n        assert_eq!(\u0026buffer[..expected_be.len()], expected_be);\n    }\n}\n\n#[test]\nfn test_encode_i128() {\n    #[rustfmt::skip]\n    let cases: \u0026[(i128, \u0026[u8], \u0026[u8])] = \u0026[\n        (0, \u0026[0], \u0026[0]),\n        (2, \u0026[4], \u0026[4]),\n        (256, \u0026[super::U16_BYTE, 0, 2], \u0026[super::U16_BYTE, 2, 0]),\n        (\n            16_000,\n            \u0026[super::U16_BYTE, 0, 125],\n            \u0026[super::U16_BYTE, 125, 0],\n        ),\n        (\n            40_000,\n            \u0026[super::U32_BYTE, 128, 56, 1, 0],\n            \u0026[super::U32_BYTE, 0, 1, 56, 128],\n        ),\n        (\n            3_000_000_000,\n            \u0026[super::U64_BYTE, 0, 188, 160, 101, 1, 0, 0, 0],\n            \u0026[super::U64_BYTE, 0, 0, 0, 1, 101, 160, 188, 0],\n        ),\n        (\n            11_000_000_000_000_000_000,\n            \u0026[\n                super::U128_BYTE,\n                0, 0, 152, 98, 112, 179, 79, 49,\n                1, 0, 0, 0, 0, 0, 0, 0,\n            ],\n            \u0026[\n                super::U128_BYTE,\n                0, 0, 0, 0, 0, 0, 0, 1,\n                49, 79, 179, 112, 98, 152, 0, 0,\n            ],\n        ),\n        (\n            i128::MAX - 1,\n            \u0026[\n                super::U128_BYTE,\n                252, 255, 255, 255, 255, 255, 255, 255,\n                255, 255, 255, 255, 255, 255, 255, 255,\n            ],\n            \u0026[\n                super::U128_BYTE,\n                255, 255, 255, 255, 255, 255, 255, 255,\n                255, 255, 255, 255, 255, 255, 255, 252,\n            ],\n        ),\n        (\n            i128::MAX,\n            \u0026[\n                super::U128_BYTE,\n                254, 255, 255, 255, 255, 255, 255, 255,\n                255, 255, 255, 255, 255, 255, 255, 255,\n            ],\n            \u0026[\n                super::U128_BYTE,\n                255, 255, 255, 255, 255, 255, 255, 255,\n                255, 255, 255, 255, 255, 255, 255, 254,\n            ],\n        ),\n    ];\n\n    use crate::enc::write::SliceWriter;\n    let mut buffer = [0u8; 20];\n    for \u0026(value, expected_le, expected_be) in cases {\n        std::dbg!(value);\n\n        // Little endian\n        let mut writer = SliceWriter::new(\u0026mut buffer);\n        varint_encode_i128(\u0026mut writer, Endian::Little, value).unwrap();\n\n        assert_eq!(writer.bytes_written(), expected_le.len());\n        assert_eq!(\u0026buffer[..expected_le.len()], expected_le);\n\n        // Big endian\n        let mut writer = SliceWriter::new(\u0026mut buffer);\n        varint_encode_i128(\u0026mut writer, Endian::Big, value).unwrap();\n\n        assert_eq!(writer.bytes_written(), expected_be.len());\n        assert_eq!(\u0026buffer[..expected_be.len()], expected_be);\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","trangar","development","rust","bincode","src","varint","encode_unsigned.rs"],"content":"use super::{SINGLE_BYTE_MAX, U128_BYTE, U16_BYTE, U32_BYTE, U64_BYTE};\nuse crate::{config::Endian, enc::write::Writer, error::EncodeError};\n\npub fn varint_encode_u16\u003cW: Writer\u003e(\n    writer: \u0026mut W,\n    endian: Endian,\n    val: u16,\n) -\u003e Result\u003c(), EncodeError\u003e {\n    if val \u003c= SINGLE_BYTE_MAX as _ {\n        writer.write(\u0026[val as u8])\n    } else {\n        writer.write(\u0026[U16_BYTE])?;\n        match endian {\n            Endian::Big =\u003e writer.write(\u0026val.to_be_bytes()),\n            Endian::Little =\u003e writer.write(\u0026val.to_le_bytes()),\n        }\n    }\n}\n\npub fn varint_encode_u32\u003cW: Writer\u003e(\n    writer: \u0026mut W,\n    endian: Endian,\n    val: u32,\n) -\u003e Result\u003c(), EncodeError\u003e {\n    if val \u003c= SINGLE_BYTE_MAX as _ {\n        writer.write(\u0026[val as u8])\n    } else if val \u003c= u16::MAX as _ {\n        writer.write(\u0026[U16_BYTE])?;\n        match endian {\n            Endian::Big =\u003e writer.write(\u0026(val as u16).to_be_bytes()),\n            Endian::Little =\u003e writer.write(\u0026(val as u16).to_le_bytes()),\n        }\n    } else {\n        writer.write(\u0026[U32_BYTE])?;\n        match endian {\n            Endian::Big =\u003e writer.write(\u0026val.to_be_bytes()),\n            Endian::Little =\u003e writer.write(\u0026val.to_le_bytes()),\n        }\n    }\n}\n\npub fn varint_encode_u64\u003cW: Writer\u003e(\n    writer: \u0026mut W,\n    endian: Endian,\n    val: u64,\n) -\u003e Result\u003c(), EncodeError\u003e {\n    if val \u003c= SINGLE_BYTE_MAX as _ {\n        writer.write(\u0026[val as u8])\n    } else if val \u003c= u16::MAX as _ {\n        writer.write(\u0026[U16_BYTE])?;\n        match endian {\n            Endian::Big =\u003e writer.write(\u0026(val as u16).to_be_bytes()),\n            Endian::Little =\u003e writer.write(\u0026(val as u16).to_le_bytes()),\n        }\n    } else if val \u003c= u32::MAX as _ {\n        writer.write(\u0026[U32_BYTE])?;\n        match endian {\n            Endian::Big =\u003e writer.write(\u0026(val as u32).to_be_bytes()),\n            Endian::Little =\u003e writer.write(\u0026(val as u32).to_le_bytes()),\n        }\n    } else {\n        writer.write(\u0026[U64_BYTE])?;\n        match endian {\n            Endian::Big =\u003e writer.write(\u0026val.to_be_bytes()),\n            Endian::Little =\u003e writer.write(\u0026val.to_le_bytes()),\n        }\n    }\n}\n\npub fn varint_encode_u128\u003cW: Writer\u003e(\n    writer: \u0026mut W,\n    endian: Endian,\n    val: u128,\n) -\u003e Result\u003c(), EncodeError\u003e {\n    if val \u003c= SINGLE_BYTE_MAX as _ {\n        writer.write(\u0026[val as u8])\n    } else if val \u003c= u16::MAX as _ {\n        writer.write(\u0026[U16_BYTE])?;\n        match endian {\n            Endian::Big =\u003e writer.write(\u0026(val as u16).to_be_bytes()),\n            Endian::Little =\u003e writer.write(\u0026(val as u16).to_le_bytes()),\n        }\n    } else if val \u003c= u32::MAX as _ {\n        writer.write(\u0026[U32_BYTE])?;\n        match endian {\n            Endian::Big =\u003e writer.write(\u0026(val as u32).to_be_bytes()),\n            Endian::Little =\u003e writer.write(\u0026(val as u32).to_le_bytes()),\n        }\n    } else if val \u003c= u64::MAX as _ {\n        writer.write(\u0026[U64_BYTE])?;\n        match endian {\n            Endian::Big =\u003e writer.write(\u0026(val as u64).to_be_bytes()),\n            Endian::Little =\u003e writer.write(\u0026(val as u64).to_le_bytes()),\n        }\n    } else {\n        writer.write(\u0026[U128_BYTE])?;\n        match endian {\n            Endian::Big =\u003e writer.write(\u0026val.to_be_bytes()),\n            Endian::Little =\u003e writer.write(\u0026val.to_le_bytes()),\n        }\n    }\n}\n\npub fn varint_encode_usize\u003cW: Writer\u003e(\n    writer: \u0026mut W,\n    endian: Endian,\n    val: usize,\n) -\u003e Result\u003c(), EncodeError\u003e {\n    // usize is being encoded as a u64\n    varint_encode_u64(writer, endian, val as u64)\n}\n\n#[test]\nfn test_encode_u16() {\n    use crate::enc::write::SliceWriter;\n    let mut buffer = [0u8; 20];\n\n    // these should all encode to a single byte\n    for i in 0u16..=SINGLE_BYTE_MAX as u16 {\n        let mut writer = SliceWriter::new(\u0026mut buffer);\n        varint_encode_u16(\u0026mut writer, Endian::Big, i).unwrap();\n        assert_eq!(writer.bytes_written(), 1);\n        assert_eq!(buffer[0] as u16, i);\n\n        // Assert endianness doesn't matter\n        let mut writer = SliceWriter::new(\u0026mut buffer);\n        varint_encode_u16(\u0026mut writer, Endian::Little, i).unwrap();\n        assert_eq!(writer.bytes_written(), 1);\n        assert_eq!(buffer[0] as u16, i);\n    }\n\n    // these values should encode in 3 bytes (leading byte + 2 bytes)\n    // Values chosen at random, add new cases as needed\n    for i in [\n        SINGLE_BYTE_MAX as u16 + 1,\n        300,\n        500,\n        700,\n        888,\n        1234,\n        u16::MAX,\n    ] {\n        let mut writer = SliceWriter::new(\u0026mut buffer);\n        varint_encode_u16(\u0026mut writer, Endian::Big, i).unwrap();\n        assert_eq!(writer.bytes_written(), 3);\n        assert_eq!(buffer[0], U16_BYTE);\n        assert_eq!(\u0026buffer[1..3], \u0026i.to_be_bytes());\n\n        let mut writer = SliceWriter::new(\u0026mut buffer);\n        varint_encode_u16(\u0026mut writer, Endian::Little, i).unwrap();\n        assert_eq!(writer.bytes_written(), 3);\n        assert_eq!(buffer[0], U16_BYTE);\n        assert_eq!(\u0026buffer[1..3], \u0026i.to_le_bytes());\n    }\n}\n\n#[test]\nfn test_encode_u32() {\n    use crate::enc::write::SliceWriter;\n    let mut buffer = [0u8; 20];\n\n    // these should all encode to a single byte\n    for i in 0u32..=SINGLE_BYTE_MAX as u32 {\n        let mut writer = SliceWriter::new(\u0026mut buffer);\n        varint_encode_u32(\u0026mut writer, Endian::Big, i).unwrap();\n        assert_eq!(writer.bytes_written(), 1);\n        assert_eq!(buffer[0] as u32, i);\n\n        // Assert endianness doesn't matter\n        let mut writer = SliceWriter::new(\u0026mut buffer);\n        varint_encode_u32(\u0026mut writer, Endian::Little, i).unwrap();\n        assert_eq!(writer.bytes_written(), 1);\n        assert_eq!(buffer[0] as u32, i);\n    }\n\n    // these values should encode in 3 bytes (leading byte + 2 bytes)\n    // Values chosen at random, add new cases as needed\n    for i in [\n        SINGLE_BYTE_MAX as u32 + 1,\n        300,\n        500,\n        700,\n        888,\n        1234,\n        u16::MAX as u32,\n    ] {\n        let mut writer = SliceWriter::new(\u0026mut buffer);\n        varint_encode_u32(\u0026mut writer, Endian::Big, i).unwrap();\n        assert_eq!(writer.bytes_written(), 3);\n        assert_eq!(buffer[0], U16_BYTE);\n        assert_eq!(\u0026buffer[1..3], \u0026(i as u16).to_be_bytes());\n\n        let mut writer = SliceWriter::new(\u0026mut buffer);\n        varint_encode_u32(\u0026mut writer, Endian::Little, i).unwrap();\n        assert_eq!(writer.bytes_written(), 3);\n        assert_eq!(buffer[0], U16_BYTE);\n        assert_eq!(\u0026buffer[1..3], \u0026(i as u16).to_le_bytes());\n    }\n\n    // these values should encode in 5 bytes (leading byte + 4 bytes)\n    // Values chosen at random, add new cases as needed\n    for i in [u16::MAX as u32 + 1, 100_000, 1_000_000, u32::MAX] {\n        let mut writer = SliceWriter::new(\u0026mut buffer);\n        varint_encode_u32(\u0026mut writer, Endian::Big, i).unwrap();\n        assert_eq!(writer.bytes_written(), 5);\n        assert_eq!(buffer[0], U32_BYTE);\n        assert_eq!(\u0026buffer[1..5], \u0026i.to_be_bytes());\n\n        let mut writer = SliceWriter::new(\u0026mut buffer);\n        varint_encode_u32(\u0026mut writer, Endian::Little, i).unwrap();\n        assert_eq!(writer.bytes_written(), 5);\n        assert_eq!(buffer[0], U32_BYTE);\n        assert_eq!(\u0026buffer[1..5], \u0026i.to_le_bytes());\n    }\n}\n\n#[test]\nfn test_encode_u64() {\n    use crate::enc::write::SliceWriter;\n    let mut buffer = [0u8; 20];\n\n    // these should all encode to a single byte\n    for i in 0u64..=SINGLE_BYTE_MAX as u64 {\n        let mut writer = SliceWriter::new(\u0026mut buffer);\n        varint_encode_u64(\u0026mut writer, Endian::Big, i).unwrap();\n        assert_eq!(writer.bytes_written(), 1);\n        assert_eq!(buffer[0] as u64, i);\n\n        // Assert endianness doesn't matter\n        let mut writer = SliceWriter::new(\u0026mut buffer);\n        varint_encode_u64(\u0026mut writer, Endian::Little, i).unwrap();\n        assert_eq!(writer.bytes_written(), 1);\n        assert_eq!(buffer[0] as u64, i);\n    }\n\n    // these values should encode in 3 bytes (leading byte + 2 bytes)\n    // Values chosen at random, add new cases as needed\n    for i in [\n        SINGLE_BYTE_MAX as u64 + 1,\n        300,\n        500,\n        700,\n        888,\n        1234,\n        u16::MAX as u64,\n    ] {\n        let mut writer = SliceWriter::new(\u0026mut buffer);\n        varint_encode_u64(\u0026mut writer, Endian::Big, i).unwrap();\n        assert_eq!(writer.bytes_written(), 3);\n        assert_eq!(buffer[0], U16_BYTE);\n        assert_eq!(\u0026buffer[1..3], \u0026(i as u16).to_be_bytes());\n\n        let mut writer = SliceWriter::new(\u0026mut buffer);\n        varint_encode_u64(\u0026mut writer, Endian::Little, i).unwrap();\n        assert_eq!(writer.bytes_written(), 3);\n        assert_eq!(buffer[0], U16_BYTE);\n        assert_eq!(\u0026buffer[1..3], \u0026(i as u16).to_le_bytes());\n    }\n\n    // these values should encode in 5 bytes (leading byte + 4 bytes)\n    // Values chosen at random, add new cases as needed\n    for i in [u16::MAX as u64 + 1, 100_000, 1_000_000, u32::MAX as u64] {\n        let mut writer = SliceWriter::new(\u0026mut buffer);\n        varint_encode_u64(\u0026mut writer, Endian::Big, i).unwrap();\n        assert_eq!(writer.bytes_written(), 5);\n        assert_eq!(buffer[0], U32_BYTE);\n        assert_eq!(\u0026buffer[1..5], \u0026(i as u32).to_be_bytes());\n\n        let mut writer = SliceWriter::new(\u0026mut buffer);\n        varint_encode_u64(\u0026mut writer, Endian::Little, i).unwrap();\n        assert_eq!(writer.bytes_written(), 5);\n        assert_eq!(buffer[0], U32_BYTE);\n        assert_eq!(\u0026buffer[1..5], \u0026(i as u32).to_le_bytes());\n    }\n\n    // these values should encode in 9 bytes (leading byte + 8 bytes)\n    // Values chosen at random, add new cases as needed\n    for i in [u32::MAX as u64 + 1, 500_0000_000, u64::MAX] {\n        let mut writer = SliceWriter::new(\u0026mut buffer);\n        varint_encode_u64(\u0026mut writer, Endian::Big, i).unwrap();\n        assert_eq!(writer.bytes_written(), 9);\n        assert_eq!(buffer[0], U64_BYTE);\n        assert_eq!(\u0026buffer[1..9], \u0026i.to_be_bytes());\n\n        let mut writer = SliceWriter::new(\u0026mut buffer);\n        varint_encode_u64(\u0026mut writer, Endian::Little, i).unwrap();\n        assert_eq!(writer.bytes_written(), 9);\n        assert_eq!(buffer[0], U64_BYTE);\n        assert_eq!(\u0026buffer[1..9], \u0026i.to_le_bytes());\n    }\n}\n\n#[test]\nfn test_encode_u128() {\n    use crate::enc::write::SliceWriter;\n    let mut buffer = [0u8; 20];\n\n    // these should all encode to a single byte\n    for i in 0u128..=SINGLE_BYTE_MAX as u128 {\n        let mut writer = SliceWriter::new(\u0026mut buffer);\n        varint_encode_u128(\u0026mut writer, Endian::Big, i).unwrap();\n        assert_eq!(writer.bytes_written(), 1);\n        assert_eq!(buffer[0] as u128, i);\n\n        // Assert endianness doesn't matter\n        let mut writer = SliceWriter::new(\u0026mut buffer);\n        varint_encode_u128(\u0026mut writer, Endian::Little, i).unwrap();\n        assert_eq!(writer.bytes_written(), 1);\n        assert_eq!(buffer[0] as u128, i);\n    }\n\n    // these values should encode in 3 bytes (leading byte + 2 bytes)\n    // Values chosen at random, add new cases as needed\n    for i in [\n        SINGLE_BYTE_MAX as u128 + 1,\n        300,\n        500,\n        700,\n        888,\n        1234,\n        u16::MAX as u128,\n    ] {\n        let mut writer = SliceWriter::new(\u0026mut buffer);\n        varint_encode_u128(\u0026mut writer, Endian::Big, i).unwrap();\n        assert_eq!(writer.bytes_written(), 3);\n        assert_eq!(buffer[0], U16_BYTE);\n        assert_eq!(\u0026buffer[1..3], \u0026(i as u16).to_be_bytes());\n\n        let mut writer = SliceWriter::new(\u0026mut buffer);\n        varint_encode_u128(\u0026mut writer, Endian::Little, i).unwrap();\n        assert_eq!(writer.bytes_written(), 3);\n        assert_eq!(buffer[0], U16_BYTE);\n        assert_eq!(\u0026buffer[1..3], \u0026(i as u16).to_le_bytes());\n    }\n\n    // these values should encode in 5 bytes (leading byte + 4 bytes)\n    // Values chosen at random, add new cases as needed\n    for i in [u16::MAX as u128 + 1, 100_000, 1_000_000, u32::MAX as u128] {\n        let mut writer = SliceWriter::new(\u0026mut buffer);\n        varint_encode_u128(\u0026mut writer, Endian::Big, i).unwrap();\n        assert_eq!(writer.bytes_written(), 5);\n        assert_eq!(buffer[0], U32_BYTE);\n        assert_eq!(\u0026buffer[1..5], \u0026(i as u32).to_be_bytes());\n\n        let mut writer = SliceWriter::new(\u0026mut buffer);\n        varint_encode_u128(\u0026mut writer, Endian::Little, i).unwrap();\n        assert_eq!(writer.bytes_written(), 5);\n        assert_eq!(buffer[0], U32_BYTE);\n        assert_eq!(\u0026buffer[1..5], \u0026(i as u32).to_le_bytes());\n    }\n\n    // these values should encode in 9 bytes (leading byte + 8 bytes)\n    // Values chosen at random, add new cases as needed\n    for i in [u32::MAX as u128 + 1, 500_0000_000, u64::MAX as u128] {\n        let mut writer = SliceWriter::new(\u0026mut buffer);\n        varint_encode_u128(\u0026mut writer, Endian::Big, i).unwrap();\n        assert_eq!(writer.bytes_written(), 9);\n        assert_eq!(buffer[0], U64_BYTE);\n        assert_eq!(\u0026buffer[1..9], \u0026(i as u64).to_be_bytes());\n\n        let mut writer = SliceWriter::new(\u0026mut buffer);\n        varint_encode_u128(\u0026mut writer, Endian::Little, i).unwrap();\n        assert_eq!(writer.bytes_written(), 9);\n        assert_eq!(buffer[0], U64_BYTE);\n        assert_eq!(\u0026buffer[1..9], \u0026(i as u64).to_le_bytes());\n    }\n\n    // these values should encode in 17 bytes (leading byte + 16 bytes)\n    // Values chosen at random, add new cases as needed\n    for i in [u64::MAX as u128 + 1, u128::MAX] {\n        let mut writer = SliceWriter::new(\u0026mut buffer);\n        varint_encode_u128(\u0026mut writer, Endian::Big, i).unwrap();\n        assert_eq!(writer.bytes_written(), 17);\n        assert_eq!(buffer[0], U128_BYTE);\n        assert_eq!(\u0026buffer[1..17], \u0026i.to_be_bytes());\n\n        let mut writer = SliceWriter::new(\u0026mut buffer);\n        varint_encode_u128(\u0026mut writer, Endian::Little, i).unwrap();\n        assert_eq!(writer.bytes_written(), 17);\n        assert_eq!(buffer[0], U128_BYTE);\n        assert_eq!(\u0026buffer[1..17], \u0026i.to_le_bytes());\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","trangar","development","rust","bincode","src","varint","mod.rs"],"content":"mod decode_signed;\nmod decode_unsigned;\nmod encode_signed;\nmod encode_unsigned;\n\npub use self::{\n    decode_signed::{\n        varint_decode_i128, varint_decode_i16, varint_decode_i32, varint_decode_i64,\n        varint_decode_isize,\n    },\n    decode_unsigned::{\n        varint_decode_u128, varint_decode_u16, varint_decode_u32, varint_decode_u64,\n        varint_decode_usize,\n    },\n    encode_signed::{\n        varint_encode_i128, varint_encode_i16, varint_encode_i32, varint_encode_i64,\n        varint_encode_isize,\n    },\n    encode_unsigned::{\n        varint_encode_u128, varint_encode_u16, varint_encode_u32, varint_encode_u64,\n        varint_encode_usize,\n    },\n};\n\npub(self) const SINGLE_BYTE_MAX: u8 = 250;\npub(self) const U16_BYTE: u8 = 251;\npub(self) const U32_BYTE: u8 = 252;\npub(self) const U64_BYTE: u8 = 253;\npub(self) const U128_BYTE: u8 = 254;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","trangar","development","rust","bincode","tests","derive.rs"],"content":"#![cfg(feature = \"derive\")]\n\nuse bincode::{de::Decodable, enc::Encodeable};\n\n#[derive(bincode::Encodable, PartialEq, Debug)]\npub(crate) struct Test\u003cT: Encodeable\u003e {\n    a: T,\n    b: u32,\n    c: u8,\n}\n\n#[derive(bincode::Decodable, PartialEq, Debug, Eq)]\npub struct Test2\u003cT: Decodable\u003e {\n    a: T,\n    b: u32,\n    c: u32,\n}\n\n#[derive(bincode::Decodable, PartialEq, Debug, Eq)]\npub struct Test3\u003c'a\u003e {\n    a: \u0026'a str,\n    b: u32,\n    c: u32,\n}\n\n#[derive(bincode::Encodable, bincode::Decodable, PartialEq, Debug, Eq)]\npub struct TestTupleStruct(u32, u32, u32);\n\n#[derive(bincode::Encodable, bincode::Decodable, PartialEq, Debug, Eq)]\npub enum TestEnum {\n    Foo,\n    Bar { name: u32 },\n    Baz(u32, u32, u32),\n}\n\n#[derive(bincode::Encodable, bincode::Decodable, PartialEq, Debug, Eq)]\npub enum TestEnum2\u003c'a\u003e {\n    Foo,\n    Bar { name: \u0026'a str },\n    Baz(u32, u32, u32),\n}\n\n#[test]\nfn test_encodable() {\n    let start = Test {\n        a: 5i32,\n        b: 10u32,\n        c: 20u8,\n    };\n    let mut slice = [0u8; 1024];\n    let bytes_written = bincode::encode_into_slice(start, \u0026mut slice).unwrap();\n    assert_eq!(bytes_written, 3);\n    assert_eq!(\u0026slice[..bytes_written], \u0026[10, 10, 20]);\n}\n\n#[cfg(feature = \"std\")]\n#[test]\nfn test_decodable() {\n    let start = Test2 {\n        a: 5u32,\n        b: 10u32,\n        c: 1024u32,\n    };\n    let slice = [5, 10, 251, 0, 4];\n    let result: Test2\u003cu32\u003e = bincode::decode_from(\u0026mut slice.as_ref()).unwrap();\n    assert_eq!(result, start);\n}\n\n#[test]\nfn test_encodable_tuple() {\n    let start = TestTupleStruct(5, 10, 1024);\n    let mut slice = [0u8; 1024];\n    let bytes_written = bincode::encode_into_slice(start, \u0026mut slice).unwrap();\n    assert_eq!(bytes_written, 5);\n    assert_eq!(\u0026slice[..bytes_written], \u0026[5, 10, 251, 0, 4]);\n}\n\n#[test]\nfn test_decodable_tuple() {\n    let start = TestTupleStruct(5, 10, 1024);\n    let mut slice = [5, 10, 251, 0, 4];\n    let result: TestTupleStruct = bincode::decode(\u0026mut slice).unwrap();\n    assert_eq!(result, start);\n}\n\n#[test]\nfn test_encodable_enum_struct_variant() {\n    let start = TestEnum::Bar { name: 5u32 };\n    let mut slice = [0u8; 1024];\n    let bytes_written = bincode::encode_into_slice(start, \u0026mut slice).unwrap();\n    assert_eq!(bytes_written, 2);\n    assert_eq!(\u0026slice[..bytes_written], \u0026[1, 5]);\n}\n\n#[test]\nfn test_decodable_enum_struct_variant() {\n    let start = TestEnum::Bar { name: 5u32 };\n    let mut slice = [1, 5];\n    let result: TestEnum = bincode::decode(\u0026mut slice).unwrap();\n    assert_eq!(result, start);\n}\n\n#[test]\nfn test_encodable_enum_tuple_variant() {\n    let start = TestEnum::Baz(5, 10, 1024);\n    let mut slice = [0u8; 1024];\n    let bytes_written = bincode::encode_into_slice(start, \u0026mut slice).unwrap();\n    assert_eq!(bytes_written, 6);\n    assert_eq!(\u0026slice[..bytes_written], \u0026[2, 5, 10, 251, 0, 4]);\n}\n\n#[test]\nfn test_decodable_enum_unit_variant() {\n    let start = TestEnum::Foo;\n    let mut slice = [0];\n    let result: TestEnum = bincode::decode(\u0026mut slice).unwrap();\n    assert_eq!(result, start);\n}\n\n#[test]\nfn test_encodable_enum_unit_variant() {\n    let start = TestEnum::Foo;\n    let mut slice = [0u8; 1024];\n    let bytes_written = bincode::encode_into_slice(start, \u0026mut slice).unwrap();\n    assert_eq!(bytes_written, 1);\n    assert_eq!(\u0026slice[..bytes_written], \u0026[0]);\n}\n\n#[test]\nfn test_decodable_enum_tuple_variant() {\n    let start = TestEnum::Baz(5, 10, 1024);\n    let mut slice = [2, 5, 10, 251, 0, 4];\n    let result: TestEnum = bincode::decode(\u0026mut slice).unwrap();\n    assert_eq!(result, start);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","trangar","development","rust","bincode","tests","test.rs"],"content":"use bincode::config::{self, Config};\nuse core::fmt::Debug;\n\nfn the_same_with_config\u003cV, C\u003e(element: V, config: C)\nwhere\n    V: bincode::enc::Encodeable\n        + for\u003c'de\u003e bincode::de::Decodable\n        + PartialEq\n        + Debug\n        + Clone\n        + 'static,\n    C: Config,\n{\n    let mut buffer = [0u8; 32];\n    bincode::encode_into_slice_with_config(element.clone(), \u0026mut buffer, config).unwrap();\n    let decoded: V = bincode::decode_with_config(\u0026mut buffer, config).unwrap();\n\n    assert_eq!(element, decoded);\n}\nfn the_same\u003cV\u003e(element: V)\nwhere\n    V: bincode::enc::Encodeable\n        + for\u003c'de\u003e bincode::de::Decodable\n        + PartialEq\n        + Debug\n        + Clone\n        + 'static,\n{\n    the_same_with_config(\n        element.clone(),\n        config::Default\n            .with_little_endian()\n            .with_fixed_int_encoding(),\n    );\n    the_same_with_config(\n        element.clone(),\n        config::Default.with_big_endian().with_fixed_int_encoding(),\n    );\n    the_same_with_config(\n        element.clone(),\n        config::Default\n            .with_little_endian()\n            .with_variable_int_encoding(),\n    );\n    the_same_with_config(\n        element,\n        config::Default\n            .with_big_endian()\n            .with_variable_int_encoding(),\n    );\n}\n\n#[test]\nfn test_numbers() {\n    the_same(5u8);\n    the_same(5u16);\n    the_same(5u32);\n    the_same(5u64);\n    the_same(5u128);\n    the_same(5usize);\n\n    the_same(5i8);\n    the_same(5i16);\n    the_same(5i32);\n    the_same(5i64);\n    the_same(5i128);\n    the_same(5isize);\n\n    the_same(5.0f32);\n    the_same(5.0f64);\n}\n\n#[test]\nfn test_slice() {\n    let mut buffer = [0u8; 32];\n    let input: \u0026[u8] = \u0026[1, 2, 3, 4, 5, 6, 7];\n    bincode::encode_into_slice(input, \u0026mut buffer).unwrap();\n    assert_eq!(\u0026buffer[..8], \u0026[7, 1, 2, 3, 4, 5, 6, 7]);\n\n    let output: \u0026[u8] = bincode::decode(\u0026mut buffer[..8]).unwrap();\n    assert_eq!(input, output);\n}\n\n#[test]\nfn test_str() {\n    let mut buffer = [0u8; 32];\n    let input: \u0026str = \"Hello world\";\n    bincode::encode_into_slice(input, \u0026mut buffer).unwrap();\n    assert_eq!(\n        \u0026buffer[..12],\n        \u0026[11, 72, 101, 108, 108, 111, 32, 119, 111, 114, 108, 100]\n    );\n\n    let output: \u0026str = bincode::decode(\u0026mut buffer[..12]).unwrap();\n    assert_eq!(input, output);\n}\n\n#[test]\nfn test_array() {\n    let mut buffer = [0u8; 32];\n    let input: [u8; 10] = [10, 20, 30, 40, 50, 60, 70, 80, 90, 100];\n    bincode::encode_into_slice(input, \u0026mut buffer).unwrap();\n    assert_eq!(\u0026buffer[..10], \u0026[10, 20, 30, 40, 50, 60, 70, 80, 90, 100]);\n\n    let output: [u8; 10] = bincode::decode(\u0026mut buffer[..10]).unwrap();\n    assert_eq!(input, output);\n}\n","traces":[],"covered":0,"coverable":0}]};
        var previousData = {"files":[{"path":["/","home","trangar","development","rust","bincode","derive","src","derive_enum.rs"],"content":"use crate::Result;\nuse proc_macro::TokenStream;\nuse proc_macro2::{Span, TokenStream as TokenStream2};\nuse quote::{quote, ToTokens};\nuse syn::{\n    spanned::Spanned, Fields, GenericParam, Generics, Ident, Index, Lifetime, LifetimeDef, Variant,\n};\npub struct DeriveEnum {\n    name: Ident,\n    generics: Generics,\n    variants: Vec\u003cVariant\u003e,\n}\n\nimpl DeriveEnum {\n    pub fn parse(name: Ident, generics: Generics, en: syn::DataEnum) -\u003e Result\u003cSelf\u003e {\n        let variants = en.variants.into_iter().collect();\n\n        Ok(DeriveEnum {\n            name,\n            generics,\n            variants,\n        })\n    }\n\n    pub fn generate_encodable(self) -\u003e Result\u003cTokenStream\u003e {\n        let DeriveEnum {\n            name,\n            generics,\n            variants,\n        } = self;\n\n        let (impl_generics, ty_generics, where_clause) = generics.split_for_impl();\n\n        let match_arms = variants.iter().enumerate().map(|(index, variant)| {\n            let fields_section = fields_to_match_arm(\u0026variant.fields);\n            let encode_statements = field_names_to_encodable(\u0026fields_to_names(\u0026variant.fields));\n            let variant_name = variant.ident.clone();\n            quote! {\n                #name :: #variant_name #fields_section =\u003e {\n                    encoder.encode_u32(#index as u32)?;\n                    #(#encode_statements)*\n                }\n            }\n        });\n        let result = quote! {\n            impl #impl_generics bincode::enc::Encodeable for #name #ty_generics #where_clause {\n                fn encode\u003cE: bincode::enc::Encode\u003e(\u0026self, mut encoder: E) -\u003e Result\u003c(), bincode::error::EncodeError\u003e {\n                    match self {\n                        #(#match_arms)*\n                    }\n                    Ok(())\n                }\n\n            }\n        };\n\n        Ok(result.into())\n    }\n\n    pub fn generate_decodable(self) -\u003e Result\u003cTokenStream\u003e {\n        let DeriveEnum {\n            name,\n            generics,\n            variants,\n        } = self;\n\n        let (mut impl_generics, ty_generics, where_clause) = generics.split_for_impl();\n\n        // check if the type has lifetimes\n        let mut should_insert_lifetime = false;\n\n        for param in \u0026generics.params {\n            if let GenericParam::Lifetime(_) = param {\n                should_insert_lifetime = true;\n                break;\n            }\n        }\n\n        // if we don't have a '__de lifetime, insert it\n        let mut generics_with_decode_lifetime;\n        if should_insert_lifetime {\n            generics_with_decode_lifetime = generics.clone();\n\n            let mut new_lifetime = LifetimeDef::new(Lifetime::new(\"'__de\", Span::call_site()));\n\n            for param in \u0026generics.params {\n                if let GenericParam::Lifetime(lt) = param {\n                    new_lifetime.bounds.push(lt.lifetime.clone())\n                }\n            }\n\n            generics_with_decode_lifetime\n                .params\n                .push(GenericParam::Lifetime(new_lifetime));\n\n            impl_generics = generics_with_decode_lifetime.split_for_impl().0;\n        }\n\n        let max_variant = (variants.len() - 1) as u32;\n        let match_arms = variants.iter().enumerate().map(|(index, variant)| {\n            let index = index as u32;\n            let decode_statements = field_names_to_decodable(\n                \u0026fields_to_constructable_names(\u0026variant.fields),\n                should_insert_lifetime,\n            );\n            let variant_name = variant.ident.clone();\n            quote! {\n                #index =\u003e {\n                    #name :: #variant_name {\n                        #(#decode_statements)*\n                    }\n                }\n            }\n        });\n        let result = if should_insert_lifetime {\n            quote! {\n                impl #impl_generics bincode::de::BorrowDecodable\u003c'__de\u003e for #name #ty_generics #where_clause {\n                    fn borrow_decode\u003cD: bincode::de::BorrowDecode\u003c'__de\u003e\u003e(mut decoder: D) -\u003e Result\u003cSelf, bincode::error::DecodeError\u003e {\n                        let i = decoder.decode_u32()?;\n                        Ok(match i {\n                            #(#match_arms)*\n                            variant =\u003e return Err(bincode::error::DecodeError::UnexpectedVariant{\n                                min: 0,\n                                max: #max_variant,\n                                found: variant,\n                            })\n                        })\n                    }\n\n                }\n            }\n        } else {\n            quote! {\n                impl #impl_generics bincode::de::Decodable for #name #ty_generics #where_clause {\n                    fn decode\u003cD: bincode::de::Decode\u003e(mut decoder: D) -\u003e Result\u003cSelf, bincode::error::DecodeError\u003e {\n                        let i = decoder.decode_u32()?;\n                        Ok(match i {\n                            #(#match_arms)*\n                            variant =\u003e return Err(bincode::error::DecodeError::UnexpectedVariant{\n                                min: 0,\n                                max: #max_variant,\n                                found: variant,\n                            })\n                        })\n                    }\n\n                }\n            }\n        };\n\n        Ok(result.into())\n    }\n}\n\nfn fields_to_match_arm(fields: \u0026Fields) -\u003e TokenStream2 {\n    match fields {\n        syn::Fields::Named(fields) =\u003e {\n            let fields: Vec\u003c_\u003e = fields\n                .named\n                .iter()\n                .map(|f| f.ident.clone().unwrap().to_token_stream())\n                .collect();\n            quote! {\n                {#(#fields),*}\n            }\n        }\n        syn::Fields::Unnamed(fields) =\u003e {\n            let fields: Vec\u003c_\u003e = fields\n                .unnamed\n                .iter()\n                .enumerate()\n                .map(|(i, f)| Ident::new(\u0026format!(\"_{}\", i), f.span()))\n                .collect();\n            quote! {\n                (#(#fields),*)\n            }\n        }\n        syn::Fields::Unit =\u003e quote! {},\n    }\n}\n\nfn fields_to_names(fields: \u0026Fields) -\u003e Vec\u003cTokenStream2\u003e {\n    match fields {\n        syn::Fields::Named(fields) =\u003e fields\n            .named\n            .iter()\n            .map(|f| f.ident.clone().unwrap().to_token_stream())\n            .collect(),\n        syn::Fields::Unnamed(fields) =\u003e fields\n            .unnamed\n            .iter()\n            .enumerate()\n            .map(|(i, f)| Ident::new(\u0026format!(\"_{}\", i), f.span()).to_token_stream())\n            .collect(),\n        syn::Fields::Unit =\u003e Vec::new(),\n    }\n}\n\nfn field_names_to_encodable(names: \u0026[TokenStream2]) -\u003e Vec\u003cTokenStream2\u003e {\n    names\n        .iter()\n        .map(|field| {\n            quote! {\n                bincode::enc::Encodeable::encode(#field, \u0026mut encoder)?;\n            }\n        })\n        .collect::\u003cVec\u003c_\u003e\u003e()\n}\n\nfn fields_to_constructable_names(fields: \u0026Fields) -\u003e Vec\u003cTokenStream2\u003e {\n    match fields {\n        syn::Fields::Named(fields) =\u003e fields\n            .named\n            .iter()\n            .map(|f| f.ident.clone().unwrap().to_token_stream())\n            .collect(),\n        syn::Fields::Unnamed(fields) =\u003e fields\n            .unnamed\n            .iter()\n            .enumerate()\n            .map(|(i, _)| Index::from(i).to_token_stream())\n            .collect(),\n        syn::Fields::Unit =\u003e Vec::new(),\n    }\n}\n\nfn field_names_to_decodable(names: \u0026[TokenStream2], borrowed: bool) -\u003e Vec\u003cTokenStream2\u003e {\n    names\n        .iter()\n        .map(|field| {\n            if borrowed {\n                quote! {\n                    #field: bincode::de::BorrowDecodable::borrow_decode(\u0026mut decoder)?,\n                }\n            } else {\n                quote! {\n                    #field: bincode::de::Decodable::decode(\u0026mut decoder)?,\n                }\n            }\n        })\n        .collect::\u003cVec\u003c_\u003e\u003e()\n}\n","traces":[{"line":15,"address":[212883,212448],"length":1,"stats":{"Line":0},"fn_name":"parse"},{"line":16,"address":[212478],"length":1,"stats":{"Line":0},"fn_name":null},{"line":18,"address":[212703],"length":1,"stats":{"Line":0},"fn_name":null},{"line":19,"address":[212607],"length":1,"stats":{"Line":0},"fn_name":null},{"line":20,"address":[212638],"length":1,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[212664],"length":1,"stats":{"Line":0},"fn_name":null},{"line":25,"address":[215972,212912],"length":1,"stats":{"Line":0},"fn_name":"generate_encodable"},{"line":26,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[212924],"length":1,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[212950],"length":1,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[213019],"length":1,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[213049],"length":1,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[213202,213129],"length":1,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[281869],"length":1,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[281888,281994],"length":1,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[282058],"length":1,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[282122,282200],"length":1,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[213294],"length":1,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[215745],"length":1,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[216016,225146],"length":1,"stats":{"Line":0},"fn_name":"generate_decodable"},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[216031],"length":1,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[216082],"length":1,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[216154],"length":1,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[216184],"length":1,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[216259],"length":1,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[216275,216526,216354,216474,216478],"length":1,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[216510],"length":1,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[216516],"length":1,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[216550,217524],"length":1,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[216565],"length":1,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[216758,216696],"length":1,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[217179,216953,216861,217054,217078],"length":1,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[217177,217115],"length":1,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[217197,217141],"length":1,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[217466],"length":1,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[217206],"length":1,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[217473],"length":1,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[217632,217553],"length":1,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[217674,217609],"length":1,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[283152],"length":1,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[283226],"length":1,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[283158],"length":1,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[283215],"length":1,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[283299],"length":1,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[283357,283432],"length":1,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[217793,224907],"length":1,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[217825],"length":1,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[221471,217803],"length":1,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[221399,224916],"length":1,"stats":{"Line":0},"fn_name":null},{"line":155,"address":[225200,226032],"length":1,"stats":{"Line":0},"fn_name":"fields_to_match_arm"},{"line":156,"address":[225272],"length":1,"stats":{"Line":0},"fn_name":null},{"line":157,"address":[225236,225279],"length":1,"stats":{"Line":0},"fn_name":null},{"line":158,"address":[225291,226057],"length":1,"stats":{"Line":0},"fn_name":null},{"line":161,"address":[284118,284080],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":163,"address":[226095,226178],"length":1,"stats":{"Line":0},"fn_name":null},{"line":167,"address":[225317],"length":1,"stats":{"Line":0},"fn_name":null},{"line":168,"address":[225387,225329],"length":1,"stats":{"Line":0},"fn_name":null},{"line":172,"address":[284256,284297],"length":1,"stats":{"Line":0},"fn_name":"{closure#1}"},{"line":174,"address":[225442,225528],"length":1,"stats":{"Line":0},"fn_name":null},{"line":178,"address":[225355],"length":1,"stats":{"Line":0},"fn_name":null},{"line":182,"address":[226688],"length":1,"stats":{"Line":0},"fn_name":"fields_to_names"},{"line":183,"address":[226748],"length":1,"stats":{"Line":0},"fn_name":null},{"line":184,"address":[226755,226905,226718],"length":1,"stats":{"Line":0},"fn_name":null},{"line":187,"address":[284726,284688],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":189,"address":[226790,226853],"length":1,"stats":{"Line":0},"fn_name":null},{"line":193,"address":[284905,284864],"length":1,"stats":{"Line":0},"fn_name":"{closure#1}"},{"line":195,"address":[226825],"length":1,"stats":{"Line":0},"fn_name":null},{"line":199,"address":[226944],"length":1,"stats":{"Line":0},"fn_name":"field_names_to_encodable"},{"line":200,"address":[226994],"length":1,"stats":{"Line":0},"fn_name":null},{"line":202,"address":[285392,285873],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":203,"address":[285421],"length":1,"stats":{"Line":0},"fn_name":null},{"line":210,"address":[227072],"length":1,"stats":{"Line":0},"fn_name":"fields_to_constructable_names"},{"line":211,"address":[227132],"length":1,"stats":{"Line":0},"fn_name":null},{"line":212,"address":[227289,227102,227139],"length":1,"stats":{"Line":0},"fn_name":null},{"line":215,"address":[285926,285888],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":217,"address":[227237,227174],"length":1,"stats":{"Line":0},"fn_name":null},{"line":221,"address":[286064,286104],"length":1,"stats":{"Line":0},"fn_name":"{closure#1}"},{"line":223,"address":[227209],"length":1,"stats":{"Line":0},"fn_name":null},{"line":227,"address":[227328],"length":1,"stats":{"Line":0},"fn_name":"field_names_to_decodable"},{"line":228,"address":[227384,227419],"length":1,"stats":{"Line":0},"fn_name":null},{"line":230,"address":[227409],"length":1,"stats":{"Line":0},"fn_name":null},{"line":231,"address":[287285,286704,286190],"length":1,"stats":{"Line":0},"fn_name":null},{"line":232,"address":[286217],"length":1,"stats":{"Line":0},"fn_name":null},{"line":236,"address":[286198,286747],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":119},{"path":["/","home","trangar","development","rust","bincode","derive","src","derive_struct.rs"],"content":"use crate::Result;\nuse proc_macro::TokenStream;\nuse proc_macro2::{Span, TokenStream as TokenStream2};\nuse quote::{quote, ToTokens};\nuse syn::{GenericParam, Generics, Ident, Index, Lifetime, LifetimeDef};\n\npub struct DeriveStruct {\n    name: Ident,\n    generics: Generics,\n    fields: Vec\u003cTokenStream2\u003e,\n}\n\nimpl DeriveStruct {\n    pub fn parse(name: Ident, generics: Generics, str: syn::DataStruct) -\u003e Result\u003cSelf\u003e {\n        let fields = match str.fields {\n            syn::Fields::Named(fields) =\u003e fields\n                .named\n                .iter()\n                .map(|f| f.ident.clone().unwrap().to_token_stream())\n                .collect(),\n            syn::Fields::Unnamed(fields) =\u003e fields\n                .unnamed\n                .iter()\n                .enumerate()\n                .map(|(i, _)| Index::from(i).to_token_stream())\n                .collect(),\n            syn::Fields::Unit =\u003e Vec::new(),\n        };\n\n        Ok(Self {\n            name,\n            generics,\n            fields,\n        })\n    }\n\n    pub fn generate_encodable(self) -\u003e Result\u003cTokenStream\u003e {\n        let DeriveStruct {\n            name,\n            generics,\n            fields,\n        } = self;\n\n        let (impl_generics, ty_generics, where_clause) = generics.split_for_impl();\n\n        let fields = fields\n            .into_iter()\n            .map(|field| {\n                quote! {\n                    bincode::enc::Encodeable::encode(\u0026self. #field, \u0026mut encoder)?;\n                }\n            })\n            .collect::\u003cVec\u003c_\u003e\u003e();\n\n        let result = quote! {\n            impl #impl_generics bincode::enc::Encodeable for #name #ty_generics #where_clause {\n                fn encode\u003cE: bincode::enc::Encode\u003e(\u0026self, mut encoder: E) -\u003e Result\u003c(), bincode::error::EncodeError\u003e {\n                    #(#fields)*\n                    Ok(())\n                }\n\n            }\n        };\n        Ok(result.into())\n    }\n\n    pub fn generate_decodable(self) -\u003e Result\u003cTokenStream\u003e {\n        let DeriveStruct {\n            name,\n            generics,\n            fields,\n        } = self;\n\n        let (mut impl_generics, ty_generics, where_clause) = generics.split_for_impl();\n\n        // check if the type has lifetimes\n        let mut should_insert_lifetime = false;\n\n        for param in \u0026generics.params {\n            if let GenericParam::Lifetime(_) = param {\n                should_insert_lifetime = true;\n                break;\n            }\n        }\n\n        // if the type has lifetimes, insert '__de and bound it to the lifetimes\n        let mut generics_with_decode_lifetime;\n        if should_insert_lifetime {\n            generics_with_decode_lifetime = generics.clone();\n            let mut new_lifetime = LifetimeDef::new(Lifetime::new(\"'__de\", Span::call_site()));\n\n            for param in \u0026generics.params {\n                if let GenericParam::Lifetime(lt) = param {\n                    new_lifetime.bounds.push(lt.lifetime.clone())\n                }\n            }\n            generics_with_decode_lifetime\n                .params\n                .push(GenericParam::Lifetime(new_lifetime));\n\n            impl_generics = generics_with_decode_lifetime.split_for_impl().0;\n        }\n\n        let fields = fields\n            .into_iter()\n            .map(|field| {\n                if should_insert_lifetime {\n                    quote! {\n                        #field: bincode::de::BorrowDecodable::borrow_decode(\u0026mut decoder)?,\n                    }\n                } else {\n                    quote! {\n                        #field: bincode::de::Decodable::decode(\u0026mut decoder)?,\n                    }\n                }\n            })\n            .collect::\u003cVec\u003c_\u003e\u003e();\n\n        let result = if should_insert_lifetime {\n            quote! {\n                impl #impl_generics bincode::de::BorrowDecodable\u003c'__de\u003e for #name #ty_generics #where_clause {\n                    fn borrow_decode\u003cD: bincode::de::BorrowDecode\u003c'__de\u003e\u003e(mut decoder: D) -\u003e Result\u003cSelf, bincode::error::DecodeError\u003e {\n                        Ok(#name {\n                            #(#fields)*\n                        })\n                    }\n\n                }\n            }\n        } else {\n            quote! {\n                impl #impl_generics bincode::de::Decodable for #name #ty_generics #where_clause {\n                    fn decode\u003cD: bincode::de::Decode\u003e(mut decoder: D) -\u003e Result\u003cSelf, bincode::error::DecodeError\u003e {\n                        Ok(#name {\n                            #(#fields)*\n                        })\n                    }\n\n                }\n            }\n        };\n\n        Ok(result.into())\n    }\n}\n","traces":[{"line":14,"address":[171146,170304],"length":1,"stats":{"Line":0},"fn_name":"parse"},{"line":15,"address":[170336,170401],"length":1,"stats":{"Line":0},"fn_name":null},{"line":16,"address":[171013,170368,170408,171092],"length":1,"stats":{"Line":0},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":19,"address":[334150,334112],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":21,"address":[170954,170890,170487],"length":1,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":25,"address":[334328,334288],"length":1,"stats":{"Line":0},"fn_name":"{closure#1}"},{"line":27,"address":[170566],"length":1,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[170717],"length":1,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[170621],"length":1,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[170652],"length":1,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[170678],"length":1,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[171184,173868],"length":1,"stats":{"Line":0},"fn_name":"generate_encodable"},{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[171196],"length":1,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[171230],"length":1,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[171299],"length":1,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[171337],"length":1,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[171409,171529],"length":1,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[334384,334977],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":49,"address":[334494,334416],"length":1,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[171559,171649],"length":1,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[173640],"length":1,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[173904,180134],"length":1,"stats":{"Line":0},"fn_name":"generate_decodable"},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[173919],"length":1,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[173978],"length":1,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[174050],"length":1,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[174088],"length":1,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[174163],"length":1,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[174383,174431,174379,174179,174259],"length":1,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[174415],"length":1,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[174421],"length":1,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[175429,174455],"length":1,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[174470],"length":1,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[174601,174663],"length":1,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[174858,175084,174959,174983,174766],"length":1,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[175020,175082],"length":1,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[175102,175046],"length":1,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[175371],"length":1,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[175111],"length":1,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[175378],"length":1,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[175529,175450],"length":1,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[175521],"length":1,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[335038,336173],"length":1,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[335068,335143],"length":1,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[335620,335046],"length":1,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[175583,179894],"length":1,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[175615,175705],"length":1,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[175593,177878],"length":1,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":143,"address":[179903,177806],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":72},{"path":["/","home","trangar","development","rust","bincode","derive","src","error.rs"],"content":"use proc_macro2::*;\nuse std::fmt;\n\n#[derive(Debug)]\npub enum Error {\n    UnknownVisibility(Span),\n    UnknownDataType(Span),\n    InvalidRustSyntax(Span),\n    ExpectedIdent(Span),\n    UnionNotSupported,\n}\n\nimpl PartialEq for Error {\n    fn eq(\u0026self, other: \u0026Error) -\u003e bool {\n        match (self, other) {\n            (Error::UnknownVisibility(_), Error::UnknownVisibility(_)) =\u003e true,\n            (Error::UnknownDataType(_), Error::UnknownDataType(_)) =\u003e true,\n            (Error::UnionNotSupported, Error::UnionNotSupported) =\u003e true,\n            (Error::InvalidRustSyntax(_), Error::InvalidRustSyntax(_)) =\u003e true,\n            (Error::ExpectedIdent(_), Error::ExpectedIdent(_)) =\u003e true,\n            _ =\u003e false,\n        }\n    }\n}\n\n// helper functions for the unit tests\n#[cfg(test)]\nimpl Error {\n    pub fn is_unknown_visibility(\u0026self) -\u003e bool {\n        matches!(self, Error::UnknownVisibility(_))\n    }\n\n    pub fn is_unknown_data_type(\u0026self) -\u003e bool {\n        matches!(self, Error::UnknownDataType(_))\n    }\n\n    pub fn is_invalid_rust_syntax(\u0026self) -\u003e bool {\n        matches!(self, Error::InvalidRustSyntax(_))\n    }\n\n    pub fn is_expected_ident(\u0026self) -\u003e bool {\n        matches!(self, Error::ExpectedIdent(_))\n    }\n}\n\nimpl fmt::Display for Error {\n    fn fmt(\u0026self, fmt: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        match self {\n            Self::UnknownVisibility(_) =\u003e write!(fmt, \"Unknown visibility\"),\n            Self::UnknownDataType(_) =\u003e {\n                write!(fmt, \"Unknown data type, only enum and struct are supported\")\n            }\n            Self::UnionNotSupported =\u003e write!(fmt, \"Unions are not supported\"),\n            Self::InvalidRustSyntax(_) =\u003e write!(fmt, \"Invalid rust syntax\"),\n            Self::ExpectedIdent(_) =\u003e write!(fmt, \"Expected ident\"),\n        }\n    }\n}\n\nimpl Error {\n    pub fn into_token_stream(self) -\u003e TokenStream {\n        let maybe_span = match \u0026self {\n            Error::UnknownVisibility(span)\n            | Error::UnknownDataType(span)\n            | Error::ExpectedIdent(span)\n            | Error::InvalidRustSyntax(span) =\u003e Some(span.clone()),\n\n            Error::UnionNotSupported =\u003e None,\n        };\n        self.throw_with_span(maybe_span.unwrap_or_else(Span::call_site))\n    }\n\n    pub fn throw_with_span(self, span: Span) -\u003e TokenStream {\n        // compile_error!($message)\n        vec![\n            TokenTree::Ident(Ident::new(\"compile_error\", span)),\n            TokenTree::Punct({\n                let mut punct = Punct::new('!', Spacing::Alone);\n                punct.set_span(span);\n                punct\n            }),\n            TokenTree::Group({\n                let mut group = Group::new(Delimiter::Brace, {\n                    TokenTree::Literal({\n                        let mut string = Literal::string(\u0026self.to_string());\n                        string.set_span(span);\n                        string\n                    })\n                    .into()\n                });\n                group.set_span(span);\n                group\n            }),\n        ]\n        .into_iter()\n        .collect()\n    }\n}\n","traces":[{"line":14,"address":[185888],"length":1,"stats":{"Line":0},"fn_name":"eq"},{"line":15,"address":[186074,185954,185902,186067,186060,186053],"length":1,"stats":{"Line":0},"fn_name":null},{"line":16,"address":[185912,185956,186069],"length":1,"stats":{"Line":0},"fn_name":null},{"line":17,"address":[185971,186062],"length":1,"stats":{"Line":0},"fn_name":null},{"line":18,"address":[186016],"length":1,"stats":{"Line":0},"fn_name":null},{"line":19,"address":[186055,185986],"length":1,"stats":{"Line":0},"fn_name":null},{"line":20,"address":[186001,186048],"length":1,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[185949],"length":1,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[186080],"length":1,"stats":{"Line":1},"fn_name":"is_unknown_visibility"},{"line":30,"address":[186089],"length":1,"stats":{"Line":1},"fn_name":null},{"line":33,"address":[186128],"length":1,"stats":{"Line":1},"fn_name":"is_unknown_data_type"},{"line":34,"address":[186137],"length":1,"stats":{"Line":1},"fn_name":null},{"line":37,"address":[186176],"length":1,"stats":{"Line":1},"fn_name":"is_invalid_rust_syntax"},{"line":38,"address":[186185],"length":1,"stats":{"Line":1},"fn_name":null},{"line":41,"address":[186224],"length":1,"stats":{"Line":0},"fn_name":"is_expected_ident"},{"line":42,"address":[186233],"length":1,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[186272],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":48,"address":[186327],"length":1,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[186329,186299,186639],"length":1,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[186616,186368],"length":1,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[186488],"length":1,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[186590,186407],"length":1,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[186449,186564],"length":1,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[186672],"length":1,"stats":{"Line":0},"fn_name":"into_token_stream"},{"line":62,"address":[186888,186763,186747,186731,186779,186795],"length":1,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[186733,186701],"length":1,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[186797],"length":1,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[186805,186895],"length":1,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[186928,188034],"length":1,"stats":{"Line":0},"fn_name":"throw_with_span"},{"line":75,"address":[187282,187157,187898,187452,188049,186982],"length":1,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[186995],"length":1,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[187353],"length":1,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[187104,187200],"length":1,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[187245],"length":1,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[187323],"length":1,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[187852],"length":1,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[187394,187754],"length":1,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[187688],"length":1,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[187415,187502],"length":1,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[187578],"length":1,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[187656],"length":1,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[187789],"length":1,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[187826],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":6,"coverable":48},{"path":["/","home","trangar","development","rust","bincode","derive","src","lib.rs"],"content":"extern crate proc_macro;\n\nmod derive_enum;\nmod derive_struct;\nmod error;\nmod parse;\n\nuse error::Error;\nuse proc_macro2::TokenStream;\n\ntype Result\u003cT = ()\u003e = std::result::Result\u003cT, Error\u003e;\n\n#[proc_macro_derive(Encodable)]\npub fn derive_encodable(input: proc_macro::TokenStream) -\u003e proc_macro::TokenStream {\n    derive_encodable_inner(input.into())\n        .unwrap_or_else(|e| e.into_token_stream())\n        .into()\n}\n\nfn derive_encodable_inner(input: TokenStream) -\u003e Result\u003cTokenStream\u003e {\n    let mut source = input.into_iter().peekable();\n    let source = \u0026mut source;\n    let _visibility = parse::Visibility::try_take(source)?;\n    let _datatype = parse::DataType::take(source)?;\n    let _generics = parse::Generics::try_take(source)?;\n\n    dbg!(_visibility);\n    dbg!(_datatype);\n    dbg!(_generics);\n\n    unimplemented!();\n}\n\n/*\n#[proc_macro_derive(Decodable)]\npub fn derive_decodable(input: TokenStream) -\u003e TokenStream {\n    let input = parse_macro_input!(input as DeriveInput);\n    derive_decodable_inner(input).unwrap_or_else(|e| e.into_token_stream())\n}\n\nfn derive_decodable_inner(input: DeriveInput) -\u003e Result\u003cTokenStream\u003e {\n    match input.data {\n        syn::Data::Struct(struct_definition) =\u003e {\n            DeriveStruct::parse(input.ident, input.generics, struct_definition)\n                .and_then(|str| str.generate_decodable())\n        }\n        syn::Data::Enum(enum_definition) =\u003e {\n            DeriveEnum::parse(input.ident, input.generics, enum_definition)\n                .and_then(|str| str.generate_decodable())\n        }\n        syn::Data::Union(_) =\u003e Err(Error::UnionNotSupported),\n    }\n}\n*/\n\n#[cfg(test)]\npub(crate) fn token_stream(\n    s: \u0026str,\n) -\u003e std::iter::Peekable\u003cimpl Iterator\u003cItem = proc_macro2::TokenTree\u003e\u003e {\n    use std::str::FromStr;\n\n    let stream = proc_macro2::TokenStream::from_str(s)\n        .unwrap_or_else(|e| panic!(\"Could not parse code: {:?}\\n{:?}\", s, e));\n    stream.into_iter().peekable()\n}\n","traces":[{"line":14,"address":[267168],"length":1,"stats":{"Line":0},"fn_name":"derive_encodable"},{"line":15,"address":[267186],"length":1,"stats":{"Line":0},"fn_name":null},{"line":16,"address":[166170,166144],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":20,"address":[270664,267296],"length":1,"stats":{"Line":0},"fn_name":"derive_encodable_inner"},{"line":21,"address":[267319],"length":1,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[267405],"length":1,"stats":{"Line":0},"fn_name":null},{"line":23,"address":[267605,267727,267413],"length":1,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[267810,267712,268022,267973],"length":1,"stats":{"Line":0},"fn_name":null},{"line":25,"address":[268551,268478,267958,268078,268126],"length":1,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[268755,268258,268634],"length":1,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[269076],"length":1,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[269881],"length":1,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[270688],"length":1,"stats":{"Line":3},"fn_name":"token_stream"},{"line":62,"address":[270749,270715],"length":1,"stats":{"Line":6},"fn_name":null},{"line":63,"address":[166208,166231],"length":1,"stats":{"Line":5},"fn_name":"{closure#0}"},{"line":64,"address":[270772],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":4,"coverable":16},{"path":["/","home","trangar","development","rust","bincode","derive","src","parse.rs"],"content":"use crate::{Error, Result};\nuse proc_macro2::{Ident, Span, TokenTree};\nuse std::iter::Peekable;\n\n#[derive(Debug, PartialEq, Copy, Clone)]\npub enum Visibility {\n    Pub,\n    PubCrate,\n}\n\nimpl Visibility {\n    pub fn try_take(input: \u0026mut Peekable\u003cimpl Iterator\u003cItem = TokenTree\u003e\u003e) -\u003e Result\u003cOption\u003cSelf\u003e\u003e {\n        if let Some(TokenTree::Ident(ident)) = input.peek() {\n            if ident.to_string() == \"pub\" {\n                // Consume this token\n                let ident = assume_ident(input.next());\n\n                // check if the next token is `pub(crate)`\n                if let Some(TokenTree::Group(_)) = input.peek() {\n                    let group = assume_group(input.next());\n                    let mut group_stream = group.stream().into_iter();\n                    return match (group_stream.next(), group_stream.next()) {\n                        (Some(TokenTree::Ident(ident)), None) =\u003e {\n                            if ident.to_string() == \"crate\" {\n                                return Ok(Some(Visibility::PubCrate));\n                            } else {\n                                Err(Error::UnknownVisibility(ident.span()))\n                            }\n                        }\n                        _ =\u003e Err(Error::UnknownVisibility(ident.span())),\n                    };\n                }\n\n                return Ok(Some(Visibility::Pub));\n            }\n        }\n        Ok(None)\n    }\n}\n\n#[test]\nfn test_visibility_try_take() {\n    use crate::token_stream;\n\n    assert_eq!(Ok(None), Visibility::try_take(\u0026mut token_stream(\"\")));\n    assert_eq!(\n        Ok(Some(Visibility::Pub)),\n        Visibility::try_take(\u0026mut token_stream(\"pub\"))\n    );\n    assert_eq!(\n        Ok(Some(Visibility::Pub)),\n        Visibility::try_take(\u0026mut token_stream(\" pub \"))\n    );\n    assert_eq!(\n        Ok(Some(Visibility::Pub)),\n        Visibility::try_take(\u0026mut token_stream(\"\\tpub\\t\"))\n    );\n    assert_eq!(\n        Ok(Some(Visibility::PubCrate)),\n        Visibility::try_take(\u0026mut token_stream(\"pub(crate)\"))\n    );\n    assert_eq!(\n        Ok(Some(Visibility::PubCrate)),\n        Visibility::try_take(\u0026mut token_stream(\" pub ( crate ) \"))\n    );\n    assert_eq!(\n        Ok(Some(Visibility::PubCrate)),\n        Visibility::try_take(\u0026mut token_stream(\"\\tpub\\t(\\tcrate\\t)\\t\"))\n    );\n\n    assert!(Visibility::try_take(\u0026mut token_stream(\"pub(foo)\"))\n        .unwrap_err()\n        .is_unknown_visibility());\n\n    assert!(Visibility::try_take(\u0026mut token_stream(\"pub(,)\"))\n        .unwrap_err()\n        .is_unknown_visibility());\n\n    assert_eq!(Ok(None), Visibility::try_take(\u0026mut token_stream(\"pb\")));\n}\n\n#[derive(Debug, Clone)]\npub enum DataType {\n    Enum(Ident),\n    Struct(Ident),\n}\n\nimpl DataType {\n    pub fn take(input: \u0026mut Peekable\u003cimpl Iterator\u003cItem = TokenTree\u003e\u003e) -\u003e Result\u003cSelf\u003e {\n        if let Some(TokenTree::Ident(ident)) = input.peek() {\n            let result = match ident.to_string().as_str() {\n                \"struct\" =\u003e DataType::Struct,\n                \"enum\" =\u003e DataType::Enum,\n                _ =\u003e return Err(Error::UnknownDataType(ident.span())),\n            };\n            let ident = assume_ident(input.next());\n            return match input.next() {\n                Some(TokenTree::Ident(ident)) =\u003e Ok((result)(ident)),\n                Some(t) =\u003e Err(Error::InvalidRustSyntax(t.span())),\n                None =\u003e Err(Error::InvalidRustSyntax(ident.span())),\n            };\n        }\n        let span = input\n            .peek()\n            .map(|t| t.span())\n            .unwrap_or_else(Span::call_site);\n        Err(Error::InvalidRustSyntax(span))\n    }\n\n    // pub fn ident(\u0026self) -\u003e String {\n    //     match self {\n    //         Self::Enum(ident) =\u003e ident,\n    //         Self::Struct(ident) =\u003e ident,\n    //     }\n    //     .to_string()\n    // }\n}\n\n#[cfg(test)]\nimpl DataType {\n    fn is_enum(\u0026self, ident: \u0026str) -\u003e bool {\n        if let Self::Enum(i) = self {\n            i.to_string() == ident\n        } else {\n            false\n        }\n    }\n    fn is_struct(\u0026self, ident: \u0026str) -\u003e bool {\n        if let Self::Struct(i) = self {\n            i.to_string() == ident\n        } else {\n            false\n        }\n    }\n}\n\n#[test]\nfn test_datatype_take() {\n    use crate::token_stream;\n\n    assert!(DataType::take(\u0026mut token_stream(\"enum\"))\n        .unwrap_err()\n        .is_invalid_rust_syntax());\n    assert!(DataType::take(\u0026mut token_stream(\"enum Foo\"))\n        .unwrap()\n        .is_enum(\"Foo\"));\n    assert!(DataType::take(\u0026mut token_stream(\"enum Foo { }\"))\n        .unwrap()\n        .is_enum(\"Foo\"));\n    assert!(DataType::take(\u0026mut token_stream(\"enum Foo { bar, baz }\"))\n        .unwrap()\n        .is_enum(\"Foo\"));\n    assert!(\n        DataType::take(\u0026mut token_stream(\"enum Foo\u003c'a, T\u003e { bar, baz }\"))\n            .unwrap()\n            .is_enum(\"Foo\")\n    );\n\n    assert!(DataType::take(\u0026mut token_stream(\"struct\"))\n        .unwrap_err()\n        .is_invalid_rust_syntax());\n    assert!(DataType::take(\u0026mut token_stream(\"struct Foo { }\"))\n        .unwrap()\n        .is_struct(\"Foo\"));\n    assert!(\n        DataType::take(\u0026mut token_stream(\"struct Foo { bar: u32, baz: u32 }\"))\n            .unwrap()\n            .is_struct(\"Foo\")\n    );\n    assert!(\n        DataType::take(\u0026mut token_stream(\"struct Foo\u003c'a, T\u003e { bar: \u0026'a T }\"))\n            .unwrap()\n            .is_struct(\"Foo\")\n    );\n\n    assert!(DataType::take(\u0026mut token_stream(\"fn foo() {}\"))\n        .unwrap_err()\n        .is_unknown_data_type());\n\n    assert!(DataType::take(\u0026mut token_stream(\"() {}\"))\n        .unwrap_err()\n        .is_invalid_rust_syntax());\n\n    assert!(DataType::take(\u0026mut token_stream(\"\"))\n        .unwrap_err()\n        .is_invalid_rust_syntax());\n}\n\n#[derive(Debug)]\npub struct Generics {\n    lifetimes: Vec\u003cLifetime\u003e,\n    generics: Vec\u003cGeneric\u003e,\n}\nimpl Generics {\n    pub fn try_take(input: \u0026mut Peekable\u003cimpl Iterator\u003cItem = TokenTree\u003e\u003e) -\u003e Result\u003cOption\u003cSelf\u003e\u003e {\n        let maybe_punct = input.peek();\n        if let Some(TokenTree::Punct(punct)) = maybe_punct {\n            if punct.as_char() == '\u003c' {\n                let punct = assume_punct(input.next(), '\u003c');\n                let mut result = Generics {\n                    lifetimes: Vec::new(),\n                    generics: Vec::new(),\n                };\n                loop {\n                    match input.peek() {\n                        Some(TokenTree::Punct(punct)) if punct.as_char() == '\\'' =\u003e {\n                            result.lifetimes.push(Lifetime::take(input)?);\n                            consume_punct_if(input, \",\");\n                        }\n                        Some(TokenTree::Punct(punct)) if punct.as_char() == '\u003e' =\u003e {\n                            break;\n                        }\n                        Some(TokenTree::Ident(_)) =\u003e {\n                            result.generics.push(Generic::take(input)?);\n                            consume_punct_if(input, \",\");\n                        }\n                        x =\u003e {\n                            return Err(Error::InvalidRustSyntax(\n                                x.map(|x| x.span()).unwrap_or_else(|| punct.span()),\n                            ));\n                        }\n                    }\n                }\n                return Ok(Some(result));\n            }\n        }\n        Ok(None)\n    }\n}\n\n#[test]\nfn test_generics_try_take() {\n    use crate::token_stream;\n\n    assert!(Generics::try_take(\u0026mut token_stream(\"\")).unwrap().is_none());\n    assert!(Generics::try_take(\u0026mut token_stream(\"foo\"))\n        .unwrap()\n        .is_none());\n    assert!(Generics::try_take(\u0026mut token_stream(\"()\"))\n        .unwrap()\n        .is_none());\n\n    let mut stream = token_stream(\"struct Foo\u003c'a, T\u003e()\");\n    assert!(DataType::take(\u0026mut stream).unwrap().is_struct(\"Foo\"));\n    let generics = Generics::try_take(\u0026mut stream).unwrap().unwrap();\n    assert_eq!(generics.lifetimes.len(), 1);\n    assert_eq!(generics.generics.len(), 1);\n    assert!(generics.lifetimes[0].is_ident(\"a\"));\n    assert!(generics.generics[0].is_ident(\"T\"));\n\n    let mut stream = token_stream(\"struct Foo\u003cA, B\u003e()\");\n    assert!(DataType::take(\u0026mut stream).unwrap().is_struct(\"Foo\"));\n    let generics = Generics::try_take(\u0026mut stream).unwrap().unwrap();\n    assert_eq!(generics.lifetimes.len(), 0);\n    assert_eq!(generics.generics.len(), 2);\n    assert!(generics.generics[0].is_ident(\"A\"));\n    assert!(generics.generics[1].is_ident(\"B\"));\n\n    let mut stream = token_stream(\"struct Foo\u003c'a, T: Display\u003e()\");\n    assert!(DataType::take(\u0026mut stream).unwrap().is_struct(\"Foo\"));\n    let generics = Generics::try_take(\u0026mut stream).unwrap().unwrap();\n    dbg!(\u0026generics);\n    assert_eq!(generics.lifetimes.len(), 1);\n    assert_eq!(generics.generics.len(), 1);\n    assert!(generics.lifetimes[0].is_ident(\"a\"));\n    assert!(generics.generics[0].is_ident(\"T\"));\n\n    let mut stream = token_stream(\"struct Foo\u003c'a, T: for\u003c'a\u003e Bar\u003c'a\u003e + 'static\u003e()\");\n    assert!(DataType::take(\u0026mut stream).unwrap().is_struct(\"Foo\"));\n    let generics = Generics::try_take(\u0026mut stream).unwrap().unwrap();\n    dbg!(\u0026generics);\n    assert_eq!(generics.lifetimes.len(), 1);\n    assert_eq!(generics.generics.len(), 1);\n    assert!(generics.lifetimes[0].is_ident(\"a\"));\n    assert!(generics.generics[0].is_ident(\"T\"));\n\n    let mut stream =\n        token_stream(\"struct Baz\u003cT: for\u003c'a\u003e Bar\u003c'a, for\u003c'b\u003e Bar\u003c'b, for\u003c'c\u003e Bar\u003c'c, u32\u003e\u003e\u003e\u003e {}\");\n    assert!(DataType::take(\u0026mut stream).unwrap().is_struct(\"Baz\"));\n    let generics = Generics::try_take(\u0026mut stream).unwrap().unwrap();\n    dbg!(\u0026generics);\n    assert_eq!(generics.lifetimes.len(), 0);\n    assert_eq!(generics.generics.len(), 1);\n    assert!(generics.generics[0].is_ident(\"T\"));\n\n    let mut stream = token_stream(\"struct Baz\u003c()\u003e {}\");\n    assert!(DataType::take(\u0026mut stream).unwrap().is_struct(\"Baz\"));\n    assert!(Generics::try_take(\u0026mut stream)\n        .unwrap_err()\n        .is_invalid_rust_syntax());\n}\n\nfn assume_group(t: Option\u003cTokenTree\u003e) -\u003e proc_macro2::Group {\n    match t {\n        Some(TokenTree::Group(group)) =\u003e group,\n        _ =\u003e unreachable!(),\n    }\n}\nfn assume_ident(t: Option\u003cTokenTree\u003e) -\u003e proc_macro2::Ident {\n    match t {\n        Some(TokenTree::Ident(ident)) =\u003e ident,\n        _ =\u003e unreachable!(),\n    }\n}\nfn assume_punct(t: Option\u003cTokenTree\u003e, punct: char) -\u003e proc_macro2::Punct {\n    match t {\n        Some(TokenTree::Punct(p)) =\u003e {\n            debug_assert_eq!(punct, p.as_char());\n            p\n        }\n        _ =\u003e unreachable!(),\n    }\n}\n\nfn consume_punct_if(input: \u0026mut Peekable\u003cimpl Iterator\u003cItem = TokenTree\u003e\u003e, punct: \u0026str) {\n    if let Some(TokenTree::Punct(p)) = input.peek() {\n        if p.to_string() == punct {\n            input.next();\n        }\n    }\n}\n\n#[derive(Debug)]\nstruct Lifetime {\n    ident: Ident,\n}\n\nimpl Lifetime {\n    pub fn take(input: \u0026mut Peekable\u003cimpl Iterator\u003cItem = TokenTree\u003e\u003e) -\u003e Result\u003cSelf\u003e {\n        let start = assume_punct(input.next(), '\\'');\n        match input.peek() {\n            Some(TokenTree::Ident(_)) =\u003e {\n                let ident = assume_ident(input.next());\n                Ok(Lifetime { ident })\n            }\n            Some(t) =\u003e Err(Error::ExpectedIdent(t.span())),\n            None =\u003e Err(Error::ExpectedIdent(start.span())),\n        }\n    }\n\n    #[cfg(test)]\n    fn is_ident(\u0026self, s: \u0026str) -\u003e bool {\n        self.ident.to_string() == s\n    }\n}\n\n#[test]\nfn test_lifetime_take() {\n    use crate::token_stream;\n    use std::panic::catch_unwind;\n    assert!(Lifetime::take(\u0026mut token_stream(\"'a\"))\n        .unwrap()\n        .is_ident(\"a\"));\n    assert!(catch_unwind(|| Lifetime::take(\u0026mut token_stream(\"\"))).is_err());\n    assert!(catch_unwind(|| Lifetime::take(\u0026mut token_stream(\"'0\"))).is_err());\n    assert!(catch_unwind(|| Lifetime::take(\u0026mut token_stream(\"'(\"))).is_err());\n    assert!(catch_unwind(|| Lifetime::take(\u0026mut token_stream(\"')\"))).is_err());\n    assert!(catch_unwind(|| Lifetime::take(\u0026mut token_stream(\"'0'\"))).is_err());\n}\n\n#[derive(Debug)]\nstruct Generic {\n    ident: Ident,\n    constraints: Vec\u003cTokenTree\u003e,\n}\n\nimpl Generic {\n    pub fn take(input: \u0026mut Peekable\u003cimpl Iterator\u003cItem = TokenTree\u003e\u003e) -\u003e Result\u003cSelf\u003e {\n        let ident = assume_ident(input.next());\n        let mut constraints = Vec::new();\n        if let Some(TokenTree::Punct(punct)) = input.peek() {\n            if punct.as_char() == ':' {\n                assume_punct(input.next(), ':');\n                let mut open_brackets = Vec::\u003cchar\u003e::new();\n                loop {\n                    match input.peek() {\n                        Some(TokenTree::Punct(punct)) =\u003e {\n                            dbg!(punct);\n                            if ['\u003c', '(', '[', '{'].contains(\u0026punct.as_char()) {\n                                open_brackets.push(punct.as_char());\n                            } else if ['\u003e', ')', ']', '}'].contains(\u0026punct.as_char()) {\n                                let last_bracket = match open_brackets.pop() {\n                                    Some(bracket) =\u003e bracket,\n                                    None if punct.as_char() == '\u003e' =\u003e {\n                                        // we're done but we encountered the closing bracket of the entire generic\n                                        break;\n                                    }\n                                    None =\u003e {\n                                        return Err(Error::InvalidRustSyntax(punct.span()));\n                                    }\n                                };\n                                let expected = match last_bracket {\n                                    '\u003c' =\u003e '\u003e',\n                                    '{' =\u003e '}',\n                                    '(' =\u003e ')',\n                                    '[' =\u003e ']',\n                                    _ =\u003e unreachable!(),\n                                };\n                                assert_eq!(\n                                    expected,\n                                    punct.as_char(),\n                                    \"Unexpected closing bracket: found {}, expected {}\",\n                                    punct.as_char(),\n                                    expected\n                                );\n                            } else if punct.as_char() == ',' \u0026\u0026 open_brackets.is_empty() {\n                                break;\n                            }\n                            constraints.push(input.next().unwrap());\n                        }\n                        Some(_) =\u003e constraints.push(input.next().unwrap()),\n                        None =\u003e {\n                            return Err(Error::InvalidRustSyntax(\n                                constraints\n                                    .last()\n                                    .map(|c| c.span())\n                                    .unwrap_or_else(|| ident.span()),\n                            ))\n                        }\n                    }\n                }\n            }\n        }\n        Ok(Generic { ident, constraints })\n    }\n\n    #[cfg(test)]\n    fn is_ident(\u0026self, i: \u0026str) -\u003e bool {\n        self.ident.to_string() == i\n    }\n}\n","traces":[{"line":12,"address":[307714,307520],"length":1,"stats":{"Line":1},"fn_name":"try_take\u003cproc_macro2::token_stream::IntoIter\u003e"},{"line":13,"address":[307739,307540],"length":1,"stats":{"Line":2},"fn_name":null},{"line":14,"address":[307613,307641,307733],"length":1,"stats":{"Line":3},"fn_name":null},{"line":16,"address":[307746],"length":1,"stats":{"Line":1},"fn_name":null},{"line":19,"address":[307876,307782],"length":1,"stats":{"Line":2},"fn_name":null},{"line":20,"address":[307917,307956],"length":1,"stats":{"Line":2},"fn_name":null},{"line":21,"address":[307963],"length":1,"stats":{"Line":1},"fn_name":null},{"line":22,"address":[308150,308058,308506,308246],"length":1,"stats":{"Line":3},"fn_name":null},{"line":23,"address":[308287,308214,308339],"length":1,"stats":{"Line":3},"fn_name":null},{"line":24,"address":[308608,308408,308677],"length":1,"stats":{"Line":3},"fn_name":null},{"line":25,"address":[308769],"length":1,"stats":{"Line":1},"fn_name":null},{"line":27,"address":[308805,308744],"length":1,"stats":{"Line":2},"fn_name":null},{"line":30,"address":[308442,308317],"length":1,"stats":{"Line":2},"fn_name":null},{"line":34,"address":[307892],"length":1,"stats":{"Line":1},"fn_name":null},{"line":37,"address":[307626],"length":1,"stats":{"Line":1},"fn_name":null},{"line":42,"address":[289488,289839],"length":1,"stats":{"Line":3},"fn_name":"test_visibility_try_take"},{"line":45,"address":[289495],"length":1,"stats":{"Line":1},"fn_name":null},{"line":46,"address":[289977],"length":1,"stats":{"Line":1},"fn_name":null},{"line":48,"address":[289854],"length":1,"stats":{"Line":1},"fn_name":null},{"line":50,"address":[290326],"length":1,"stats":{"Line":1},"fn_name":null},{"line":52,"address":[290203],"length":1,"stats":{"Line":1},"fn_name":null},{"line":54,"address":[290675],"length":1,"stats":{"Line":1},"fn_name":null},{"line":56,"address":[290552],"length":1,"stats":{"Line":1},"fn_name":null},{"line":58,"address":[291024],"length":1,"stats":{"Line":1},"fn_name":null},{"line":60,"address":[290901],"length":1,"stats":{"Line":1},"fn_name":null},{"line":62,"address":[291373],"length":1,"stats":{"Line":1},"fn_name":null},{"line":64,"address":[291250],"length":1,"stats":{"Line":1},"fn_name":null},{"line":66,"address":[291722],"length":1,"stats":{"Line":1},"fn_name":null},{"line":68,"address":[291599],"length":1,"stats":{"Line":1},"fn_name":null},{"line":71,"address":[292236,291936],"length":1,"stats":{"Line":1},"fn_name":null},{"line":75,"address":[292274,292541,292209],"length":1,"stats":{"Line":2},"fn_name":null},{"line":79,"address":[292579,292514],"length":1,"stats":{"Line":2},"fn_name":null},{"line":89,"address":[310566,309184],"length":1,"stats":{"Line":1},"fn_name":"take\u003cproc_macro2::token_stream::IntoIter\u003e"},{"line":90,"address":[309222,309293],"length":1,"stats":{"Line":2},"fn_name":null},{"line":91,"address":[309480,309709,309315],"length":1,"stats":{"Line":3},"fn_name":null},{"line":92,"address":[309637,309596,309529],"length":1,"stats":{"Line":3},"fn_name":null},{"line":93,"address":[309697,309612,309666],"length":1,"stats":{"Line":3},"fn_name":null},{"line":94,"address":[310590,309677],"length":1,"stats":{"Line":2},"fn_name":null},{"line":96,"address":[309716],"length":1,"stats":{"Line":1},"fn_name":null},{"line":97,"address":[310430,309841,310355,309763],"length":1,"stats":{"Line":3},"fn_name":null},{"line":98,"address":[310322,309778,309871],"length":1,"stats":{"Line":3},"fn_name":null},{"line":99,"address":[310008],"length":1,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[309843,310366],"length":1,"stats":{"Line":2},"fn_name":null},{"line":103,"address":[309336,309281],"length":1,"stats":{"Line":2},"fn_name":null},{"line":105,"address":[310672,310681],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}\u003cproc_macro2::token_stream::IntoIter\u003e"},{"line":106,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[309405],"length":1,"stats":{"Line":1},"fn_name":null},{"line":121,"address":[287632,287783],"length":1,"stats":{"Line":1},"fn_name":"is_enum"},{"line":122,"address":[287656],"length":1,"stats":{"Line":1},"fn_name":null},{"line":123,"address":[287718,287676],"length":1,"stats":{"Line":2},"fn_name":null},{"line":125,"address":[287689],"length":1,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[287959,287808],"length":1,"stats":{"Line":1},"fn_name":"is_struct"},{"line":129,"address":[287832],"length":1,"stats":{"Line":1},"fn_name":null},{"line":130,"address":[287852,287894],"length":1,"stats":{"Line":2},"fn_name":null},{"line":132,"address":[287865],"length":1,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[293673,293488],"length":1,"stats":{"Line":3},"fn_name":"test_datatype_take"},{"line":141,"address":[293495,293725,293692],"length":1,"stats":{"Line":2},"fn_name":null},{"line":144,"address":[293994,293698,293771],"length":1,"stats":{"Line":2},"fn_name":null},{"line":147,"address":[294040,294263,293967],"length":1,"stats":{"Line":2},"fn_name":null},{"line":150,"address":[294236,294532,294309],"length":1,"stats":{"Line":2},"fn_name":null},{"line":153,"address":[294801,294615,294692],"length":1,"stats":{"Line":1},"fn_name":null},{"line":154,"address":[294578,294655,294505],"length":1,"stats":{"Line":3},"fn_name":null},{"line":159,"address":[295034,294847,294774],"length":1,"stats":{"Line":2},"fn_name":null},{"line":162,"address":[295303,295007,295080],"length":1,"stats":{"Line":2},"fn_name":null},{"line":165,"address":[295463,295572,295386],"length":1,"stats":{"Line":1},"fn_name":null},{"line":166,"address":[295349,295276,295426],"length":1,"stats":{"Line":3},"fn_name":null},{"line":170,"address":[295732,295841,295655],"length":1,"stats":{"Line":1},"fn_name":null},{"line":171,"address":[295695,295545,295618],"length":1,"stats":{"Line":3},"fn_name":null},{"line":176,"address":[295887,295814,296074],"length":1,"stats":{"Line":2},"fn_name":null},{"line":180,"address":[296047,296306,296120],"length":1,"stats":{"Line":2},"fn_name":null},{"line":184,"address":[296352,296280,296520],"length":1,"stats":{"Line":2},"fn_name":null},{"line":195,"address":[310720,311169],"length":1,"stats":{"Line":1},"fn_name":"try_take\u003cproc_macro2::token_stream::IntoIter\u003e"},{"line":196,"address":[310758],"length":1,"stats":{"Line":1},"fn_name":null},{"line":197,"address":[310776,310924],"length":1,"stats":{"Line":1},"fn_name":null},{"line":198,"address":[310831,310899],"length":1,"stats":{"Line":2},"fn_name":null},{"line":199,"address":[310909,310952],"length":1,"stats":{"Line":2},"fn_name":null},{"line":201,"address":[310998],"length":1,"stats":{"Line":1},"fn_name":null},{"line":202,"address":[311019],"length":1,"stats":{"Line":1},"fn_name":null},{"line":204,"address":[311130],"length":1,"stats":{"Line":1},"fn_name":null},{"line":205,"address":[312092,312425,311189],"length":1,"stats":{"Line":3},"fn_name":null},{"line":206,"address":[311282,311217,311435],"length":1,"stats":{"Line":3},"fn_name":null},{"line":207,"address":[312041,311843,311531],"length":1,"stats":{"Line":2},"fn_name":null},{"line":208,"address":[312073],"length":1,"stats":{"Line":1},"fn_name":null},{"line":210,"address":[311541],"length":1,"stats":{"Line":1},"fn_name":null},{"line":211,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":214,"address":[312346,312113,311404],"length":1,"stats":{"Line":2},"fn_name":null},{"line":215,"address":[312406],"length":1,"stats":{"Line":1},"fn_name":null},{"line":217,"address":[311318],"length":1,"stats":{"Line":0},"fn_name":null},{"line":218,"address":[311725,311342],"length":1,"stats":{"Line":0},"fn_name":null},{"line":222,"address":[311615],"length":1,"stats":{"Line":1},"fn_name":null},{"line":225,"address":[310848],"length":1,"stats":{"Line":1},"fn_name":null},{"line":230,"address":[297038,296800],"length":1,"stats":{"Line":3},"fn_name":"test_generics_try_take"},{"line":233,"address":[297060,297093,296813],"length":1,"stats":{"Line":2},"fn_name":null},{"line":234,"address":[297139,297362,297066],"length":1,"stats":{"Line":2},"fn_name":null},{"line":237,"address":[297335,297408,297631],"length":1,"stats":{"Line":2},"fn_name":null},{"line":241,"address":[297604],"length":1,"stats":{"Line":1},"fn_name":null},{"line":242,"address":[297754,297677,297895],"length":1,"stats":{"Line":2},"fn_name":null},{"line":243,"address":[297927,297888],"length":1,"stats":{"Line":2},"fn_name":null},{"line":244,"address":[297995,298205],"length":1,"stats":{"Line":1},"fn_name":null},{"line":245,"address":[298418,298265,298163],"length":1,"stats":{"Line":2},"fn_name":null},{"line":246,"address":[298556,298365,298478],"length":1,"stats":{"Line":2},"fn_name":null},{"line":247,"address":[298665,298519,298597],"length":1,"stats":{"Line":2},"fn_name":null},{"line":249,"address":[298638],"length":1,"stats":{"Line":1},"fn_name":null},{"line":250,"address":[298932,298791,298714],"length":1,"stats":{"Line":2},"fn_name":null},{"line":251,"address":[298925,298965],"length":1,"stats":{"Line":2},"fn_name":null},{"line":252,"address":[299243,299033],"length":1,"stats":{"Line":1},"fn_name":null},{"line":253,"address":[299303,299456,299201],"length":1,"stats":{"Line":2},"fn_name":null},{"line":254,"address":[299595,299516,299403],"length":1,"stats":{"Line":2},"fn_name":null},{"line":255,"address":[299636,299704,299557],"length":1,"stats":{"Line":2},"fn_name":null},{"line":257,"address":[299677],"length":1,"stats":{"Line":1},"fn_name":null},{"line":258,"address":[299753,299971,299830],"length":1,"stats":{"Line":2},"fn_name":null},{"line":259,"address":[300004,299964],"length":1,"stats":{"Line":2},"fn_name":null},{"line":260,"address":[300072,300445],"length":1,"stats":{"Line":2},"fn_name":null},{"line":261,"address":[300774,300942],"length":1,"stats":{"Line":1},"fn_name":null},{"line":262,"address":[301155,301002,300900],"length":1,"stats":{"Line":2},"fn_name":null},{"line":263,"address":[301102,301215,301293],"length":1,"stats":{"Line":2},"fn_name":null},{"line":264,"address":[301256,301402,301334],"length":1,"stats":{"Line":2},"fn_name":null},{"line":266,"address":[301375],"length":1,"stats":{"Line":1},"fn_name":null},{"line":267,"address":[301528,301451,301669],"length":1,"stats":{"Line":2},"fn_name":null},{"line":268,"address":[301702,301662],"length":1,"stats":{"Line":2},"fn_name":null},{"line":269,"address":[301770,302143],"length":1,"stats":{"Line":2},"fn_name":null},{"line":270,"address":[302640,302472],"length":1,"stats":{"Line":1},"fn_name":null},{"line":271,"address":[302598,302853,302700],"length":1,"stats":{"Line":2},"fn_name":null},{"line":272,"address":[302800,302991,302913],"length":1,"stats":{"Line":2},"fn_name":null},{"line":273,"address":[302954,303100,303032],"length":1,"stats":{"Line":2},"fn_name":null},{"line":277,"address":[303226,303367,303149],"length":1,"stats":{"Line":2},"fn_name":null},{"line":278,"address":[303360,303400],"length":1,"stats":{"Line":2},"fn_name":null},{"line":279,"address":[303468,303835],"length":1,"stats":{"Line":2},"fn_name":null},{"line":280,"address":[304281,304134],"length":1,"stats":{"Line":1},"fn_name":null},{"line":281,"address":[304476,304338,304248],"length":1,"stats":{"Line":2},"fn_name":null},{"line":282,"address":[304432,304583,304533],"length":1,"stats":{"Line":2},"fn_name":null},{"line":285,"address":[288178,287984],"length":1,"stats":{"Line":1},"fn_name":"assume_group"},{"line":287,"address":[288003,288076],"length":1,"stats":{"Line":2},"fn_name":null},{"line":291,"address":[288434,288240],"length":1,"stats":{"Line":1},"fn_name":"assume_ident"},{"line":293,"address":[288259,288332],"length":1,"stats":{"Line":2},"fn_name":null},{"line":297,"address":[288496,288874],"length":1,"stats":{"Line":2},"fn_name":"assume_punct"},{"line":299,"address":[288585,288512],"length":1,"stats":{"Line":2},"fn_name":null},{"line":300,"address":[288690,288823,288601],"length":1,"stats":{"Line":2},"fn_name":null},{"line":301,"address":[288768],"length":1,"stats":{"Line":1},"fn_name":null},{"line":307,"address":[312615,312432],"length":1,"stats":{"Line":1},"fn_name":"consume_punct_if\u003cproc_macro2::token_stream::IntoIter\u003e"},{"line":308,"address":[312459],"length":1,"stats":{"Line":1},"fn_name":null},{"line":309,"address":[312668,312634,312554,312524],"length":1,"stats":{"Line":4},"fn_name":null},{"line":310,"address":[312647],"length":1,"stats":{"Line":1},"fn_name":null},{"line":321,"address":[312688],"length":1,"stats":{"Line":1},"fn_name":"take\u003cproc_macro2::token_stream::IntoIter\u003e"},{"line":322,"address":[312718],"length":1,"stats":{"Line":1},"fn_name":null},{"line":323,"address":[313147,313097,312789,312819],"length":1,"stats":{"Line":2},"fn_name":null},{"line":324,"address":[312799,312858],"length":1,"stats":{"Line":2},"fn_name":null},{"line":325,"address":[312992,312876],"length":1,"stats":{"Line":2},"fn_name":null},{"line":326,"address":[313010],"length":1,"stats":{"Line":1},"fn_name":null},{"line":328,"address":[312891],"length":1,"stats":{"Line":0},"fn_name":null},{"line":329,"address":[313104,312821],"length":1,"stats":{"Line":0},"fn_name":null},{"line":334,"address":[289061,288960],"length":1,"stats":{"Line":1},"fn_name":"is_ident"},{"line":335,"address":[288985],"length":1,"stats":{"Line":1},"fn_name":null},{"line":340,"address":[304944,305147],"length":1,"stats":{"Line":3},"fn_name":"test_lifetime_take"},{"line":343,"address":[305166,304951,305187],"length":1,"stats":{"Line":2},"fn_name":null},{"line":346,"address":[305172,305328,305225],"length":1,"stats":{"Line":4},"fn_name":null},{"line":347,"address":[305313,305469,305366],"length":1,"stats":{"Line":4},"fn_name":null},{"line":348,"address":[305454,305507,305610],"length":1,"stats":{"Line":4},"fn_name":null},{"line":349,"address":[305595,305648,305751],"length":1,"stats":{"Line":4},"fn_name":null},{"line":350,"address":[305736,305885,305789],"length":1,"stats":{"Line":4},"fn_name":null},{"line":360,"address":[316342,313152],"length":1,"stats":{"Line":1},"fn_name":"take\u003cproc_macro2::token_stream::IntoIter\u003e"},{"line":361,"address":[313191],"length":1,"stats":{"Line":1},"fn_name":null},{"line":362,"address":[313225],"length":1,"stats":{"Line":1},"fn_name":null},{"line":363,"address":[313319,313252,313393],"length":1,"stats":{"Line":3},"fn_name":null},{"line":364,"address":[313658,313686,313431],"length":1,"stats":{"Line":3},"fn_name":null},{"line":365,"address":[313704,313679],"length":1,"stats":{"Line":2},"fn_name":null},{"line":366,"address":[313802],"length":1,"stats":{"Line":1},"fn_name":null},{"line":367,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":368,"address":[316093,313819,313916],"length":1,"stats":{"Line":2},"fn_name":null},{"line":369,"address":[313962,313853],"length":1,"stats":{"Line":2},"fn_name":null},{"line":370,"address":[314352,314010],"length":1,"stats":{"Line":2},"fn_name":null},{"line":371,"address":[314922,314761],"length":1,"stats":{"Line":2},"fn_name":null},{"line":372,"address":[314880],"length":1,"stats":{"Line":1},"fn_name":null},{"line":373,"address":[315411,316009,314852,314957],"length":1,"stats":{"Line":4},"fn_name":null},{"line":374,"address":[315106,315052],"length":1,"stats":{"Line":1},"fn_name":null},{"line":375,"address":[315082,315139],"length":1,"stats":{"Line":2},"fn_name":null},{"line":376,"address":[315116,315797],"length":1,"stats":{"Line":2},"fn_name":null},{"line":378,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":380,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":381,"address":[315812],"length":1,"stats":{"Line":0},"fn_name":null},{"line":384,"address":[315284,315271,315245,315258],"length":1,"stats":{"Line":1},"fn_name":null},{"line":385,"address":[315164,315234],"length":1,"stats":{"Line":2},"fn_name":null},{"line":386,"address":[315247],"length":1,"stats":{"Line":0},"fn_name":null},{"line":387,"address":[315260],"length":1,"stats":{"Line":0},"fn_name":null},{"line":388,"address":[315273],"length":1,"stats":{"Line":0},"fn_name":null},{"line":391,"address":[315468,315424,315324],"length":1,"stats":{"Line":1},"fn_name":null},{"line":392,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":393,"address":[315296],"length":1,"stats":{"Line":1},"fn_name":null},{"line":395,"address":[315432],"length":1,"stats":{"Line":0},"fn_name":null},{"line":396,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":398,"address":[315021,315948],"length":1,"stats":{"Line":2},"fn_name":null},{"line":399,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":401,"address":[316032,314940],"length":1,"stats":{"Line":2},"fn_name":null},{"line":403,"address":[314239],"length":1,"stats":{"Line":1},"fn_name":null},{"line":404,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":405,"address":[316256],"length":1,"stats":{"Line":0},"fn_name":null},{"line":406,"address":[313918,316194,316114],"length":1,"stats":{"Line":0},"fn_name":null},{"line":407,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":408,"address":[316368,316377],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}\u003cproc_macro2::token_stream::IntoIter\u003e"},{"line":409,"address":[316186,316425,316416],"length":1,"stats":{"Line":0},"fn_name":"{closure#1}\u003cproc_macro2::token_stream::IntoIter\u003e"},{"line":416,"address":[313454],"length":1,"stats":{"Line":1},"fn_name":null},{"line":420,"address":[289088,289189],"length":1,"stats":{"Line":1},"fn_name":"is_ident"},{"line":421,"address":[289113],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":177,"coverable":204},{"path":["/","home","trangar","development","rust","bincode","rust-proc-macro-without-dependencies","default_derive","src","lib.rs"],"content":"extern crate proc_macro;\nuse proc_macro::{Delimiter, Group, Ident, Punct, TokenStream, TokenTree};\n\nuse std::iter::Peekable;\n\n#[derive(Debug)]\nenum VisibilityModifier {\n    Pub,\n    PubCrate,\n}\n\n#[derive(Debug)]\nenum DataType {\n    Enum,\n    Struct(Struct),\n}\n\n#[derive(Debug)]\nstruct Struct {\n    pub name: Ident,\n    pub fields: Vec\u003cField\u003e,\n}\n\n#[derive(Debug)]\nstruct Field {\n    pub visibility: Option\u003cVisibilityModifier\u003e,\n    pub name: Ident,\n    pub typ: Ident,\n}\n\n/// Parses a visibility modifier such as `pub`. This function will panic if it encounters\n/// a visibility modifier with an additional group specifier like `pub(crate)`\nfn next_visibility_modifier(\n    input: \u0026mut Peekable\u003cimpl Iterator\u003cItem = TokenTree\u003e\u003e,\n) -\u003e Option\u003cVisibilityModifier\u003e {\n    if let Some(TokenTree::Ident(ident)) = input.peek() {\n        if ident.to_string() == \"pub\" {\n            // Consume this token\n            input.next();\n\n            // TODO: We do not handle any modifiers besides `pub`\n            if let Some(TokenTree::Group(_)) = input.peek() {\n                panic!(\"Visibility modifies like pub(crate) are not yet handled\");\n            }\n\n            return Some(VisibilityModifier::Pub);\n        }\n    }\n\n    None\n}\n\n/// Parses a data type such as `struct` or `enum`.\nfn next_data_type\u003c'a\u003e(input: \u0026'a mut Peekable\u003cimpl Iterator\u003cItem = TokenTree\u003e\u003e) -\u003e DataType {\n    // The next token should either be a `struct` or `enum`\n    if let Some(TokenTree::Ident(ident)) = input.peek() {\n        if ident.to_string() != \"struct\" {\n            panic!(\"Data type `{}` is not yet supported\", ident);\n        }\n\n        // Consume the data type identifier\n        input.next();\n\n        let struct_name = next_ident(input).unwrap_or_else(|| {\n            let next = input.peek();\n            panic!(\"Expected a struct name, got {:?}\", next);\n        });\n\n        // TODO: Handle unit struct (`struct Foo;`)\n        let group = next_group(input)\n            .unwrap_or_else(|| panic!(\"Expected a struct group, got {:?}\", input.peek()));\n\n        // Examine the group delimiter to determine if this is a named or unnamed struct\n        match group.delimiter() {\n            Delimiter::Brace =\u003e {}\n            delim =\u003e panic!(\"Unsupported group delimiter: {:?}. Currently only braces (named structs) are supported\", delim)\n        }\n\n        let mut group_body = group.stream().into_iter().peekable();\n\n        return DataType::Struct(Struct {\n            name: struct_name,\n            fields: next_fields(\u0026mut group_body),\n        });\n    }\n\n    panic!(\"Unexpected token: {:?}\", input.next());\n}\n\nfn next_fields\u003c'a\u003e(input: \u0026'a mut Peekable\u003cimpl Iterator\u003cItem = TokenTree\u003e\u003e) -\u003e Vec\u003cField\u003e {\n    let mut fields = Vec::new();\n\n    // Loop until we reach EOF of this group we're in\n    while !next_eof(input) {\n        // At the beginning of this loop we should expect one of the following:\n        // `pub name: Type`\n        // `name: Type`\n\n        // Try to parse a visibility modifier\n        let visibility_modifier = next_visibility_modifier(input);\n\n        // Parse out the field name\n        let name = next_ident(input)\n            .unwrap_or_else(|| panic!(\"failed to parse field name (got: {:?})\", input.peek()));\n\n        // Parse the literal colon `:`\n        next_matching_punct(input, \":\").unwrap_or_else(|| {\n            panic!(\n                \"expected a colon following a struct field name, got: {:?}\",\n                input.peek()\n            )\n        });\n\n        // Parse the field type.\n        // TODO: This does not handle generics, lifetimes, references, or `fully::qualified::path::Names`.\n        let typ = next_ident(input).expect(\"failed to parse field type\");\n\n        // Finally, parse out trailing commas if they exist\n        next_matching_punct(input, \",\");\n\n        fields.push(Field {\n            visibility: visibility_modifier,\n            name,\n            typ,\n        });\n    }\n\n    fields\n}\n\n/// Consumes and returns the next `[proc_macro::Ident]`. Panics if the next token is\n/// empty or not an `Ident`.\nfn next_ident(input: \u0026mut Peekable\u003cimpl Iterator\u003cItem = TokenTree\u003e\u003e) -\u003e Option\u003cIdent\u003e {\n    if let Some(TokenTree::Ident(_)) = input.peek() {\n        // consume this token\n        if let Some(TokenTree::Ident(token)) = input.next() {\n            return Some(token);\n        }\n    }\n\n    None\n}\n\n/// Consumes and returns the next `[proc_macro::Group]`. This is something like: `(crate)`, `{stuff_in_braces}`,\n/// `[stuff_in_brackets]`.\nfn next_group\u003c'a\u003e(input: \u0026'a mut Peekable\u003cimpl Iterator\u003cItem = TokenTree\u003e\u003e) -\u003e Option\u003cGroup\u003e {\n    if let Some(TokenTree::Group(_)) = input.peek() {\n        // consume this token\n        if let Some(TokenTree::Group(group)) = input.next() {\n            return Some(group);\n        }\n    }\n\n    None\n}\n\n/// Returns whether the `input` has reached end-of-file\nfn next_eof(input: \u0026mut Peekable\u003cimpl Iterator\u003cItem = TokenTree\u003e\u003e) -\u003e bool {\n    input.peek().is_none()\n}\n\n/// Consumes and returns the next `[proc_macro::Punct]` if it matches the given string.\nfn next_matching_punct\u003c'a\u003e(\n    input: \u0026'a mut Peekable\u003cimpl Iterator\u003cItem = TokenTree\u003e\u003e,\n    matching_str: \u0026str,\n) -\u003e Option\u003cPunct\u003e {\n    if let Some(TokenTree::Punct(punct)) = input.peek() {\n        if punct.to_string() != matching_str {\n            return None;\n        }\n\n        // Consume this token\n        if let Some(TokenTree::Punct(punct)) = input.next() {\n            return Some(punct);\n        }\n    }\n\n    None\n}\n\n#[proc_macro_derive(OurDefault)]\npub fn default_derive(input: TokenStream) -\u003e TokenStream {\n    // We assume an input that looks loosely like the following:\n    //\n    // pub struct Foo {\n    //    pub a: String,\n    //    b: usize,\n    // }\n    //\n    // At this times enums, lifetime specifiers, unnamed fields, and generic parameters\n    // are not supported.\n\n    // Convert the input to an iterator so we can start peeking tokens\n    let mut source = input.into_iter().peekable();\n\n    // We assume that the first token is going to be either a keyword like `pub`\n    // or `pub(crate), or the data type.\n    let _visibility = next_visibility_modifier(\u0026mut source);\n\n    // Parse the struct\n    let parsed_data_type = next_data_type(\u0026mut source);\n\n    let result_text = match parsed_data_type {\n        DataType::Struct(s) =\u003e {\n            // Map each field to the form of:\n            // `field_name: Default::default(),`\n            let field_initializers = s\n                .fields\n                .iter()\n                .map(|field| format!(\"{}: Default::default()\", field.name))\n                .collect::\u003cVec\u003cString\u003e\u003e()\n                .join(\"\\n,\");\n\n            // Struct has been parsed -- let's emit our impl\n            format!(\n                \"#[automatically_derived] \\\n                impl crate::OurDefault for {} {{ \\\n                    fn our_default() -\u003e Self {{ \\\n                        {} {{\n                            {}\n                        }}\n                    }}\n                }}\",\n                s.name, s.name, field_initializers\n            )\n        }\n        _ =\u003e panic!(\"Only structs are currently supported\"),\n    };\n\n    result_text\n        .parse::\u003cTokenStream\u003e()\n        .expect(\"proc macro generated invalid tokens\")\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","trangar","development","rust","bincode","rust-proc-macro-without-dependencies","default_derive_tester","src","main.rs"],"content":"use default_derive::OurDefault;\n\ntrait OurDefault {\n    fn our_default() -\u003e Self;\n}\n\nfn main() {\n    #[derive(Debug, PartialEq, Eq, OurDefault, Default)]\n    pub struct TestStruct {\n        foo: String,\n        pub bar: usize,\n    }\n\n    assert_eq!(TestStruct::our_default(), TestStruct::default())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","trangar","development","rust","bincode","src","config.rs"],"content":"pub(crate) use self::internal::*;\nuse core::marker::PhantomData;\n\npub trait Config: InternalConfig + Copy + Clone + Sized {\n    fn with_big_endian(self) -\u003e BigEndian\u003cSelf\u003e {\n        BigEndian { _pd: PhantomData }\n    }\n    fn with_little_endian(self) -\u003e LittleEndian\u003cSelf\u003e {\n        LittleEndian { _pd: PhantomData }\n    }\n    fn with_variable_int_encoding(self) -\u003e Varint\u003cSelf\u003e {\n        Varint { _pd: PhantomData }\n    }\n    fn with_fixed_int_encoding(self) -\u003e Fixint\u003cSelf\u003e {\n        Fixint { _pd: PhantomData }\n    }\n}\n\nimpl\u003cT: InternalConfig\u003e Config for T {}\n\n#[derive(Copy, Clone)]\npub struct Default;\n\nimpl InternalConfig for Default {\n    const ENDIAN: Endian = Endian::Little;\n    const INT_ENCODING: IntEncoding = IntEncoding::Variable;\n    const LIMIT: Option\u003cu64\u003e = None;\n    const ALLOW_TRAILING: bool = true;\n}\n\n#[derive(Copy, Clone)]\npub struct BigEndian\u003cC: Config\u003e {\n    _pd: PhantomData\u003cC\u003e,\n}\n\nimpl\u003cC: InternalConfig\u003e InternalConfig for BigEndian\u003cC\u003e {\n    const ENDIAN: Endian = Endian::Big;\n    const INT_ENCODING: IntEncoding = C::INT_ENCODING;\n    const LIMIT: Option\u003cu64\u003e = C::LIMIT;\n    const ALLOW_TRAILING: bool = C::ALLOW_TRAILING;\n}\n\n#[derive(Copy, Clone)]\npub struct LittleEndian\u003cC: Config\u003e {\n    _pd: PhantomData\u003cC\u003e,\n}\n\nimpl\u003cC: InternalConfig\u003e InternalConfig for LittleEndian\u003cC\u003e {\n    const ENDIAN: Endian = Endian::Little;\n    const INT_ENCODING: IntEncoding = C::INT_ENCODING;\n    const LIMIT: Option\u003cu64\u003e = C::LIMIT;\n    const ALLOW_TRAILING: bool = C::ALLOW_TRAILING;\n}\n\n#[derive(Copy, Clone)]\npub struct Fixint\u003cC: Config\u003e {\n    _pd: PhantomData\u003cC\u003e,\n}\n\nimpl\u003cC: InternalConfig\u003e InternalConfig for Fixint\u003cC\u003e {\n    const ENDIAN: Endian = C::ENDIAN;\n    const INT_ENCODING: IntEncoding = IntEncoding::Fixed;\n    const LIMIT: Option\u003cu64\u003e = C::LIMIT;\n    const ALLOW_TRAILING: bool = C::ALLOW_TRAILING;\n}\n\n#[derive(Copy, Clone)]\npub struct Varint\u003cC: Config\u003e {\n    _pd: PhantomData\u003cC\u003e,\n}\n\nimpl\u003cC: InternalConfig\u003e InternalConfig for Varint\u003cC\u003e {\n    const ENDIAN: Endian = C::ENDIAN;\n    const INT_ENCODING: IntEncoding = IntEncoding::Variable;\n    const LIMIT: Option\u003cu64\u003e = C::LIMIT;\n    const ALLOW_TRAILING: bool = C::ALLOW_TRAILING;\n}\n\nmod internal {\n    pub trait InternalConfig: Copy + Clone {\n        const ENDIAN: Endian;\n        const INT_ENCODING: IntEncoding;\n        const LIMIT: Option\u003cu64\u003e;\n        const ALLOW_TRAILING: bool;\n    }\n\n    #[derive(PartialEq, Eq)]\n    pub enum Endian {\n        Little,\n        Big,\n    }\n\n    #[derive(PartialEq, Eq)]\n    pub enum IntEncoding {\n        Fixed,\n        Variable,\n    }\n\n    impl\u003c'a, C: InternalConfig\u003e InternalConfig for \u0026'a mut C\n    where\n        \u0026'a mut C: Copy + Clone,\n    {\n        const ENDIAN: Endian = C::ENDIAN;\n        const INT_ENCODING: IntEncoding = C::INT_ENCODING;\n        const LIMIT: Option\u003cu64\u003e = C::LIMIT;\n        const ALLOW_TRAILING: bool = C::ALLOW_TRAILING;\n    }\n}\n","traces":[{"line":5,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":6,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":8,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":9,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":11,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":12,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":14,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":8},{"path":["/","home","trangar","development","rust","bincode","src","de","decoder.rs"],"content":"use super::{\n    read::{BorrowReader, Reader},\n    BorrowDecode, Decode,\n};\nuse crate::{\n    config::{Config, Endian, IntEncoding},\n    error::DecodeError,\n};\nuse core::marker::PhantomData;\n\npub struct Decoder\u003cR, C: Config\u003e {\n    reader: R,\n    config: PhantomData\u003cC\u003e,\n}\n\nimpl\u003c'de, R: Reader\u003c'de\u003e, C: Config\u003e Decoder\u003cR, C\u003e {\n    pub fn new(reader: R, _config: C) -\u003e Decoder\u003cR, C\u003e {\n        Decoder {\n            reader,\n            config: PhantomData,\n        }\n    }\n\n    pub fn into_reader(self) -\u003e R {\n        self.reader\n    }\n}\n\nimpl\u003c'a, 'de, R: BorrowReader\u003c'de\u003e, C: Config\u003e BorrowDecode\u003c'de\u003e for \u0026'a mut Decoder\u003cR, C\u003e {\n    fn decode_slice(\u0026mut self, len: usize) -\u003e Result\u003c\u0026'de [u8], DecodeError\u003e {\n        self.reader.take_bytes(len)\n    }\n}\n\nimpl\u003c'a, 'de, R: Reader\u003c'de\u003e, C: Config\u003e Decode for \u0026'a mut Decoder\u003cR, C\u003e {\n    fn decode_u8(\u0026mut self) -\u003e Result\u003cu8, DecodeError\u003e {\n        let mut bytes = [0u8; 1];\n        self.reader.read(\u0026mut bytes)?;\n        Ok(bytes[0])\n    }\n\n    fn decode_u16(\u0026mut self) -\u003e Result\u003cu16, DecodeError\u003e {\n        match C::INT_ENCODING {\n            IntEncoding::Variable =\u003e crate::varint::varint_decode_u16(\u0026mut self.reader, C::ENDIAN),\n            IntEncoding::Fixed =\u003e {\n                let mut bytes = [0u8; 2];\n                self.reader.read(\u0026mut bytes)?;\n                Ok(match C::ENDIAN {\n                    Endian::Little =\u003e u16::from_le_bytes(bytes),\n                    Endian::Big =\u003e u16::from_be_bytes(bytes),\n                })\n            }\n        }\n    }\n\n    fn decode_u32(\u0026mut self) -\u003e Result\u003cu32, DecodeError\u003e {\n        match C::INT_ENCODING {\n            IntEncoding::Variable =\u003e crate::varint::varint_decode_u32(\u0026mut self.reader, C::ENDIAN),\n            IntEncoding::Fixed =\u003e {\n                let mut bytes = [0u8; 4];\n                self.reader.read(\u0026mut bytes)?;\n                Ok(match C::ENDIAN {\n                    Endian::Little =\u003e u32::from_le_bytes(bytes),\n                    Endian::Big =\u003e u32::from_be_bytes(bytes),\n                })\n            }\n        }\n    }\n\n    fn decode_u64(\u0026mut self) -\u003e Result\u003cu64, DecodeError\u003e {\n        match C::INT_ENCODING {\n            IntEncoding::Variable =\u003e crate::varint::varint_decode_u64(\u0026mut self.reader, C::ENDIAN),\n            IntEncoding::Fixed =\u003e {\n                let mut bytes = [0u8; 8];\n                self.reader.read(\u0026mut bytes)?;\n                Ok(match C::ENDIAN {\n                    Endian::Little =\u003e u64::from_le_bytes(bytes),\n                    Endian::Big =\u003e u64::from_be_bytes(bytes),\n                })\n            }\n        }\n    }\n\n    fn decode_u128(\u0026mut self) -\u003e Result\u003cu128, DecodeError\u003e {\n        match C::INT_ENCODING {\n            IntEncoding::Variable =\u003e crate::varint::varint_decode_u128(\u0026mut self.reader, C::ENDIAN),\n            IntEncoding::Fixed =\u003e {\n                let mut bytes = [0u8; 16];\n                self.reader.read(\u0026mut bytes)?;\n                Ok(match C::ENDIAN {\n                    Endian::Little =\u003e u128::from_le_bytes(bytes),\n                    Endian::Big =\u003e u128::from_be_bytes(bytes),\n                })\n            }\n        }\n    }\n\n    fn decode_usize(\u0026mut self) -\u003e Result\u003cusize, DecodeError\u003e {\n        match C::INT_ENCODING {\n            IntEncoding::Variable =\u003e {\n                crate::varint::varint_decode_usize(\u0026mut self.reader, C::ENDIAN)\n            }\n            IntEncoding::Fixed =\u003e {\n                let mut bytes = [0u8; 8];\n                self.reader.read(\u0026mut bytes)?;\n                Ok(match C::ENDIAN {\n                    Endian::Little =\u003e u64::from_le_bytes(bytes),\n                    Endian::Big =\u003e u64::from_be_bytes(bytes),\n                } as usize)\n            }\n        }\n    }\n\n    fn decode_i8(\u0026mut self) -\u003e Result\u003ci8, DecodeError\u003e {\n        let mut bytes = [0u8; 1];\n        self.reader.read(\u0026mut bytes)?;\n        Ok(bytes[0] as i8)\n    }\n\n    fn decode_i16(\u0026mut self) -\u003e Result\u003ci16, DecodeError\u003e {\n        match C::INT_ENCODING {\n            IntEncoding::Variable =\u003e crate::varint::varint_decode_i16(\u0026mut self.reader, C::ENDIAN),\n            IntEncoding::Fixed =\u003e {\n                let mut bytes = [0u8; 2];\n                self.reader.read(\u0026mut bytes)?;\n                Ok(match C::ENDIAN {\n                    Endian::Little =\u003e i16::from_le_bytes(bytes),\n                    Endian::Big =\u003e i16::from_be_bytes(bytes),\n                })\n            }\n        }\n    }\n\n    fn decode_i32(\u0026mut self) -\u003e Result\u003ci32, DecodeError\u003e {\n        match C::INT_ENCODING {\n            IntEncoding::Variable =\u003e crate::varint::varint_decode_i32(\u0026mut self.reader, C::ENDIAN),\n            IntEncoding::Fixed =\u003e {\n                let mut bytes = [0u8; 4];\n                self.reader.read(\u0026mut bytes)?;\n                Ok(match C::ENDIAN {\n                    Endian::Little =\u003e i32::from_le_bytes(bytes),\n                    Endian::Big =\u003e i32::from_be_bytes(bytes),\n                })\n            }\n        }\n    }\n\n    fn decode_i64(\u0026mut self) -\u003e Result\u003ci64, DecodeError\u003e {\n        match C::INT_ENCODING {\n            IntEncoding::Variable =\u003e crate::varint::varint_decode_i64(\u0026mut self.reader, C::ENDIAN),\n            IntEncoding::Fixed =\u003e {\n                let mut bytes = [0u8; 8];\n                self.reader.read(\u0026mut bytes)?;\n                Ok(match C::ENDIAN {\n                    Endian::Little =\u003e i64::from_le_bytes(bytes),\n                    Endian::Big =\u003e i64::from_be_bytes(bytes),\n                })\n            }\n        }\n    }\n\n    fn decode_i128(\u0026mut self) -\u003e Result\u003ci128, DecodeError\u003e {\n        match C::INT_ENCODING {\n            IntEncoding::Variable =\u003e crate::varint::varint_decode_i128(\u0026mut self.reader, C::ENDIAN),\n            IntEncoding::Fixed =\u003e {\n                let mut bytes = [0u8; 16];\n                self.reader.read(\u0026mut bytes)?;\n                Ok(match C::ENDIAN {\n                    Endian::Little =\u003e i128::from_le_bytes(bytes),\n                    Endian::Big =\u003e i128::from_be_bytes(bytes),\n                })\n            }\n        }\n    }\n\n    fn decode_isize(\u0026mut self) -\u003e Result\u003cisize, DecodeError\u003e {\n        match C::INT_ENCODING {\n            IntEncoding::Variable =\u003e {\n                crate::varint::varint_decode_isize(\u0026mut self.reader, C::ENDIAN)\n            }\n            IntEncoding::Fixed =\u003e {\n                let mut bytes = [0u8; 8];\n                self.reader.read(\u0026mut bytes)?;\n                Ok(match C::ENDIAN {\n                    Endian::Little =\u003e i64::from_le_bytes(bytes),\n                    Endian::Big =\u003e i64::from_be_bytes(bytes),\n                } as isize)\n            }\n        }\n    }\n\n    fn decode_f32(\u0026mut self) -\u003e Result\u003cf32, DecodeError\u003e {\n        let mut bytes = [0u8; 4];\n        self.reader.read(\u0026mut bytes)?;\n        Ok(match C::ENDIAN {\n            Endian::Little =\u003e f32::from_le_bytes(bytes),\n            Endian::Big =\u003e f32::from_be_bytes(bytes),\n        })\n    }\n\n    fn decode_f64(\u0026mut self) -\u003e Result\u003cf64, DecodeError\u003e {\n        let mut bytes = [0u8; 8];\n        self.reader.read(\u0026mut bytes)?;\n        Ok(match C::ENDIAN {\n            Endian::Little =\u003e f64::from_le_bytes(bytes),\n            Endian::Big =\u003e f64::from_be_bytes(bytes),\n        })\n    }\n\n    fn decode_array\u003cconst N: usize\u003e(\u0026mut self) -\u003e Result\u003c[u8; N], DecodeError\u003e {\n        let mut array = [0u8; N];\n        self.reader.read(\u0026mut array)?;\n        Ok(array)\n    }\n}\n","traces":[{"line":17,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":182,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":186,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":193,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":194,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":195,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":196,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":203,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":204,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":210,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":211,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":123},{"path":["/","home","trangar","development","rust","bincode","src","de","impls.rs"],"content":"use super::{BorrowDecodable, BorrowDecode, Decodable, Decode};\nuse crate::error::DecodeError;\n\nimpl\u003c'de\u003e Decodable for u8 {\n    fn decode\u003cD: Decode\u003e(mut decoder: D) -\u003e Result\u003cSelf, DecodeError\u003e {\n        decoder.decode_u8()\n    }\n}\n\nimpl\u003c'de\u003e Decodable for u16 {\n    fn decode\u003cD: Decode\u003e(mut decoder: D) -\u003e Result\u003cSelf, DecodeError\u003e {\n        decoder.decode_u16()\n    }\n}\n\nimpl\u003c'de\u003e Decodable for u32 {\n    fn decode\u003cD: Decode\u003e(mut decoder: D) -\u003e Result\u003cSelf, DecodeError\u003e {\n        decoder.decode_u32()\n    }\n}\n\nimpl\u003c'de\u003e Decodable for u64 {\n    fn decode\u003cD: Decode\u003e(mut decoder: D) -\u003e Result\u003cSelf, DecodeError\u003e {\n        decoder.decode_u64()\n    }\n}\n\nimpl\u003c'de\u003e Decodable for u128 {\n    fn decode\u003cD: Decode\u003e(mut decoder: D) -\u003e Result\u003cSelf, DecodeError\u003e {\n        decoder.decode_u128()\n    }\n}\n\nimpl\u003c'de\u003e Decodable for usize {\n    fn decode\u003cD: Decode\u003e(mut decoder: D) -\u003e Result\u003cSelf, DecodeError\u003e {\n        decoder.decode_usize()\n    }\n}\n\nimpl\u003c'de\u003e Decodable for i8 {\n    fn decode\u003cD: Decode\u003e(mut decoder: D) -\u003e Result\u003cSelf, DecodeError\u003e {\n        decoder.decode_i8()\n    }\n}\n\nimpl\u003c'de\u003e Decodable for i16 {\n    fn decode\u003cD: Decode\u003e(mut decoder: D) -\u003e Result\u003cSelf, DecodeError\u003e {\n        decoder.decode_i16()\n    }\n}\n\nimpl\u003c'de\u003e Decodable for i32 {\n    fn decode\u003cD: Decode\u003e(mut decoder: D) -\u003e Result\u003cSelf, DecodeError\u003e {\n        decoder.decode_i32()\n    }\n}\n\nimpl\u003c'de\u003e Decodable for i64 {\n    fn decode\u003cD: Decode\u003e(mut decoder: D) -\u003e Result\u003cSelf, DecodeError\u003e {\n        decoder.decode_i64()\n    }\n}\n\nimpl\u003c'de\u003e Decodable for i128 {\n    fn decode\u003cD: Decode\u003e(mut decoder: D) -\u003e Result\u003cSelf, DecodeError\u003e {\n        decoder.decode_i128()\n    }\n}\n\nimpl\u003c'de\u003e Decodable for isize {\n    fn decode\u003cD: Decode\u003e(mut decoder: D) -\u003e Result\u003cSelf, DecodeError\u003e {\n        decoder.decode_isize()\n    }\n}\n\nimpl\u003c'de\u003e Decodable for f32 {\n    fn decode\u003cD: Decode\u003e(mut decoder: D) -\u003e Result\u003cSelf, DecodeError\u003e {\n        decoder.decode_f32()\n    }\n}\n\nimpl\u003c'de\u003e Decodable for f64 {\n    fn decode\u003cD: Decode\u003e(mut decoder: D) -\u003e Result\u003cSelf, DecodeError\u003e {\n        decoder.decode_f64()\n    }\n}\n\nimpl\u003c'a, 'de: 'a\u003e BorrowDecodable\u003c'de\u003e for \u0026'a [u8] {\n    fn borrow_decode\u003cD: BorrowDecode\u003c'de\u003e\u003e(mut decoder: D) -\u003e Result\u003cSelf, DecodeError\u003e {\n        let len = usize::decode(\u0026mut decoder)?;\n        decoder.decode_slice(len)\n    }\n}\n\nimpl\u003c'a, 'de: 'a\u003e BorrowDecodable\u003c'de\u003e for \u0026'a str {\n    fn borrow_decode\u003cD: BorrowDecode\u003c'de\u003e\u003e(decoder: D) -\u003e Result\u003cSelf, DecodeError\u003e {\n        let slice: \u0026[u8] = BorrowDecodable::borrow_decode(decoder)?;\n        core::str::from_utf8(slice).map_err(DecodeError::Utf8)\n    }\n}\n\nimpl\u003c'de, const N: usize\u003e Decodable for [u8; N] {\n    fn decode\u003cD: Decode\u003e(mut decoder: D) -\u003e Result\u003cSelf, DecodeError\u003e {\n        decoder.decode_array()\n    }\n}\n\nimpl\u003c'de, T\u003e Decodable for core::marker::PhantomData\u003cT\u003e {\n    fn decode\u003cD: Decode\u003e(_: D) -\u003e Result\u003cSelf, DecodeError\u003e {\n        Ok(core::marker::PhantomData)\n    }\n}\n\nimpl\u003c'a, 'de, T\u003e Decode for \u0026'a mut T\nwhere\n    T: Decode,\n{\n    fn decode_u8(\u0026mut self) -\u003e Result\u003cu8, DecodeError\u003e {\n        T::decode_u8(self)\n    }\n\n    fn decode_u16(\u0026mut self) -\u003e Result\u003cu16, DecodeError\u003e {\n        T::decode_u16(self)\n    }\n\n    fn decode_u32(\u0026mut self) -\u003e Result\u003cu32, DecodeError\u003e {\n        T::decode_u32(self)\n    }\n\n    fn decode_u64(\u0026mut self) -\u003e Result\u003cu64, DecodeError\u003e {\n        T::decode_u64(self)\n    }\n\n    fn decode_u128(\u0026mut self) -\u003e Result\u003cu128, DecodeError\u003e {\n        T::decode_u128(self)\n    }\n\n    fn decode_usize(\u0026mut self) -\u003e Result\u003cusize, DecodeError\u003e {\n        T::decode_usize(self)\n    }\n\n    fn decode_i8(\u0026mut self) -\u003e Result\u003ci8, DecodeError\u003e {\n        T::decode_i8(self)\n    }\n\n    fn decode_i16(\u0026mut self) -\u003e Result\u003ci16, DecodeError\u003e {\n        T::decode_i16(self)\n    }\n\n    fn decode_i32(\u0026mut self) -\u003e Result\u003ci32, DecodeError\u003e {\n        T::decode_i32(self)\n    }\n\n    fn decode_i64(\u0026mut self) -\u003e Result\u003ci64, DecodeError\u003e {\n        T::decode_i64(self)\n    }\n\n    fn decode_i128(\u0026mut self) -\u003e Result\u003ci128, DecodeError\u003e {\n        T::decode_i128(self)\n    }\n\n    fn decode_isize(\u0026mut self) -\u003e Result\u003cisize, DecodeError\u003e {\n        T::decode_isize(self)\n    }\n\n    fn decode_f32(\u0026mut self) -\u003e Result\u003cf32, DecodeError\u003e {\n        T::decode_f32(self)\n    }\n\n    fn decode_f64(\u0026mut self) -\u003e Result\u003cf64, DecodeError\u003e {\n        T::decode_f64(self)\n    }\n\n    fn decode_array\u003cconst N: usize\u003e(\u0026mut self) -\u003e Result\u003c[u8; N], DecodeError\u003e {\n        T::decode_array::\u003cN\u003e(self)\n    }\n}\n\nimpl\u003c'a, 'de, T\u003e BorrowDecode\u003c'de\u003e for \u0026'a mut T\nwhere\n    T: BorrowDecode\u003c'de\u003e,\n{\n    fn decode_slice(\u0026mut self, len: usize) -\u003e Result\u003c\u0026'de [u8], DecodeError\u003e {\n        T::decode_slice(self, len)\n    }\n}\n","traces":[{"line":5,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":6,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":11,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":12,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":70},{"path":["/","home","trangar","development","rust","bincode","src","de","mod.rs"],"content":"use crate::error::DecodeError;\n\nmod decoder;\nmod impls;\n\npub mod read;\npub use self::decoder::Decoder;\n\npub trait Decodable: for\u003c'de\u003e BorrowDecodable\u003c'de\u003e {\n    fn decode\u003cD: Decode\u003e(decoder: D) -\u003e Result\u003cSelf, DecodeError\u003e;\n}\n\npub trait BorrowDecodable\u003c'de\u003e: Sized {\n    fn borrow_decode\u003cD: BorrowDecode\u003c'de\u003e\u003e(decoder: D) -\u003e Result\u003cSelf, DecodeError\u003e;\n}\n\nimpl\u003c'de, T: Decodable\u003e BorrowDecodable\u003c'de\u003e for T {\n    fn borrow_decode\u003cD: Decode\u003e(decoder: D) -\u003e Result\u003cSelf, DecodeError\u003e {\n        Decodable::decode(decoder)\n    }\n}\n\npub trait Decode {\n    fn decode_u8(\u0026mut self) -\u003e Result\u003cu8, DecodeError\u003e;\n    fn decode_u16(\u0026mut self) -\u003e Result\u003cu16, DecodeError\u003e;\n    fn decode_u32(\u0026mut self) -\u003e Result\u003cu32, DecodeError\u003e;\n    fn decode_u64(\u0026mut self) -\u003e Result\u003cu64, DecodeError\u003e;\n    fn decode_u128(\u0026mut self) -\u003e Result\u003cu128, DecodeError\u003e;\n    fn decode_usize(\u0026mut self) -\u003e Result\u003cusize, DecodeError\u003e;\n\n    fn decode_i8(\u0026mut self) -\u003e Result\u003ci8, DecodeError\u003e;\n    fn decode_i16(\u0026mut self) -\u003e Result\u003ci16, DecodeError\u003e;\n    fn decode_i32(\u0026mut self) -\u003e Result\u003ci32, DecodeError\u003e;\n    fn decode_i64(\u0026mut self) -\u003e Result\u003ci64, DecodeError\u003e;\n    fn decode_i128(\u0026mut self) -\u003e Result\u003ci128, DecodeError\u003e;\n    fn decode_isize(\u0026mut self) -\u003e Result\u003cisize, DecodeError\u003e;\n\n    fn decode_f32(\u0026mut self) -\u003e Result\u003cf32, DecodeError\u003e;\n    fn decode_f64(\u0026mut self) -\u003e Result\u003cf64, DecodeError\u003e;\n    fn decode_array\u003cconst N: usize\u003e(\u0026mut self) -\u003e Result\u003c[u8; N], DecodeError\u003e;\n}\n\npub trait BorrowDecode\u003c'de\u003e: Decode {\n    fn decode_slice(\u0026mut self, len: usize) -\u003e Result\u003c\u0026'de [u8], DecodeError\u003e;\n}\n","traces":[{"line":18,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":2},{"path":["/","home","trangar","development","rust","bincode","src","de","read.rs"],"content":"use crate::error::DecodeError;\n\npub trait Reader\u003c'storage\u003e {\n    fn read(\u0026mut self, bytes: \u0026mut [u8]) -\u003e Result\u003c(), DecodeError\u003e;\n}\n\npub trait BorrowReader\u003c'storage\u003e: Reader\u003c'storage\u003e {\n    fn take_bytes(\u0026mut self, length: usize) -\u003e Result\u003c\u0026'storage [u8], DecodeError\u003e;\n}\n\npub struct SliceReader\u003c'storage\u003e {\n    slice: \u0026'storage [u8],\n}\n\nimpl\u003c'storage\u003e SliceReader\u003c'storage\u003e {\n    /// Constructs a slice reader\n    pub(crate) fn new(bytes: \u0026'storage [u8]) -\u003e SliceReader\u003c'storage\u003e {\n        SliceReader { slice: bytes }\n    }\n\n    #[inline(always)]\n    fn get_byte_slice(\u0026mut self, length: usize) -\u003e Result\u003c\u0026'storage [u8], DecodeError\u003e {\n        if length \u003e self.slice.len() {\n            return Err(DecodeError::UnexpectedEnd);\n        }\n        let (read_slice, remaining) = self.slice.split_at(length);\n        self.slice = remaining;\n        Ok(read_slice)\n    }\n}\n\nimpl\u003c'storage\u003e Reader\u003c'storage\u003e for SliceReader\u003c'storage\u003e {\n    #[inline(always)]\n    fn read(\u0026mut self, bytes: \u0026mut [u8]) -\u003e Result\u003c(), DecodeError\u003e {\n        if bytes.len() \u003e self.slice.len() {\n            return Err(DecodeError::UnexpectedEnd);\n        }\n        let (read_slice, remaining) = self.slice.split_at(bytes.len());\n        bytes.copy_from_slice(read_slice);\n        self.slice = remaining;\n\n        Ok(())\n    }\n}\n\nimpl\u003c'storage\u003e BorrowReader\u003c'storage\u003e for SliceReader\u003c'storage\u003e {\n    #[inline(always)]\n    fn take_bytes(\u0026mut self, length: usize) -\u003e Result\u003c\u0026'storage [u8], DecodeError\u003e {\n        self.get_byte_slice(length)\n    }\n}\n","traces":[{"line":17,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":16},{"path":["/","home","trangar","development","rust","bincode","src","enc","encoder.rs"],"content":"use super::{write::Writer, Encode};\nuse crate::{\n    config::{Config, Endian, IntEncoding},\n    error::EncodeError,\n};\nuse core::marker::PhantomData;\n\npub struct Encoder\u003cW: Writer, C: Config\u003e {\n    writer: W,\n    config: PhantomData\u003cC\u003e,\n}\n\nimpl\u003cW: Writer, C: Config\u003e Encoder\u003cW, C\u003e {\n    pub fn new(writer: W) -\u003e Encoder\u003cW, C\u003e {\n        Encoder {\n            writer,\n            config: PhantomData,\n        }\n    }\n\n    pub fn into_writer(self) -\u003e W {\n        self.writer\n    }\n}\n\nimpl\u003c'a, W: Writer, C: Config\u003e Encode for \u0026'a mut Encoder\u003cW, C\u003e {\n    fn encode_u8(\u0026mut self, val: u8) -\u003e Result\u003c(), EncodeError\u003e {\n        self.writer.write(\u0026[val])\n    }\n\n    fn encode_u16(\u0026mut self, val: u16) -\u003e Result\u003c(), EncodeError\u003e {\n        match C::INT_ENCODING {\n            IntEncoding::Variable =\u003e {\n                crate::varint::varint_encode_u16(\u0026mut self.writer, C::ENDIAN, val)\n            }\n            IntEncoding::Fixed =\u003e match C::ENDIAN {\n                Endian::Big =\u003e self.writer.write(\u0026val.to_be_bytes()),\n                Endian::Little =\u003e self.writer.write(\u0026val.to_le_bytes()),\n            },\n        }\n    }\n\n    fn encode_u32(\u0026mut self, val: u32) -\u003e Result\u003c(), EncodeError\u003e {\n        match C::INT_ENCODING {\n            IntEncoding::Variable =\u003e {\n                crate::varint::varint_encode_u32(\u0026mut self.writer, C::ENDIAN, val)\n            }\n            IntEncoding::Fixed =\u003e match C::ENDIAN {\n                Endian::Big =\u003e self.writer.write(\u0026val.to_be_bytes()),\n                Endian::Little =\u003e self.writer.write(\u0026val.to_le_bytes()),\n            },\n        }\n    }\n\n    fn encode_u64(\u0026mut self, val: u64) -\u003e Result\u003c(), EncodeError\u003e {\n        match C::INT_ENCODING {\n            IntEncoding::Variable =\u003e {\n                crate::varint::varint_encode_u64(\u0026mut self.writer, C::ENDIAN, val)\n            }\n            IntEncoding::Fixed =\u003e match C::ENDIAN {\n                Endian::Big =\u003e self.writer.write(\u0026val.to_be_bytes()),\n                Endian::Little =\u003e self.writer.write(\u0026val.to_le_bytes()),\n            },\n        }\n    }\n\n    fn encode_u128(\u0026mut self, val: u128) -\u003e Result\u003c(), EncodeError\u003e {\n        match C::INT_ENCODING {\n            IntEncoding::Variable =\u003e {\n                crate::varint::varint_encode_u128(\u0026mut self.writer, C::ENDIAN, val)\n            }\n            IntEncoding::Fixed =\u003e match C::ENDIAN {\n                Endian::Big =\u003e self.writer.write(\u0026val.to_be_bytes()),\n                Endian::Little =\u003e self.writer.write(\u0026val.to_le_bytes()),\n            },\n        }\n    }\n\n    fn encode_usize(\u0026mut self, val: usize) -\u003e Result\u003c(), EncodeError\u003e {\n        match C::INT_ENCODING {\n            IntEncoding::Variable =\u003e {\n                crate::varint::varint_encode_usize(\u0026mut self.writer, C::ENDIAN, val)\n            }\n            IntEncoding::Fixed =\u003e match C::ENDIAN {\n                Endian::Big =\u003e self.writer.write(\u0026val.to_be_bytes()),\n                Endian::Little =\u003e self.writer.write(\u0026val.to_le_bytes()),\n            },\n        }\n    }\n\n    fn encode_i8(\u0026mut self, val: i8) -\u003e Result\u003c(), EncodeError\u003e {\n        self.writer.write(\u0026[val as u8])\n    }\n\n    fn encode_i16(\u0026mut self, val: i16) -\u003e Result\u003c(), EncodeError\u003e {\n        match C::INT_ENCODING {\n            IntEncoding::Variable =\u003e {\n                crate::varint::varint_encode_i16(\u0026mut self.writer, C::ENDIAN, val)\n            }\n            IntEncoding::Fixed =\u003e match C::ENDIAN {\n                Endian::Big =\u003e self.writer.write(\u0026val.to_be_bytes()),\n                Endian::Little =\u003e self.writer.write(\u0026val.to_le_bytes()),\n            },\n        }\n    }\n\n    fn encode_i32(\u0026mut self, val: i32) -\u003e Result\u003c(), EncodeError\u003e {\n        match C::INT_ENCODING {\n            IntEncoding::Variable =\u003e {\n                crate::varint::varint_encode_i32(\u0026mut self.writer, C::ENDIAN, val)\n            }\n            IntEncoding::Fixed =\u003e match C::ENDIAN {\n                Endian::Big =\u003e self.writer.write(\u0026val.to_be_bytes()),\n                Endian::Little =\u003e self.writer.write(\u0026val.to_le_bytes()),\n            },\n        }\n    }\n\n    fn encode_i64(\u0026mut self, val: i64) -\u003e Result\u003c(), EncodeError\u003e {\n        match C::INT_ENCODING {\n            IntEncoding::Variable =\u003e {\n                crate::varint::varint_encode_i64(\u0026mut self.writer, C::ENDIAN, val)\n            }\n            IntEncoding::Fixed =\u003e match C::ENDIAN {\n                Endian::Big =\u003e self.writer.write(\u0026val.to_be_bytes()),\n                Endian::Little =\u003e self.writer.write(\u0026val.to_le_bytes()),\n            },\n        }\n    }\n\n    fn encode_i128(\u0026mut self, val: i128) -\u003e Result\u003c(), EncodeError\u003e {\n        match C::INT_ENCODING {\n            IntEncoding::Variable =\u003e {\n                crate::varint::varint_encode_i128(\u0026mut self.writer, C::ENDIAN, val)\n            }\n            IntEncoding::Fixed =\u003e match C::ENDIAN {\n                Endian::Big =\u003e self.writer.write(\u0026val.to_be_bytes()),\n                Endian::Little =\u003e self.writer.write(\u0026val.to_le_bytes()),\n            },\n        }\n    }\n\n    fn encode_isize(\u0026mut self, val: isize) -\u003e Result\u003c(), EncodeError\u003e {\n        match C::INT_ENCODING {\n            IntEncoding::Variable =\u003e {\n                crate::varint::varint_encode_isize(\u0026mut self.writer, C::ENDIAN, val)\n            }\n            IntEncoding::Fixed =\u003e match C::ENDIAN {\n                Endian::Big =\u003e self.writer.write(\u0026val.to_be_bytes()),\n                Endian::Little =\u003e self.writer.write(\u0026val.to_le_bytes()),\n            },\n        }\n    }\n\n    fn encode_f32(\u0026mut self, val: f32) -\u003e Result\u003c(), EncodeError\u003e {\n        match C::ENDIAN {\n            Endian::Big =\u003e self.writer.write(\u0026val.to_be_bytes()),\n            Endian::Little =\u003e self.writer.write(\u0026val.to_le_bytes()),\n        }\n    }\n\n    fn encode_f64(\u0026mut self, val: f64) -\u003e Result\u003c(), EncodeError\u003e {\n        match C::ENDIAN {\n            Endian::Big =\u003e self.writer.write(\u0026val.to_be_bytes()),\n            Endian::Little =\u003e self.writer.write(\u0026val.to_le_bytes()),\n        }\n    }\n\n    fn encode_slice(\u0026mut self, val: \u0026[u8]) -\u003e Result\u003c(), EncodeError\u003e {\n        self.encode_usize(val.len())?;\n        self.writer.write(val)\n    }\n\n    fn encode_array\u003cconst N: usize\u003e(\u0026mut self, val: [u8; N]) -\u003e Result\u003c(), EncodeError\u003e {\n        self.writer.write(\u0026val)\n    }\n}\n","traces":[{"line":14,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":90},{"path":["/","home","trangar","development","rust","bincode","src","enc","impls.rs"],"content":"use super::{Encode, Encodeable};\nuse crate::error::EncodeError;\n\nimpl Encodeable for u8 {\n    fn encode\u003cE: Encode\u003e(\u0026self, mut encoder: E) -\u003e Result\u003c(), EncodeError\u003e {\n        encoder.encode_u8(*self)\n    }\n}\n\nimpl Encodeable for u16 {\n    fn encode\u003cE: Encode\u003e(\u0026self, mut encoder: E) -\u003e Result\u003c(), EncodeError\u003e {\n        encoder.encode_u16(*self)\n    }\n}\n\nimpl Encodeable for u32 {\n    fn encode\u003cE: Encode\u003e(\u0026self, mut encoder: E) -\u003e Result\u003c(), EncodeError\u003e {\n        encoder.encode_u32(*self)\n    }\n}\n\nimpl Encodeable for u64 {\n    fn encode\u003cE: Encode\u003e(\u0026self, mut encoder: E) -\u003e Result\u003c(), EncodeError\u003e {\n        encoder.encode_u64(*self)\n    }\n}\n\nimpl Encodeable for u128 {\n    fn encode\u003cE: Encode\u003e(\u0026self, mut encoder: E) -\u003e Result\u003c(), EncodeError\u003e {\n        encoder.encode_u128(*self)\n    }\n}\n\nimpl Encodeable for usize {\n    fn encode\u003cE: Encode\u003e(\u0026self, mut encoder: E) -\u003e Result\u003c(), EncodeError\u003e {\n        encoder.encode_usize(*self)\n    }\n}\n\nimpl Encodeable for i8 {\n    fn encode\u003cE: Encode\u003e(\u0026self, mut encoder: E) -\u003e Result\u003c(), EncodeError\u003e {\n        encoder.encode_i8(*self)\n    }\n}\n\nimpl Encodeable for i16 {\n    fn encode\u003cE: Encode\u003e(\u0026self, mut encoder: E) -\u003e Result\u003c(), EncodeError\u003e {\n        encoder.encode_i16(*self)\n    }\n}\n\nimpl Encodeable for i32 {\n    fn encode\u003cE: Encode\u003e(\u0026self, mut encoder: E) -\u003e Result\u003c(), EncodeError\u003e {\n        encoder.encode_i32(*self)\n    }\n}\n\nimpl Encodeable for i64 {\n    fn encode\u003cE: Encode\u003e(\u0026self, mut encoder: E) -\u003e Result\u003c(), EncodeError\u003e {\n        encoder.encode_i64(*self)\n    }\n}\n\nimpl Encodeable for i128 {\n    fn encode\u003cE: Encode\u003e(\u0026self, mut encoder: E) -\u003e Result\u003c(), EncodeError\u003e {\n        encoder.encode_i128(*self)\n    }\n}\n\nimpl Encodeable for isize {\n    fn encode\u003cE: Encode\u003e(\u0026self, mut encoder: E) -\u003e Result\u003c(), EncodeError\u003e {\n        encoder.encode_isize(*self)\n    }\n}\n\nimpl Encodeable for f32 {\n    fn encode\u003cE: Encode\u003e(\u0026self, mut encoder: E) -\u003e Result\u003c(), EncodeError\u003e {\n        encoder.encode_f32(*self)\n    }\n}\n\nimpl Encodeable for f64 {\n    fn encode\u003cE: Encode\u003e(\u0026self, mut encoder: E) -\u003e Result\u003c(), EncodeError\u003e {\n        encoder.encode_f64(*self)\n    }\n}\n\nimpl Encodeable for \u0026'_ [u8] {\n    fn encode\u003cE: Encode\u003e(\u0026self, mut encoder: E) -\u003e Result\u003c(), EncodeError\u003e {\n        encoder.encode_slice(*self)\n    }\n}\n\nimpl Encodeable for \u0026'_ str {\n    fn encode\u003cE: Encode\u003e(\u0026self, mut encoder: E) -\u003e Result\u003c(), EncodeError\u003e {\n        encoder.encode_slice(self.as_bytes())\n    }\n}\n\nimpl\u003cconst N: usize\u003e Encodeable for [u8; N] {\n    fn encode\u003cE: Encode\u003e(\u0026self, mut encoder: E) -\u003e Result\u003c(), EncodeError\u003e {\n        encoder.encode_array(*self)\n    }\n}\n\nimpl\u003c'a, T\u003e Encode for \u0026'a mut T\nwhere\n    T: Encode,\n{\n    fn encode_u8(\u0026mut self, val: u8) -\u003e Result\u003c(), EncodeError\u003e {\n        T::encode_u8(self, val)\n    }\n    fn encode_u16(\u0026mut self, val: u16) -\u003e Result\u003c(), EncodeError\u003e {\n        T::encode_u16(self, val)\n    }\n    fn encode_u32(\u0026mut self, val: u32) -\u003e Result\u003c(), EncodeError\u003e {\n        T::encode_u32(self, val)\n    }\n    fn encode_u64(\u0026mut self, val: u64) -\u003e Result\u003c(), EncodeError\u003e {\n        T::encode_u64(self, val)\n    }\n    fn encode_u128(\u0026mut self, val: u128) -\u003e Result\u003c(), EncodeError\u003e {\n        T::encode_u128(self, val)\n    }\n    fn encode_usize(\u0026mut self, val: usize) -\u003e Result\u003c(), EncodeError\u003e {\n        T::encode_usize(self, val)\n    }\n\n    fn encode_i8(\u0026mut self, val: i8) -\u003e Result\u003c(), EncodeError\u003e {\n        T::encode_i8(self, val)\n    }\n    fn encode_i16(\u0026mut self, val: i16) -\u003e Result\u003c(), EncodeError\u003e {\n        T::encode_i16(self, val)\n    }\n    fn encode_i32(\u0026mut self, val: i32) -\u003e Result\u003c(), EncodeError\u003e {\n        T::encode_i32(self, val)\n    }\n    fn encode_i64(\u0026mut self, val: i64) -\u003e Result\u003c(), EncodeError\u003e {\n        T::encode_i64(self, val)\n    }\n    fn encode_i128(\u0026mut self, val: i128) -\u003e Result\u003c(), EncodeError\u003e {\n        T::encode_i128(self, val)\n    }\n    fn encode_isize(\u0026mut self, val: isize) -\u003e Result\u003c(), EncodeError\u003e {\n        T::encode_isize(self, val)\n    }\n\n    fn encode_f32(\u0026mut self, val: f32) -\u003e Result\u003c(), EncodeError\u003e {\n        T::encode_f32(self, val)\n    }\n    fn encode_f64(\u0026mut self, val: f64) -\u003e Result\u003c(), EncodeError\u003e {\n        T::encode_f64(self, val)\n    }\n    fn encode_slice(\u0026mut self, val: \u0026[u8]) -\u003e Result\u003c(), EncodeError\u003e {\n        T::encode_slice(self, val)\n    }\n    fn encode_array\u003cconst N: usize\u003e(\u0026mut self, val: [u8; N]) -\u003e Result\u003c(), EncodeError\u003e {\n        T::encode_array(self, val)\n    }\n}\n","traces":[{"line":5,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":6,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":11,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":12,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":66},{"path":["/","home","trangar","development","rust","bincode","src","enc","mod.rs"],"content":"mod encoder;\nmod impls;\n\nuse crate::error::EncodeError;\n\npub mod write;\n\npub use self::encoder::Encoder;\n\npub trait Encodeable {\n    fn encode\u003cE: Encode\u003e(\u0026self, encoder: E) -\u003e Result\u003c(), EncodeError\u003e;\n}\n\npub trait Encode {\n    fn encode_u8(\u0026mut self, val: u8) -\u003e Result\u003c(), EncodeError\u003e;\n    fn encode_u16(\u0026mut self, val: u16) -\u003e Result\u003c(), EncodeError\u003e;\n    fn encode_u32(\u0026mut self, val: u32) -\u003e Result\u003c(), EncodeError\u003e;\n    fn encode_u64(\u0026mut self, val: u64) -\u003e Result\u003c(), EncodeError\u003e;\n    fn encode_u128(\u0026mut self, val: u128) -\u003e Result\u003c(), EncodeError\u003e;\n    fn encode_usize(\u0026mut self, val: usize) -\u003e Result\u003c(), EncodeError\u003e;\n\n    fn encode_i8(\u0026mut self, val: i8) -\u003e Result\u003c(), EncodeError\u003e;\n    fn encode_i16(\u0026mut self, val: i16) -\u003e Result\u003c(), EncodeError\u003e;\n    fn encode_i32(\u0026mut self, val: i32) -\u003e Result\u003c(), EncodeError\u003e;\n    fn encode_i64(\u0026mut self, val: i64) -\u003e Result\u003c(), EncodeError\u003e;\n    fn encode_i128(\u0026mut self, val: i128) -\u003e Result\u003c(), EncodeError\u003e;\n    fn encode_isize(\u0026mut self, val: isize) -\u003e Result\u003c(), EncodeError\u003e;\n\n    fn encode_f32(\u0026mut self, val: f32) -\u003e Result\u003c(), EncodeError\u003e;\n    fn encode_f64(\u0026mut self, val: f64) -\u003e Result\u003c(), EncodeError\u003e;\n    fn encode_slice(\u0026mut self, val: \u0026[u8]) -\u003e Result\u003c(), EncodeError\u003e;\n    fn encode_array\u003cconst N: usize\u003e(\u0026mut self, val: [u8; N]) -\u003e Result\u003c(), EncodeError\u003e;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","trangar","development","rust","bincode","src","enc","write.rs"],"content":"use crate::error::EncodeError;\n\npub trait Writer {\n    fn write(\u0026mut self, bytes: \u0026[u8]) -\u003e Result\u003c(), EncodeError\u003e;\n}\n\npub struct SliceWriter\u003c'storage\u003e {\n    slice: \u0026'storage mut [u8],\n    idx: usize,\n}\n\nimpl\u003c'storage\u003e SliceWriter\u003c'storage\u003e {\n    pub(crate) fn new(bytes: \u0026'storage mut [u8]) -\u003e SliceWriter\u003c'storage\u003e {\n        SliceWriter {\n            slice: bytes,\n            idx: 0,\n        }\n    }\n\n    pub(crate) fn bytes_written(\u0026self) -\u003e usize {\n        self.idx\n    }\n}\n\nimpl\u003c'storage\u003e Writer for SliceWriter\u003c'storage\u003e {\n    fn write(\u0026mut self, bytes: \u0026[u8]) -\u003e Result\u003c(), EncodeError\u003e {\n        let remaining = \u0026mut self.slice[self.idx..];\n        if bytes.len() \u003e remaining.len() {\n            return Err(EncodeError::UnexpectedEnd);\n        }\n        self.idx += bytes.len();\n        let write_slice = \u0026mut remaining[..bytes.len()];\n        write_slice.copy_from_slice(bytes);\n        Ok(())\n    }\n}\n","traces":[{"line":13,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":11},{"path":["/","home","trangar","development","rust","bincode","src","error.rs"],"content":"#[non_exhaustive]\n#[derive(Debug)]\npub enum EncodeError {\n    InvalidIntEncoding,\n    UnexpectedEnd,\n}\n\n#[non_exhaustive]\n#[derive(Debug)]\npub enum DecodeError {\n    UnexpectedEnd,\n    /// Invalid type was found. The decoder tried to read type `expected`, but found type `found` instead.\n    InvalidIntegerType {\n        /// The type that was being read from the reader\n        expected: IntegerType,\n        /// The type that was encoded in the data\n        found: IntegerType,\n    },\n    UnexpectedVariant {\n        min: u32,\n        max: u32,\n        found: u32,\n    },\n\n    Utf8(core::str::Utf8Error),\n}\n\n#[non_exhaustive]\n#[derive(Debug)]\npub enum IntegerType {\n    U16,\n    U32,\n    U64,\n    U128,\n    USize,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","trangar","development","rust","bincode","src","features","derive.rs"],"content":"pub use bincode_derive::Encodable; // Decodable,\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","trangar","development","rust","bincode","src","features","impl_alloc.rs"],"content":"\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","trangar","development","rust","bincode","src","features","impl_std.rs"],"content":"use crate::{\n    config::{self, Config},\n    de::{read::Reader, Decodable, Decoder},\n    error::DecodeError,\n};\n\npub fn decode_from\u003cD: Decodable, R: std::io::Read\u003e(src: \u0026mut R) -\u003e Result\u003cD, DecodeError\u003e {\n    decode_from_with_config(src, config::Default)\n}\n\npub fn decode_from_with_config\u003cD: Decodable, C: Config, R: std::io::Read\u003e(\n    src: \u0026mut R,\n    _config: C,\n) -\u003e Result\u003cD, DecodeError\u003e {\n    let mut decoder = Decoder::\u003c_, C\u003e::new(src, _config);\n    D::decode(\u0026mut decoder)\n}\n\nimpl\u003c'storage, R: std::io::Read\u003e Reader\u003c'storage\u003e for R {\n    #[inline(always)]\n    fn read(\u0026mut self, bytes: \u0026mut [u8]) -\u003e Result\u003c(), DecodeError\u003e {\n        match self.read_exact(bytes) {\n            Ok(_) =\u003e Ok(()),\n            Err(_) =\u003e Err(DecodeError::UnexpectedEnd),\n        }\n    }\n}\n","traces":[{"line":21,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":4},{"path":["/","home","trangar","development","rust","bincode","src","features","mod.rs"],"content":"#[cfg(feature = \"alloc\")]\nmod impl_alloc;\n#[cfg(feature = \"alloc\")]\npub use self::impl_alloc::*;\n\n#[cfg(feature = \"std\")]\nmod impl_std;\n#[cfg(feature = \"std\")]\npub use self::impl_std::*;\n\n#[cfg(feature = \"derive\")]\nmod derive;\n#[cfg(feature = \"derive\")]\npub use self::derive::*;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","trangar","development","rust","bincode","src","lib.rs"],"content":"#![no_std]\n\n//! Bincode is a crate for encoding and decoding using a tiny binary\n//! serialization strategy.  Using it, you can easily go from having\n//! an object in memory, quickly serialize it to bytes, and then\n//! deserialize it back just as fast!\n\n#![doc(html_root_url = \"https://docs.rs/bincode/2.0.0-dev\")]\n#![crate_name = \"bincode\"]\n#![crate_type = \"rlib\"]\n#![crate_type = \"dylib\"]\n\n#[cfg(feature = \"alloc\")]\nextern crate alloc;\n#[cfg(any(feature = \"std\", test))]\nextern crate std;\n\nmod features;\npub(crate) mod varint;\n\npub use features::*;\n\npub mod config;\npub mod de;\npub mod enc;\npub mod error;\n\nuse config::Config;\n\npub fn encode_into_slice\u003cE: enc::Encodeable\u003e(\n    val: E,\n    dst: \u0026mut [u8],\n) -\u003e Result\u003cusize, error::EncodeError\u003e {\n    encode_into_slice_with_config(val, dst, config::Default)\n}\n\npub fn encode_into_slice_with_config\u003cE: enc::Encodeable, C: Config\u003e(\n    val: E,\n    dst: \u0026mut [u8],\n    _config: C,\n) -\u003e Result\u003cusize, error::EncodeError\u003e {\n    let writer = enc::write::SliceWriter::new(dst);\n    let mut encoder = enc::Encoder::\u003c_, C\u003e::new(writer);\n    val.encode(\u0026mut encoder)?;\n    Ok(encoder.into_writer().bytes_written())\n}\n\npub fn decode\u003c'__de, D: de::BorrowDecodable\u003c'__de\u003e\u003e(\n    src: \u0026'__de mut [u8],\n) -\u003e Result\u003cD, error::DecodeError\u003e {\n    decode_with_config(src, config::Default)\n}\n\npub fn decode_with_config\u003c'__de, D: de::BorrowDecodable\u003c'__de\u003e, C: Config\u003e(\n    src: \u0026'__de mut [u8],\n    _config: C,\n) -\u003e Result\u003cD, error::DecodeError\u003e {\n    let reader = de::read::SliceReader::new(src);\n    let mut decoder = de::Decoder::\u003c_, C\u003e::new(reader, _config);\n    D::borrow_decode(\u0026mut decoder)\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","trangar","development","rust","bincode","src","varint","decode_signed.rs"],"content":"use crate::{config::Endian, de::read::Reader, error::DecodeError};\n\npub fn varint_decode_i16\u003c'a, R: Reader\u003c'a\u003e\u003e(\n    read: \u0026mut R,\n    endian: Endian,\n) -\u003e Result\u003ci16, DecodeError\u003e {\n    let n = super::varint_decode_u16(read, endian)?;\n    Ok(if n % 2 == 0 {\n        // positive number\n        (n / 2) as _\n    } else {\n        // negative number\n        // !m * 2 + 1 = n\n        // !m * 2 = n - 1\n        // !m = (n - 1) / 2\n        // m = !((n - 1) / 2)\n        // since we have n is odd, we have floor(n / 2) = floor((n - 1) / 2)\n        !(n / 2) as _\n    })\n}\n\npub fn varint_decode_i32\u003c'a, R: Reader\u003c'a\u003e\u003e(\n    read: \u0026mut R,\n    endian: Endian,\n) -\u003e Result\u003ci32, DecodeError\u003e {\n    let n = super::varint_decode_u32(read, endian)?;\n    Ok(if n % 2 == 0 {\n        // positive number\n        (n / 2) as _\n    } else {\n        // negative number\n        // !m * 2 + 1 = n\n        // !m * 2 = n - 1\n        // !m = (n - 1) / 2\n        // m = !((n - 1) / 2)\n        // since we have n is odd, we have floor(n / 2) = floor((n - 1) / 2)\n        !(n / 2) as _\n    })\n}\n\npub fn varint_decode_i64\u003c'a, R: Reader\u003c'a\u003e\u003e(\n    read: \u0026mut R,\n    endian: Endian,\n) -\u003e Result\u003ci64, DecodeError\u003e {\n    let n = super::varint_decode_u64(read, endian)?;\n    Ok(if n % 2 == 0 {\n        // positive number\n        (n / 2) as _\n    } else {\n        // negative number\n        // !m * 2 + 1 = n\n        // !m * 2 = n - 1\n        // !m = (n - 1) / 2\n        // m = !((n - 1) / 2)\n        // since we have n is odd, we have floor(n / 2) = floor((n - 1) / 2)\n        !(n / 2) as _\n    })\n}\n\npub fn varint_decode_i128\u003c'a, R: Reader\u003c'a\u003e\u003e(\n    read: \u0026mut R,\n    endian: Endian,\n) -\u003e Result\u003ci128, DecodeError\u003e {\n    let n = super::varint_decode_u128(read, endian)?;\n    Ok(if n % 2 == 0 {\n        // positive number\n        (n / 2) as _\n    } else {\n        // negative number\n        // !m * 2 + 1 = n\n        // !m * 2 = n - 1\n        // !m = (n - 1) / 2\n        // m = !((n - 1) / 2)\n        // since we have n is odd, we have floor(n / 2) = floor((n - 1) / 2)\n        !(n / 2) as _\n    })\n}\n\npub fn varint_decode_isize\u003c'a, R: Reader\u003c'a\u003e\u003e(\n    read: \u0026mut R,\n    endian: Endian,\n) -\u003e Result\u003cisize, DecodeError\u003e {\n    varint_decode_i64(read, endian).map(|v| v as isize)\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","trangar","development","rust","bincode","src","varint","decode_unsigned.rs"],"content":"use super::{U128_BYTE, U16_BYTE, U32_BYTE, U64_BYTE};\nuse crate::{\n    config::Endian,\n    de::read::Reader,\n    error::{DecodeError, IntegerType},\n};\n\npub fn varint_decode_u16\u003c'a, R: Reader\u003c'a\u003e\u003e(\n    read: \u0026mut R,\n    endian: Endian,\n) -\u003e Result\u003cu16, DecodeError\u003e {\n    let mut byte = [0u8; 1];\n    read.read(\u0026mut byte)?;\n    match byte[0] {\n        U16_BYTE =\u003e {\n            let mut bytes = [0u8; 2];\n            read.read(\u0026mut bytes)?;\n            Ok(match endian {\n                Endian::Big =\u003e u16::from_be_bytes(bytes),\n                Endian::Little =\u003e u16::from_le_bytes(bytes),\n            })\n        }\n        U32_BYTE =\u003e Err(DecodeError::InvalidIntegerType {\n            expected: IntegerType::U16,\n            found: IntegerType::U32,\n        }),\n        U64_BYTE =\u003e Err(DecodeError::InvalidIntegerType {\n            expected: IntegerType::U16,\n            found: IntegerType::U64,\n        }),\n        U128_BYTE =\u003e Err(DecodeError::InvalidIntegerType {\n            expected: IntegerType::U16,\n            found: IntegerType::U128,\n        }),\n        x =\u003e Ok(x as u16),\n    }\n}\n\npub fn varint_decode_u32\u003c'a, R: Reader\u003c'a\u003e\u003e(\n    read: \u0026mut R,\n    endian: Endian,\n) -\u003e Result\u003cu32, DecodeError\u003e {\n    let mut byte = [0u8; 1];\n    read.read(\u0026mut byte)?;\n    match byte[0] {\n        U16_BYTE =\u003e {\n            let mut bytes = [0u8; 2];\n            read.read(\u0026mut bytes)?;\n            Ok(match endian {\n                Endian::Big =\u003e u16::from_be_bytes(bytes) as u32,\n                Endian::Little =\u003e u16::from_le_bytes(bytes) as u32,\n            })\n        }\n        U32_BYTE =\u003e {\n            let mut bytes = [0u8; 4];\n            read.read(\u0026mut bytes)?;\n            Ok(match endian {\n                Endian::Big =\u003e u32::from_be_bytes(bytes),\n                Endian::Little =\u003e u32::from_le_bytes(bytes),\n            })\n        }\n        U64_BYTE =\u003e Err(DecodeError::InvalidIntegerType {\n            expected: IntegerType::U32,\n            found: IntegerType::U64,\n        }),\n        U128_BYTE =\u003e Err(DecodeError::InvalidIntegerType {\n            expected: IntegerType::U32,\n            found: IntegerType::U128,\n        }),\n        x =\u003e Ok(x as u32),\n    }\n}\n\npub fn varint_decode_u64\u003c'a, R: Reader\u003c'a\u003e\u003e(\n    read: \u0026mut R,\n    endian: Endian,\n) -\u003e Result\u003cu64, DecodeError\u003e {\n    let mut byte = [0u8; 1];\n    read.read(\u0026mut byte)?;\n    match byte[0] {\n        U16_BYTE =\u003e {\n            let mut bytes = [0u8; 2];\n            read.read(\u0026mut bytes)?;\n            Ok(match endian {\n                Endian::Big =\u003e u16::from_be_bytes(bytes) as u64,\n                Endian::Little =\u003e u16::from_le_bytes(bytes) as u64,\n            })\n        }\n        U32_BYTE =\u003e {\n            let mut bytes = [0u8; 4];\n            read.read(\u0026mut bytes)?;\n            Ok(match endian {\n                Endian::Big =\u003e u32::from_be_bytes(bytes) as u64,\n                Endian::Little =\u003e u32::from_le_bytes(bytes) as u64,\n            })\n        }\n        U64_BYTE =\u003e {\n            let mut bytes = [0u8; 8];\n            read.read(\u0026mut bytes)?;\n            Ok(match endian {\n                Endian::Big =\u003e u64::from_be_bytes(bytes),\n                Endian::Little =\u003e u64::from_le_bytes(bytes),\n            })\n        }\n        U128_BYTE =\u003e Err(DecodeError::InvalidIntegerType {\n            expected: IntegerType::U64,\n            found: IntegerType::U128,\n        }),\n        x =\u003e Ok(x as u64),\n    }\n}\n\npub fn varint_decode_usize\u003c'a, R: Reader\u003c'a\u003e\u003e(\n    read: \u0026mut R,\n    endian: Endian,\n) -\u003e Result\u003cusize, DecodeError\u003e {\n    let mut byte = [0u8; 1];\n    read.read(\u0026mut byte)?;\n    match byte[0] {\n        U16_BYTE =\u003e {\n            let mut bytes = [0u8; 2];\n            read.read(\u0026mut bytes)?;\n            Ok(match endian {\n                Endian::Big =\u003e u16::from_be_bytes(bytes) as usize,\n                Endian::Little =\u003e u16::from_le_bytes(bytes) as usize,\n            })\n        }\n        U32_BYTE =\u003e {\n            let mut bytes = [0u8; 4];\n            read.read(\u0026mut bytes)?;\n            Ok(match endian {\n                Endian::Big =\u003e u32::from_be_bytes(bytes) as usize,\n                Endian::Little =\u003e u32::from_le_bytes(bytes) as usize,\n            })\n        }\n        U64_BYTE =\u003e {\n            let mut bytes = [0u8; 8];\n            read.read(\u0026mut bytes)?;\n            Ok(match endian {\n                Endian::Big =\u003e u64::from_be_bytes(bytes) as usize,\n                Endian::Little =\u003e u64::from_le_bytes(bytes) as usize,\n            })\n        }\n        U128_BYTE =\u003e Err(DecodeError::InvalidIntegerType {\n            expected: IntegerType::USize,\n            found: IntegerType::U128,\n        }),\n        x =\u003e Ok(x as usize),\n    }\n}\n\npub fn varint_decode_u128\u003c'a, R: Reader\u003c'a\u003e\u003e(\n    read: \u0026mut R,\n    endian: Endian,\n) -\u003e Result\u003cu128, DecodeError\u003e {\n    let mut byte = [0u8; 1];\n    read.read(\u0026mut byte)?;\n    match byte[0] {\n        U16_BYTE =\u003e {\n            let mut bytes = [0u8; 2];\n            read.read(\u0026mut bytes)?;\n            Ok(match endian {\n                Endian::Big =\u003e u16::from_be_bytes(bytes) as u128,\n                Endian::Little =\u003e u16::from_le_bytes(bytes) as u128,\n            })\n        }\n        U32_BYTE =\u003e {\n            let mut bytes = [0u8; 4];\n            read.read(\u0026mut bytes)?;\n            Ok(match endian {\n                Endian::Big =\u003e u32::from_be_bytes(bytes) as u128,\n                Endian::Little =\u003e u32::from_le_bytes(bytes) as u128,\n            })\n        }\n        U64_BYTE =\u003e {\n            let mut bytes = [0u8; 8];\n            read.read(\u0026mut bytes)?;\n            Ok(match endian {\n                Endian::Big =\u003e u64::from_be_bytes(bytes) as u128,\n                Endian::Little =\u003e u64::from_le_bytes(bytes) as u128,\n            })\n        }\n        U128_BYTE =\u003e {\n            let mut bytes = [0u8; 16];\n            read.read(\u0026mut bytes)?;\n            Ok(match endian {\n                Endian::Big =\u003e u128::from_be_bytes(bytes),\n                Endian::Little =\u003e u128::from_le_bytes(bytes),\n            })\n        }\n        x =\u003e Ok(x as u128),\n    }\n}\n\n#[test]\nfn test_decode_u16() {\n    let cases: \u0026[(\u0026[u8], u16, u16)] = \u0026[\n        (\u0026[0], 0, 0),\n        (\u0026[10], 10, 10),\n        (\u0026[U16_BYTE, 0, 10], 2560, 10),\n    ];\n    for \u0026(slice, expected_le, expected_be) in cases {\n        let mut reader = crate::de::read::SliceReader::new(slice);\n        let found = varint_decode_u16(\u0026mut reader, Endian::Little).unwrap();\n        assert_eq!(expected_le, found);\n\n        let mut reader = crate::de::read::SliceReader::new(slice);\n        let found = varint_decode_u16(\u0026mut reader, Endian::Big).unwrap();\n        assert_eq!(expected_be, found);\n    }\n\n    let errors: \u0026[(\u0026[u8], DecodeError)] = \u0026[\n        (\n            \u0026[U32_BYTE],\n            DecodeError::InvalidIntegerType {\n                expected: IntegerType::U16,\n                found: IntegerType::U32,\n            },\n        ),\n        (\n            \u0026[U64_BYTE],\n            DecodeError::InvalidIntegerType {\n                expected: IntegerType::U16,\n                found: IntegerType::U64,\n            },\n        ),\n        (\n            \u0026[U128_BYTE],\n            DecodeError::InvalidIntegerType {\n                expected: IntegerType::U16,\n                found: IntegerType::U128,\n            },\n        ),\n        (\u0026[U16_BYTE], DecodeError::UnexpectedEnd),\n        (\u0026[U16_BYTE, 0], DecodeError::UnexpectedEnd),\n    ];\n\n    for (slice, expected) in errors {\n        let mut reader = crate::de::read::SliceReader::new(slice);\n        let found = varint_decode_u16(\u0026mut reader, Endian::Little).unwrap_err();\n        assert_eq!(std::format!(\"{:?}\", expected), std::format!(\"{:?}\", found));\n    }\n}\n\n#[test]\nfn test_decode_u32() {\n    let cases: \u0026[(\u0026[u8], u32, u32)] = \u0026[\n        (\u0026[0], 0, 0),\n        (\u0026[10], 10, 10),\n        (\u0026[U16_BYTE, 0, 10], 2560, 10),\n        (\u0026[U32_BYTE, 0, 0, 0, 10], 167_772_160, 10),\n    ];\n    for \u0026(slice, expected_le, expected_be) in cases {\n        let mut reader = crate::de::read::SliceReader::new(slice);\n        let found = varint_decode_u32(\u0026mut reader, Endian::Little).unwrap();\n        assert_eq!(expected_le, found);\n\n        let mut reader = crate::de::read::SliceReader::new(slice);\n        let found = varint_decode_u32(\u0026mut reader, Endian::Big).unwrap();\n        assert_eq!(expected_be, found);\n    }\n\n    let errors: \u0026[(\u0026[u8], DecodeError)] = \u0026[\n        (\n            \u0026[U64_BYTE],\n            DecodeError::InvalidIntegerType {\n                expected: IntegerType::U32,\n                found: IntegerType::U64,\n            },\n        ),\n        (\n            \u0026[U128_BYTE],\n            DecodeError::InvalidIntegerType {\n                expected: IntegerType::U32,\n                found: IntegerType::U128,\n            },\n        ),\n        (\u0026[U16_BYTE], DecodeError::UnexpectedEnd),\n        (\u0026[U16_BYTE, 0], DecodeError::UnexpectedEnd),\n        (\u0026[U32_BYTE], DecodeError::UnexpectedEnd),\n        (\u0026[U32_BYTE, 0], DecodeError::UnexpectedEnd),\n        (\u0026[U32_BYTE, 0, 0], DecodeError::UnexpectedEnd),\n        (\u0026[U32_BYTE, 0, 0, 0], DecodeError::UnexpectedEnd),\n    ];\n\n    for (slice, expected) in errors {\n        let mut reader = crate::de::read::SliceReader::new(slice);\n        let found = varint_decode_u32(\u0026mut reader, Endian::Little).unwrap_err();\n        assert_eq!(std::format!(\"{:?}\", expected), std::format!(\"{:?}\", found));\n    }\n}\n\n#[test]\nfn test_decode_u64() {\n    let cases: \u0026[(\u0026[u8], u64, u64)] = \u0026[\n        (\u0026[0], 0, 0),\n        (\u0026[10], 10, 10),\n        (\u0026[U16_BYTE, 0, 10], 2560, 10),\n        (\u0026[U32_BYTE, 0, 0, 0, 10], 167_772_160, 10),\n        (\n            \u0026[U64_BYTE, 0, 0, 0, 0, 0, 0, 0, 10],\n            72_057_594_037_9279_360,\n            10,\n        ),\n    ];\n    for \u0026(slice, expected_le, expected_be) in cases {\n        let mut reader = crate::de::read::SliceReader::new(slice);\n        let found = varint_decode_u64(\u0026mut reader, Endian::Little).unwrap();\n        assert_eq!(expected_le, found);\n\n        let mut reader = crate::de::read::SliceReader::new(slice);\n        let found = varint_decode_u64(\u0026mut reader, Endian::Big).unwrap();\n        assert_eq!(expected_be, found);\n    }\n\n    let errors: \u0026[(\u0026[u8], DecodeError)] = \u0026[\n        (\n            \u0026[U128_BYTE],\n            DecodeError::InvalidIntegerType {\n                expected: IntegerType::U64,\n                found: IntegerType::U128,\n            },\n        ),\n        (\u0026[U16_BYTE], DecodeError::UnexpectedEnd),\n        (\u0026[U16_BYTE, 0], DecodeError::UnexpectedEnd),\n        (\u0026[U32_BYTE], DecodeError::UnexpectedEnd),\n        (\u0026[U32_BYTE, 0], DecodeError::UnexpectedEnd),\n        (\u0026[U32_BYTE, 0, 0], DecodeError::UnexpectedEnd),\n        (\u0026[U32_BYTE, 0, 0, 0], DecodeError::UnexpectedEnd),\n        (\u0026[U64_BYTE], DecodeError::UnexpectedEnd),\n        (\u0026[U64_BYTE, 0], DecodeError::UnexpectedEnd),\n        (\u0026[U64_BYTE, 0, 0], DecodeError::UnexpectedEnd),\n        (\u0026[U64_BYTE, 0, 0, 0], DecodeError::UnexpectedEnd),\n        (\u0026[U64_BYTE, 0, 0, 0, 0], DecodeError::UnexpectedEnd),\n        (\u0026[U64_BYTE, 0, 0, 0, 0, 0], DecodeError::UnexpectedEnd),\n        (\u0026[U64_BYTE, 0, 0, 0, 0, 0, 0], DecodeError::UnexpectedEnd),\n        (\u0026[U64_BYTE, 0, 0, 0, 0, 0, 0, 0], DecodeError::UnexpectedEnd),\n    ];\n\n    for (slice, expected) in errors {\n        let mut reader = crate::de::read::SliceReader::new(slice);\n        let found = varint_decode_u64(\u0026mut reader, Endian::Little).unwrap_err();\n        assert_eq!(std::format!(\"{:?}\", expected), std::format!(\"{:?}\", found));\n    }\n}\n\n#[test]\nfn test_decode_u128() {\n    let cases: \u0026[(\u0026[u8], u128, u128)] = \u0026[\n        (\u0026[0], 0, 0),\n        (\u0026[10], 10, 10),\n        (\u0026[U16_BYTE, 0, 10], 2560, 10),\n        (\u0026[U32_BYTE, 0, 0, 0, 10], 167_772_160, 10),\n        (\n            \u0026[U64_BYTE, 0, 0, 0, 0, 0, 0, 0, 10],\n            72_057_594_037_9279_360,\n            10,\n        ),\n        (\n            \u0026[U128_BYTE, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10],\n            13_292_279_957_849_158_729_038_070_602_803_445_760,\n            10,\n        ),\n    ];\n    for \u0026(slice, expected_le, expected_be) in cases {\n        let mut reader = crate::de::read::SliceReader::new(slice);\n        let found = varint_decode_u128(\u0026mut reader, Endian::Little).unwrap();\n        assert_eq!(expected_le, found);\n\n        let mut reader = crate::de::read::SliceReader::new(slice);\n        let found = varint_decode_u128(\u0026mut reader, Endian::Big).unwrap();\n        assert_eq!(expected_be, found);\n    }\n\n    let errors: \u0026[(\u0026[u8], DecodeError)] = \u0026[\n        (\u0026[U16_BYTE], DecodeError::UnexpectedEnd),\n        (\u0026[U16_BYTE, 0], DecodeError::UnexpectedEnd),\n        (\u0026[U32_BYTE], DecodeError::UnexpectedEnd),\n        (\u0026[U32_BYTE, 0], DecodeError::UnexpectedEnd),\n        (\u0026[U32_BYTE, 0, 0], DecodeError::UnexpectedEnd),\n        (\u0026[U32_BYTE, 0, 0, 0], DecodeError::UnexpectedEnd),\n        (\u0026[U64_BYTE], DecodeError::UnexpectedEnd),\n        (\u0026[U64_BYTE, 0], DecodeError::UnexpectedEnd),\n        (\u0026[U64_BYTE, 0, 0], DecodeError::UnexpectedEnd),\n        (\u0026[U64_BYTE, 0, 0, 0], DecodeError::UnexpectedEnd),\n        (\u0026[U64_BYTE, 0, 0, 0, 0], DecodeError::UnexpectedEnd),\n        (\u0026[U64_BYTE, 0, 0, 0, 0, 0], DecodeError::UnexpectedEnd),\n        (\u0026[U64_BYTE, 0, 0, 0, 0, 0, 0], DecodeError::UnexpectedEnd),\n        (\u0026[U64_BYTE, 0, 0, 0, 0, 0, 0, 0], DecodeError::UnexpectedEnd),\n        (\u0026[U128_BYTE], DecodeError::UnexpectedEnd),\n        (\u0026[U128_BYTE, 0], DecodeError::UnexpectedEnd),\n        (\u0026[U128_BYTE, 0, 0], DecodeError::UnexpectedEnd),\n        (\u0026[U128_BYTE, 0, 0, 0], DecodeError::UnexpectedEnd),\n        (\u0026[U128_BYTE, 0, 0, 0, 0], DecodeError::UnexpectedEnd),\n        (\u0026[U128_BYTE, 0, 0, 0, 0, 0], DecodeError::UnexpectedEnd),\n        (\u0026[U128_BYTE, 0, 0, 0, 0, 0, 0], DecodeError::UnexpectedEnd),\n        (\n            \u0026[U128_BYTE, 0, 0, 0, 0, 0, 0, 0],\n            DecodeError::UnexpectedEnd,\n        ),\n        (\n            \u0026[U128_BYTE, 0, 0, 0, 0, 0, 0, 0, 0],\n            DecodeError::UnexpectedEnd,\n        ),\n        (\n            \u0026[U128_BYTE, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n            DecodeError::UnexpectedEnd,\n        ),\n        (\n            \u0026[U128_BYTE, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n            DecodeError::UnexpectedEnd,\n        ),\n        (\n            \u0026[U128_BYTE, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n            DecodeError::UnexpectedEnd,\n        ),\n        (\n            \u0026[U128_BYTE, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n            DecodeError::UnexpectedEnd,\n        ),\n        (\n            \u0026[U128_BYTE, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n            DecodeError::UnexpectedEnd,\n        ),\n        (\n            \u0026[U128_BYTE, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n            DecodeError::UnexpectedEnd,\n        ),\n    ];\n\n    for (slice, expected) in errors {\n        let mut reader = crate::de::read::SliceReader::new(slice);\n        let found = varint_decode_u128(\u0026mut reader, Endian::Little).unwrap_err();\n        std::dbg!(slice);\n        assert_eq!(std::format!(\"{:?}\", expected), std::format!(\"{:?}\", found));\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","trangar","development","rust","bincode","src","varint","encode_signed.rs"],"content":"use super::{varint_encode_u128, varint_encode_u16, varint_encode_u32, varint_encode_u64};\nuse crate::{config::Endian, enc::write::Writer, error::EncodeError};\n\npub fn varint_encode_i16\u003cW: Writer\u003e(\n    writer: \u0026mut W,\n    endian: Endian,\n    val: i16,\n) -\u003e Result\u003c(), EncodeError\u003e {\n    varint_encode_u16(\n        writer,\n        endian,\n        if val \u003c 0 {\n            // let's avoid the edge case of i16::min_value()\n            // !n is equal to `-n - 1`, so this is:\n            // !n * 2 + 1 = 2(-n - 1) + 1 = -2n - 2 + 1 = -2n - 1\n            !(val as u16) * 2 + 1\n        } else {\n            (val as u16) * 2\n        },\n    )\n}\n\npub fn varint_encode_i32\u003cW: Writer\u003e(\n    writer: \u0026mut W,\n    endian: Endian,\n    val: i32,\n) -\u003e Result\u003c(), EncodeError\u003e {\n    varint_encode_u32(\n        writer,\n        endian,\n        if val \u003c 0 {\n            // let's avoid the edge case of i32::min_value()\n            // !n is equal to `-n - 1`, so this is:\n            // !n * 2 + 1 = 2(-n - 1) + 1 = -2n - 2 + 1 = -2n - 1\n            !(val as u32) * 2 + 1\n        } else {\n            (val as u32) * 2\n        },\n    )\n}\n\npub fn varint_encode_i64\u003cW: Writer\u003e(\n    writer: \u0026mut W,\n    endian: Endian,\n    val: i64,\n) -\u003e Result\u003c(), EncodeError\u003e {\n    varint_encode_u64(\n        writer,\n        endian,\n        if val \u003c 0 {\n            // let's avoid the edge case of i64::min_value()\n            // !n is equal to `-n - 1`, so this is:\n            // !n * 2 + 1 = 2(-n - 1) + 1 = -2n - 2 + 1 = -2n - 1\n            !(val as u64) * 2 + 1\n        } else {\n            (val as u64) * 2\n        },\n    )\n}\n\npub fn varint_encode_i128\u003cW: Writer\u003e(\n    writer: \u0026mut W,\n    endian: Endian,\n    val: i128,\n) -\u003e Result\u003c(), EncodeError\u003e {\n    varint_encode_u128(\n        writer,\n        endian,\n        if val \u003c 0 {\n            // let's avoid the edge case of i128::min_value()\n            // !n is equal to `-n - 1`, so this is:\n            // !n * 2 + 1 = 2(-n - 1) + 1 = -2n - 2 + 1 = -2n - 1\n            !(val as u128) * 2 + 1\n        } else {\n            (val as u128) * 2\n        },\n    )\n}\n\npub fn varint_encode_isize\u003cW: Writer\u003e(\n    writer: \u0026mut W,\n    endian: Endian,\n    val: isize,\n) -\u003e Result\u003c(), EncodeError\u003e {\n    // isize is being encoded as a i64\n    varint_encode_i64(writer, endian, val as i64)\n}\n\n#[test]\nfn test_encode_i16() {\n    let cases: \u0026[(i16, \u0026[u8], \u0026[u8])] = \u0026[\n        (0, \u0026[0], \u0026[0]),\n        (2, \u0026[4], \u0026[4]),\n        (256, \u0026[super::U16_BYTE, 0, 2], \u0026[super::U16_BYTE, 2, 0]),\n        (\n            16_000,\n            \u0026[super::U16_BYTE, 0, 125],\n            \u0026[super::U16_BYTE, 125, 0],\n        ),\n        (\n            i16::MAX - 1,\n            \u0026[super::U16_BYTE, 252, 255],\n            \u0026[super::U16_BYTE, 255, 252],\n        ),\n        (\n            i16::MAX,\n            \u0026[super::U16_BYTE, 254, 255],\n            \u0026[super::U16_BYTE, 255, 254],\n        ),\n    ];\n\n    use crate::enc::write::SliceWriter;\n    let mut buffer = [0u8; 20];\n    for \u0026(value, expected_le, expected_be) in cases {\n        std::dbg!(value);\n\n        // Little endian\n        let mut writer = SliceWriter::new(\u0026mut buffer);\n        varint_encode_i16(\u0026mut writer, Endian::Little, value).unwrap();\n\n        assert_eq!(writer.bytes_written(), expected_le.len());\n        assert_eq!(\u0026buffer[..expected_le.len()], expected_le);\n\n        // Big endian\n        let mut writer = SliceWriter::new(\u0026mut buffer);\n        varint_encode_i16(\u0026mut writer, Endian::Big, value).unwrap();\n\n        assert_eq!(writer.bytes_written(), expected_be.len());\n        assert_eq!(\u0026buffer[..expected_be.len()], expected_be);\n    }\n}\n\n#[test]\nfn test_encode_i32() {\n    let cases: \u0026[(i32, \u0026[u8], \u0026[u8])] = \u0026[\n        (0, \u0026[0], \u0026[0]),\n        (2, \u0026[4], \u0026[4]),\n        (256, \u0026[super::U16_BYTE, 0, 2], \u0026[super::U16_BYTE, 2, 0]),\n        (\n            16_000,\n            \u0026[super::U16_BYTE, 0, 125],\n            \u0026[super::U16_BYTE, 125, 0],\n        ),\n        (\n            40_000,\n            \u0026[super::U32_BYTE, 128, 56, 1, 0],\n            \u0026[super::U32_BYTE, 0, 1, 56, 128],\n        ),\n        (\n            i32::MAX - 1,\n            \u0026[super::U32_BYTE, 252, 255, 255, 255],\n            \u0026[super::U32_BYTE, 255, 255, 255, 252],\n        ),\n        (\n            i32::MAX,\n            \u0026[super::U32_BYTE, 254, 255, 255, 255],\n            \u0026[super::U32_BYTE, 255, 255, 255, 254],\n        ),\n    ];\n\n    use crate::enc::write::SliceWriter;\n    let mut buffer = [0u8; 20];\n    for \u0026(value, expected_le, expected_be) in cases {\n        std::dbg!(value);\n\n        // Little endian\n        let mut writer = SliceWriter::new(\u0026mut buffer);\n        varint_encode_i32(\u0026mut writer, Endian::Little, value).unwrap();\n\n        assert_eq!(writer.bytes_written(), expected_le.len());\n        assert_eq!(\u0026buffer[..expected_le.len()], expected_le);\n\n        // Big endian\n        let mut writer = SliceWriter::new(\u0026mut buffer);\n        varint_encode_i32(\u0026mut writer, Endian::Big, value).unwrap();\n\n        assert_eq!(writer.bytes_written(), expected_be.len());\n        assert_eq!(\u0026buffer[..expected_be.len()], expected_be);\n    }\n}\n\n#[test]\nfn test_encode_i64() {\n    let cases: \u0026[(i64, \u0026[u8], \u0026[u8])] = \u0026[\n        (0, \u0026[0], \u0026[0]),\n        (2, \u0026[4], \u0026[4]),\n        (256, \u0026[super::U16_BYTE, 0, 2], \u0026[super::U16_BYTE, 2, 0]),\n        (\n            16_000,\n            \u0026[super::U16_BYTE, 0, 125],\n            \u0026[super::U16_BYTE, 125, 0],\n        ),\n        (\n            40_000,\n            \u0026[super::U32_BYTE, 128, 56, 1, 0],\n            \u0026[super::U32_BYTE, 0, 1, 56, 128],\n        ),\n        (\n            3_000_000_000,\n            \u0026[super::U64_BYTE, 0, 188, 160, 101, 1, 0, 0, 0],\n            \u0026[super::U64_BYTE, 0, 0, 0, 1, 101, 160, 188, 0],\n        ),\n        (\n            i64::MAX - 1,\n            \u0026[super::U64_BYTE, 252, 255, 255, 255, 255, 255, 255, 255],\n            \u0026[super::U64_BYTE, 255, 255, 255, 255, 255, 255, 255, 252],\n        ),\n        (\n            i64::MAX,\n            \u0026[super::U64_BYTE, 254, 255, 255, 255, 255, 255, 255, 255],\n            \u0026[super::U64_BYTE, 255, 255, 255, 255, 255, 255, 255, 254],\n        ),\n    ];\n\n    use crate::enc::write::SliceWriter;\n    let mut buffer = [0u8; 20];\n    for \u0026(value, expected_le, expected_be) in cases {\n        std::dbg!(value);\n\n        // Little endian\n        let mut writer = SliceWriter::new(\u0026mut buffer);\n        varint_encode_i64(\u0026mut writer, Endian::Little, value).unwrap();\n\n        assert_eq!(writer.bytes_written(), expected_le.len());\n        assert_eq!(\u0026buffer[..expected_le.len()], expected_le);\n\n        // Big endian\n        let mut writer = SliceWriter::new(\u0026mut buffer);\n        varint_encode_i64(\u0026mut writer, Endian::Big, value).unwrap();\n\n        assert_eq!(writer.bytes_written(), expected_be.len());\n        assert_eq!(\u0026buffer[..expected_be.len()], expected_be);\n    }\n}\n\n#[test]\nfn test_encode_i128() {\n    #[rustfmt::skip]\n    let cases: \u0026[(i128, \u0026[u8], \u0026[u8])] = \u0026[\n        (0, \u0026[0], \u0026[0]),\n        (2, \u0026[4], \u0026[4]),\n        (256, \u0026[super::U16_BYTE, 0, 2], \u0026[super::U16_BYTE, 2, 0]),\n        (\n            16_000,\n            \u0026[super::U16_BYTE, 0, 125],\n            \u0026[super::U16_BYTE, 125, 0],\n        ),\n        (\n            40_000,\n            \u0026[super::U32_BYTE, 128, 56, 1, 0],\n            \u0026[super::U32_BYTE, 0, 1, 56, 128],\n        ),\n        (\n            3_000_000_000,\n            \u0026[super::U64_BYTE, 0, 188, 160, 101, 1, 0, 0, 0],\n            \u0026[super::U64_BYTE, 0, 0, 0, 1, 101, 160, 188, 0],\n        ),\n        (\n            11_000_000_000_000_000_000,\n            \u0026[\n                super::U128_BYTE,\n                0, 0, 152, 98, 112, 179, 79, 49,\n                1, 0, 0, 0, 0, 0, 0, 0,\n            ],\n            \u0026[\n                super::U128_BYTE,\n                0, 0, 0, 0, 0, 0, 0, 1,\n                49, 79, 179, 112, 98, 152, 0, 0,\n            ],\n        ),\n        (\n            i128::MAX - 1,\n            \u0026[\n                super::U128_BYTE,\n                252, 255, 255, 255, 255, 255, 255, 255,\n                255, 255, 255, 255, 255, 255, 255, 255,\n            ],\n            \u0026[\n                super::U128_BYTE,\n                255, 255, 255, 255, 255, 255, 255, 255,\n                255, 255, 255, 255, 255, 255, 255, 252,\n            ],\n        ),\n        (\n            i128::MAX,\n            \u0026[\n                super::U128_BYTE,\n                254, 255, 255, 255, 255, 255, 255, 255,\n                255, 255, 255, 255, 255, 255, 255, 255,\n            ],\n            \u0026[\n                super::U128_BYTE,\n                255, 255, 255, 255, 255, 255, 255, 255,\n                255, 255, 255, 255, 255, 255, 255, 254,\n            ],\n        ),\n    ];\n\n    use crate::enc::write::SliceWriter;\n    let mut buffer = [0u8; 20];\n    for \u0026(value, expected_le, expected_be) in cases {\n        std::dbg!(value);\n\n        // Little endian\n        let mut writer = SliceWriter::new(\u0026mut buffer);\n        varint_encode_i128(\u0026mut writer, Endian::Little, value).unwrap();\n\n        assert_eq!(writer.bytes_written(), expected_le.len());\n        assert_eq!(\u0026buffer[..expected_le.len()], expected_le);\n\n        // Big endian\n        let mut writer = SliceWriter::new(\u0026mut buffer);\n        varint_encode_i128(\u0026mut writer, Endian::Big, value).unwrap();\n\n        assert_eq!(writer.bytes_written(), expected_be.len());\n        assert_eq!(\u0026buffer[..expected_be.len()], expected_be);\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","trangar","development","rust","bincode","src","varint","encode_unsigned.rs"],"content":"use super::{SINGLE_BYTE_MAX, U128_BYTE, U16_BYTE, U32_BYTE, U64_BYTE};\nuse crate::{config::Endian, enc::write::Writer, error::EncodeError};\n\npub fn varint_encode_u16\u003cW: Writer\u003e(\n    writer: \u0026mut W,\n    endian: Endian,\n    val: u16,\n) -\u003e Result\u003c(), EncodeError\u003e {\n    if val \u003c= SINGLE_BYTE_MAX as _ {\n        writer.write(\u0026[val as u8])\n    } else {\n        writer.write(\u0026[U16_BYTE])?;\n        match endian {\n            Endian::Big =\u003e writer.write(\u0026val.to_be_bytes()),\n            Endian::Little =\u003e writer.write(\u0026val.to_le_bytes()),\n        }\n    }\n}\n\npub fn varint_encode_u32\u003cW: Writer\u003e(\n    writer: \u0026mut W,\n    endian: Endian,\n    val: u32,\n) -\u003e Result\u003c(), EncodeError\u003e {\n    if val \u003c= SINGLE_BYTE_MAX as _ {\n        writer.write(\u0026[val as u8])\n    } else if val \u003c= u16::MAX as _ {\n        writer.write(\u0026[U16_BYTE])?;\n        match endian {\n            Endian::Big =\u003e writer.write(\u0026(val as u16).to_be_bytes()),\n            Endian::Little =\u003e writer.write(\u0026(val as u16).to_le_bytes()),\n        }\n    } else {\n        writer.write(\u0026[U32_BYTE])?;\n        match endian {\n            Endian::Big =\u003e writer.write(\u0026val.to_be_bytes()),\n            Endian::Little =\u003e writer.write(\u0026val.to_le_bytes()),\n        }\n    }\n}\n\npub fn varint_encode_u64\u003cW: Writer\u003e(\n    writer: \u0026mut W,\n    endian: Endian,\n    val: u64,\n) -\u003e Result\u003c(), EncodeError\u003e {\n    if val \u003c= SINGLE_BYTE_MAX as _ {\n        writer.write(\u0026[val as u8])\n    } else if val \u003c= u16::MAX as _ {\n        writer.write(\u0026[U16_BYTE])?;\n        match endian {\n            Endian::Big =\u003e writer.write(\u0026(val as u16).to_be_bytes()),\n            Endian::Little =\u003e writer.write(\u0026(val as u16).to_le_bytes()),\n        }\n    } else if val \u003c= u32::MAX as _ {\n        writer.write(\u0026[U32_BYTE])?;\n        match endian {\n            Endian::Big =\u003e writer.write(\u0026(val as u32).to_be_bytes()),\n            Endian::Little =\u003e writer.write(\u0026(val as u32).to_le_bytes()),\n        }\n    } else {\n        writer.write(\u0026[U64_BYTE])?;\n        match endian {\n            Endian::Big =\u003e writer.write(\u0026val.to_be_bytes()),\n            Endian::Little =\u003e writer.write(\u0026val.to_le_bytes()),\n        }\n    }\n}\n\npub fn varint_encode_u128\u003cW: Writer\u003e(\n    writer: \u0026mut W,\n    endian: Endian,\n    val: u128,\n) -\u003e Result\u003c(), EncodeError\u003e {\n    if val \u003c= SINGLE_BYTE_MAX as _ {\n        writer.write(\u0026[val as u8])\n    } else if val \u003c= u16::MAX as _ {\n        writer.write(\u0026[U16_BYTE])?;\n        match endian {\n            Endian::Big =\u003e writer.write(\u0026(val as u16).to_be_bytes()),\n            Endian::Little =\u003e writer.write(\u0026(val as u16).to_le_bytes()),\n        }\n    } else if val \u003c= u32::MAX as _ {\n        writer.write(\u0026[U32_BYTE])?;\n        match endian {\n            Endian::Big =\u003e writer.write(\u0026(val as u32).to_be_bytes()),\n            Endian::Little =\u003e writer.write(\u0026(val as u32).to_le_bytes()),\n        }\n    } else if val \u003c= u64::MAX as _ {\n        writer.write(\u0026[U64_BYTE])?;\n        match endian {\n            Endian::Big =\u003e writer.write(\u0026(val as u64).to_be_bytes()),\n            Endian::Little =\u003e writer.write(\u0026(val as u64).to_le_bytes()),\n        }\n    } else {\n        writer.write(\u0026[U128_BYTE])?;\n        match endian {\n            Endian::Big =\u003e writer.write(\u0026val.to_be_bytes()),\n            Endian::Little =\u003e writer.write(\u0026val.to_le_bytes()),\n        }\n    }\n}\n\npub fn varint_encode_usize\u003cW: Writer\u003e(\n    writer: \u0026mut W,\n    endian: Endian,\n    val: usize,\n) -\u003e Result\u003c(), EncodeError\u003e {\n    // usize is being encoded as a u64\n    varint_encode_u64(writer, endian, val as u64)\n}\n\n#[test]\nfn test_encode_u16() {\n    use crate::enc::write::SliceWriter;\n    let mut buffer = [0u8; 20];\n\n    // these should all encode to a single byte\n    for i in 0u16..=SINGLE_BYTE_MAX as u16 {\n        let mut writer = SliceWriter::new(\u0026mut buffer);\n        varint_encode_u16(\u0026mut writer, Endian::Big, i).unwrap();\n        assert_eq!(writer.bytes_written(), 1);\n        assert_eq!(buffer[0] as u16, i);\n\n        // Assert endianness doesn't matter\n        let mut writer = SliceWriter::new(\u0026mut buffer);\n        varint_encode_u16(\u0026mut writer, Endian::Little, i).unwrap();\n        assert_eq!(writer.bytes_written(), 1);\n        assert_eq!(buffer[0] as u16, i);\n    }\n\n    // these values should encode in 3 bytes (leading byte + 2 bytes)\n    // Values chosen at random, add new cases as needed\n    for i in [\n        SINGLE_BYTE_MAX as u16 + 1,\n        300,\n        500,\n        700,\n        888,\n        1234,\n        u16::MAX,\n    ] {\n        let mut writer = SliceWriter::new(\u0026mut buffer);\n        varint_encode_u16(\u0026mut writer, Endian::Big, i).unwrap();\n        assert_eq!(writer.bytes_written(), 3);\n        assert_eq!(buffer[0], U16_BYTE);\n        assert_eq!(\u0026buffer[1..3], \u0026i.to_be_bytes());\n\n        let mut writer = SliceWriter::new(\u0026mut buffer);\n        varint_encode_u16(\u0026mut writer, Endian::Little, i).unwrap();\n        assert_eq!(writer.bytes_written(), 3);\n        assert_eq!(buffer[0], U16_BYTE);\n        assert_eq!(\u0026buffer[1..3], \u0026i.to_le_bytes());\n    }\n}\n\n#[test]\nfn test_encode_u32() {\n    use crate::enc::write::SliceWriter;\n    let mut buffer = [0u8; 20];\n\n    // these should all encode to a single byte\n    for i in 0u32..=SINGLE_BYTE_MAX as u32 {\n        let mut writer = SliceWriter::new(\u0026mut buffer);\n        varint_encode_u32(\u0026mut writer, Endian::Big, i).unwrap();\n        assert_eq!(writer.bytes_written(), 1);\n        assert_eq!(buffer[0] as u32, i);\n\n        // Assert endianness doesn't matter\n        let mut writer = SliceWriter::new(\u0026mut buffer);\n        varint_encode_u32(\u0026mut writer, Endian::Little, i).unwrap();\n        assert_eq!(writer.bytes_written(), 1);\n        assert_eq!(buffer[0] as u32, i);\n    }\n\n    // these values should encode in 3 bytes (leading byte + 2 bytes)\n    // Values chosen at random, add new cases as needed\n    for i in [\n        SINGLE_BYTE_MAX as u32 + 1,\n        300,\n        500,\n        700,\n        888,\n        1234,\n        u16::MAX as u32,\n    ] {\n        let mut writer = SliceWriter::new(\u0026mut buffer);\n        varint_encode_u32(\u0026mut writer, Endian::Big, i).unwrap();\n        assert_eq!(writer.bytes_written(), 3);\n        assert_eq!(buffer[0], U16_BYTE);\n        assert_eq!(\u0026buffer[1..3], \u0026(i as u16).to_be_bytes());\n\n        let mut writer = SliceWriter::new(\u0026mut buffer);\n        varint_encode_u32(\u0026mut writer, Endian::Little, i).unwrap();\n        assert_eq!(writer.bytes_written(), 3);\n        assert_eq!(buffer[0], U16_BYTE);\n        assert_eq!(\u0026buffer[1..3], \u0026(i as u16).to_le_bytes());\n    }\n\n    // these values should encode in 5 bytes (leading byte + 4 bytes)\n    // Values chosen at random, add new cases as needed\n    for i in [u16::MAX as u32 + 1, 100_000, 1_000_000, u32::MAX] {\n        let mut writer = SliceWriter::new(\u0026mut buffer);\n        varint_encode_u32(\u0026mut writer, Endian::Big, i).unwrap();\n        assert_eq!(writer.bytes_written(), 5);\n        assert_eq!(buffer[0], U32_BYTE);\n        assert_eq!(\u0026buffer[1..5], \u0026i.to_be_bytes());\n\n        let mut writer = SliceWriter::new(\u0026mut buffer);\n        varint_encode_u32(\u0026mut writer, Endian::Little, i).unwrap();\n        assert_eq!(writer.bytes_written(), 5);\n        assert_eq!(buffer[0], U32_BYTE);\n        assert_eq!(\u0026buffer[1..5], \u0026i.to_le_bytes());\n    }\n}\n\n#[test]\nfn test_encode_u64() {\n    use crate::enc::write::SliceWriter;\n    let mut buffer = [0u8; 20];\n\n    // these should all encode to a single byte\n    for i in 0u64..=SINGLE_BYTE_MAX as u64 {\n        let mut writer = SliceWriter::new(\u0026mut buffer);\n        varint_encode_u64(\u0026mut writer, Endian::Big, i).unwrap();\n        assert_eq!(writer.bytes_written(), 1);\n        assert_eq!(buffer[0] as u64, i);\n\n        // Assert endianness doesn't matter\n        let mut writer = SliceWriter::new(\u0026mut buffer);\n        varint_encode_u64(\u0026mut writer, Endian::Little, i).unwrap();\n        assert_eq!(writer.bytes_written(), 1);\n        assert_eq!(buffer[0] as u64, i);\n    }\n\n    // these values should encode in 3 bytes (leading byte + 2 bytes)\n    // Values chosen at random, add new cases as needed\n    for i in [\n        SINGLE_BYTE_MAX as u64 + 1,\n        300,\n        500,\n        700,\n        888,\n        1234,\n        u16::MAX as u64,\n    ] {\n        let mut writer = SliceWriter::new(\u0026mut buffer);\n        varint_encode_u64(\u0026mut writer, Endian::Big, i).unwrap();\n        assert_eq!(writer.bytes_written(), 3);\n        assert_eq!(buffer[0], U16_BYTE);\n        assert_eq!(\u0026buffer[1..3], \u0026(i as u16).to_be_bytes());\n\n        let mut writer = SliceWriter::new(\u0026mut buffer);\n        varint_encode_u64(\u0026mut writer, Endian::Little, i).unwrap();\n        assert_eq!(writer.bytes_written(), 3);\n        assert_eq!(buffer[0], U16_BYTE);\n        assert_eq!(\u0026buffer[1..3], \u0026(i as u16).to_le_bytes());\n    }\n\n    // these values should encode in 5 bytes (leading byte + 4 bytes)\n    // Values chosen at random, add new cases as needed\n    for i in [u16::MAX as u64 + 1, 100_000, 1_000_000, u32::MAX as u64] {\n        let mut writer = SliceWriter::new(\u0026mut buffer);\n        varint_encode_u64(\u0026mut writer, Endian::Big, i).unwrap();\n        assert_eq!(writer.bytes_written(), 5);\n        assert_eq!(buffer[0], U32_BYTE);\n        assert_eq!(\u0026buffer[1..5], \u0026(i as u32).to_be_bytes());\n\n        let mut writer = SliceWriter::new(\u0026mut buffer);\n        varint_encode_u64(\u0026mut writer, Endian::Little, i).unwrap();\n        assert_eq!(writer.bytes_written(), 5);\n        assert_eq!(buffer[0], U32_BYTE);\n        assert_eq!(\u0026buffer[1..5], \u0026(i as u32).to_le_bytes());\n    }\n\n    // these values should encode in 9 bytes (leading byte + 8 bytes)\n    // Values chosen at random, add new cases as needed\n    for i in [u32::MAX as u64 + 1, 500_0000_000, u64::MAX] {\n        let mut writer = SliceWriter::new(\u0026mut buffer);\n        varint_encode_u64(\u0026mut writer, Endian::Big, i).unwrap();\n        assert_eq!(writer.bytes_written(), 9);\n        assert_eq!(buffer[0], U64_BYTE);\n        assert_eq!(\u0026buffer[1..9], \u0026i.to_be_bytes());\n\n        let mut writer = SliceWriter::new(\u0026mut buffer);\n        varint_encode_u64(\u0026mut writer, Endian::Little, i).unwrap();\n        assert_eq!(writer.bytes_written(), 9);\n        assert_eq!(buffer[0], U64_BYTE);\n        assert_eq!(\u0026buffer[1..9], \u0026i.to_le_bytes());\n    }\n}\n\n#[test]\nfn test_encode_u128() {\n    use crate::enc::write::SliceWriter;\n    let mut buffer = [0u8; 20];\n\n    // these should all encode to a single byte\n    for i in 0u128..=SINGLE_BYTE_MAX as u128 {\n        let mut writer = SliceWriter::new(\u0026mut buffer);\n        varint_encode_u128(\u0026mut writer, Endian::Big, i).unwrap();\n        assert_eq!(writer.bytes_written(), 1);\n        assert_eq!(buffer[0] as u128, i);\n\n        // Assert endianness doesn't matter\n        let mut writer = SliceWriter::new(\u0026mut buffer);\n        varint_encode_u128(\u0026mut writer, Endian::Little, i).unwrap();\n        assert_eq!(writer.bytes_written(), 1);\n        assert_eq!(buffer[0] as u128, i);\n    }\n\n    // these values should encode in 3 bytes (leading byte + 2 bytes)\n    // Values chosen at random, add new cases as needed\n    for i in [\n        SINGLE_BYTE_MAX as u128 + 1,\n        300,\n        500,\n        700,\n        888,\n        1234,\n        u16::MAX as u128,\n    ] {\n        let mut writer = SliceWriter::new(\u0026mut buffer);\n        varint_encode_u128(\u0026mut writer, Endian::Big, i).unwrap();\n        assert_eq!(writer.bytes_written(), 3);\n        assert_eq!(buffer[0], U16_BYTE);\n        assert_eq!(\u0026buffer[1..3], \u0026(i as u16).to_be_bytes());\n\n        let mut writer = SliceWriter::new(\u0026mut buffer);\n        varint_encode_u128(\u0026mut writer, Endian::Little, i).unwrap();\n        assert_eq!(writer.bytes_written(), 3);\n        assert_eq!(buffer[0], U16_BYTE);\n        assert_eq!(\u0026buffer[1..3], \u0026(i as u16).to_le_bytes());\n    }\n\n    // these values should encode in 5 bytes (leading byte + 4 bytes)\n    // Values chosen at random, add new cases as needed\n    for i in [u16::MAX as u128 + 1, 100_000, 1_000_000, u32::MAX as u128] {\n        let mut writer = SliceWriter::new(\u0026mut buffer);\n        varint_encode_u128(\u0026mut writer, Endian::Big, i).unwrap();\n        assert_eq!(writer.bytes_written(), 5);\n        assert_eq!(buffer[0], U32_BYTE);\n        assert_eq!(\u0026buffer[1..5], \u0026(i as u32).to_be_bytes());\n\n        let mut writer = SliceWriter::new(\u0026mut buffer);\n        varint_encode_u128(\u0026mut writer, Endian::Little, i).unwrap();\n        assert_eq!(writer.bytes_written(), 5);\n        assert_eq!(buffer[0], U32_BYTE);\n        assert_eq!(\u0026buffer[1..5], \u0026(i as u32).to_le_bytes());\n    }\n\n    // these values should encode in 9 bytes (leading byte + 8 bytes)\n    // Values chosen at random, add new cases as needed\n    for i in [u32::MAX as u128 + 1, 500_0000_000, u64::MAX as u128] {\n        let mut writer = SliceWriter::new(\u0026mut buffer);\n        varint_encode_u128(\u0026mut writer, Endian::Big, i).unwrap();\n        assert_eq!(writer.bytes_written(), 9);\n        assert_eq!(buffer[0], U64_BYTE);\n        assert_eq!(\u0026buffer[1..9], \u0026(i as u64).to_be_bytes());\n\n        let mut writer = SliceWriter::new(\u0026mut buffer);\n        varint_encode_u128(\u0026mut writer, Endian::Little, i).unwrap();\n        assert_eq!(writer.bytes_written(), 9);\n        assert_eq!(buffer[0], U64_BYTE);\n        assert_eq!(\u0026buffer[1..9], \u0026(i as u64).to_le_bytes());\n    }\n\n    // these values should encode in 17 bytes (leading byte + 16 bytes)\n    // Values chosen at random, add new cases as needed\n    for i in [u64::MAX as u128 + 1, u128::MAX] {\n        let mut writer = SliceWriter::new(\u0026mut buffer);\n        varint_encode_u128(\u0026mut writer, Endian::Big, i).unwrap();\n        assert_eq!(writer.bytes_written(), 17);\n        assert_eq!(buffer[0], U128_BYTE);\n        assert_eq!(\u0026buffer[1..17], \u0026i.to_be_bytes());\n\n        let mut writer = SliceWriter::new(\u0026mut buffer);\n        varint_encode_u128(\u0026mut writer, Endian::Little, i).unwrap();\n        assert_eq!(writer.bytes_written(), 17);\n        assert_eq!(buffer[0], U128_BYTE);\n        assert_eq!(\u0026buffer[1..17], \u0026i.to_le_bytes());\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","trangar","development","rust","bincode","src","varint","mod.rs"],"content":"mod decode_signed;\nmod decode_unsigned;\nmod encode_signed;\nmod encode_unsigned;\n\npub use self::{\n    decode_signed::{\n        varint_decode_i128, varint_decode_i16, varint_decode_i32, varint_decode_i64,\n        varint_decode_isize,\n    },\n    decode_unsigned::{\n        varint_decode_u128, varint_decode_u16, varint_decode_u32, varint_decode_u64,\n        varint_decode_usize,\n    },\n    encode_signed::{\n        varint_encode_i128, varint_encode_i16, varint_encode_i32, varint_encode_i64,\n        varint_encode_isize,\n    },\n    encode_unsigned::{\n        varint_encode_u128, varint_encode_u16, varint_encode_u32, varint_encode_u64,\n        varint_encode_usize,\n    },\n};\n\npub(self) const SINGLE_BYTE_MAX: u8 = 250;\npub(self) const U16_BYTE: u8 = 251;\npub(self) const U32_BYTE: u8 = 252;\npub(self) const U64_BYTE: u8 = 253;\npub(self) const U128_BYTE: u8 = 254;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","trangar","development","rust","bincode","tests","derive.rs"],"content":"#![cfg(feature = \"derive\")]\n\nuse bincode::{de::Decodable, enc::Encodeable};\n\n#[derive(bincode::Encodable, PartialEq, Debug)]\npub(crate) struct Test\u003cT: Encodeable\u003e {\n    a: T,\n    b: u32,\n    c: u8,\n}\n\n#[derive(bincode::Decodable, PartialEq, Debug, Eq)]\npub struct Test2\u003cT: Decodable\u003e {\n    a: T,\n    b: u32,\n    c: u32,\n}\n\n#[derive(bincode::Decodable, PartialEq, Debug, Eq)]\npub struct Test3\u003c'a\u003e {\n    a: \u0026'a str,\n    b: u32,\n    c: u32,\n}\n\n#[derive(bincode::Encodable, bincode::Decodable, PartialEq, Debug, Eq)]\npub struct TestTupleStruct(u32, u32, u32);\n\n#[derive(bincode::Encodable, bincode::Decodable, PartialEq, Debug, Eq)]\npub enum TestEnum {\n    Foo,\n    Bar { name: u32 },\n    Baz(u32, u32, u32),\n}\n\n#[derive(bincode::Encodable, bincode::Decodable, PartialEq, Debug, Eq)]\npub enum TestEnum2\u003c'a\u003e {\n    Foo,\n    Bar { name: \u0026'a str },\n    Baz(u32, u32, u32),\n}\n\n#[test]\nfn test_encodable() {\n    let start = Test {\n        a: 5i32,\n        b: 10u32,\n        c: 20u8,\n    };\n    let mut slice = [0u8; 1024];\n    let bytes_written = bincode::encode_into_slice(start, \u0026mut slice).unwrap();\n    assert_eq!(bytes_written, 3);\n    assert_eq!(\u0026slice[..bytes_written], \u0026[10, 10, 20]);\n}\n\n#[cfg(feature = \"std\")]\n#[test]\nfn test_decodable() {\n    let start = Test2 {\n        a: 5u32,\n        b: 10u32,\n        c: 1024u32,\n    };\n    let slice = [5, 10, 251, 0, 4];\n    let result: Test2\u003cu32\u003e = bincode::decode_from(\u0026mut slice.as_ref()).unwrap();\n    assert_eq!(result, start);\n}\n\n#[test]\nfn test_encodable_tuple() {\n    let start = TestTupleStruct(5, 10, 1024);\n    let mut slice = [0u8; 1024];\n    let bytes_written = bincode::encode_into_slice(start, \u0026mut slice).unwrap();\n    assert_eq!(bytes_written, 5);\n    assert_eq!(\u0026slice[..bytes_written], \u0026[5, 10, 251, 0, 4]);\n}\n\n#[test]\nfn test_decodable_tuple() {\n    let start = TestTupleStruct(5, 10, 1024);\n    let mut slice = [5, 10, 251, 0, 4];\n    let result: TestTupleStruct = bincode::decode(\u0026mut slice).unwrap();\n    assert_eq!(result, start);\n}\n\n#[test]\nfn test_encodable_enum_struct_variant() {\n    let start = TestEnum::Bar { name: 5u32 };\n    let mut slice = [0u8; 1024];\n    let bytes_written = bincode::encode_into_slice(start, \u0026mut slice).unwrap();\n    assert_eq!(bytes_written, 2);\n    assert_eq!(\u0026slice[..bytes_written], \u0026[1, 5]);\n}\n\n#[test]\nfn test_decodable_enum_struct_variant() {\n    let start = TestEnum::Bar { name: 5u32 };\n    let mut slice = [1, 5];\n    let result: TestEnum = bincode::decode(\u0026mut slice).unwrap();\n    assert_eq!(result, start);\n}\n\n#[test]\nfn test_encodable_enum_tuple_variant() {\n    let start = TestEnum::Baz(5, 10, 1024);\n    let mut slice = [0u8; 1024];\n    let bytes_written = bincode::encode_into_slice(start, \u0026mut slice).unwrap();\n    assert_eq!(bytes_written, 6);\n    assert_eq!(\u0026slice[..bytes_written], \u0026[2, 5, 10, 251, 0, 4]);\n}\n\n#[test]\nfn test_decodable_enum_unit_variant() {\n    let start = TestEnum::Foo;\n    let mut slice = [0];\n    let result: TestEnum = bincode::decode(\u0026mut slice).unwrap();\n    assert_eq!(result, start);\n}\n\n#[test]\nfn test_encodable_enum_unit_variant() {\n    let start = TestEnum::Foo;\n    let mut slice = [0u8; 1024];\n    let bytes_written = bincode::encode_into_slice(start, \u0026mut slice).unwrap();\n    assert_eq!(bytes_written, 1);\n    assert_eq!(\u0026slice[..bytes_written], \u0026[0]);\n}\n\n#[test]\nfn test_decodable_enum_tuple_variant() {\n    let start = TestEnum::Baz(5, 10, 1024);\n    let mut slice = [2, 5, 10, 251, 0, 4];\n    let result: TestEnum = bincode::decode(\u0026mut slice).unwrap();\n    assert_eq!(result, start);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","trangar","development","rust","bincode","tests","test.rs"],"content":"use bincode::config::{self, Config};\nuse core::fmt::Debug;\n\nfn the_same_with_config\u003cV, C\u003e(element: V, config: C)\nwhere\n    V: bincode::enc::Encodeable\n        + for\u003c'de\u003e bincode::de::Decodable\n        + PartialEq\n        + Debug\n        + Clone\n        + 'static,\n    C: Config,\n{\n    let mut buffer = [0u8; 32];\n    bincode::encode_into_slice_with_config(element.clone(), \u0026mut buffer, config).unwrap();\n    let decoded: V = bincode::decode_with_config(\u0026mut buffer, config).unwrap();\n\n    assert_eq!(element, decoded);\n}\nfn the_same\u003cV\u003e(element: V)\nwhere\n    V: bincode::enc::Encodeable\n        + for\u003c'de\u003e bincode::de::Decodable\n        + PartialEq\n        + Debug\n        + Clone\n        + 'static,\n{\n    the_same_with_config(\n        element.clone(),\n        config::Default\n            .with_little_endian()\n            .with_fixed_int_encoding(),\n    );\n    the_same_with_config(\n        element.clone(),\n        config::Default.with_big_endian().with_fixed_int_encoding(),\n    );\n    the_same_with_config(\n        element.clone(),\n        config::Default\n            .with_little_endian()\n            .with_variable_int_encoding(),\n    );\n    the_same_with_config(\n        element,\n        config::Default\n            .with_big_endian()\n            .with_variable_int_encoding(),\n    );\n}\n\n#[test]\nfn test_numbers() {\n    the_same(5u8);\n    the_same(5u16);\n    the_same(5u32);\n    the_same(5u64);\n    the_same(5u128);\n    the_same(5usize);\n\n    the_same(5i8);\n    the_same(5i16);\n    the_same(5i32);\n    the_same(5i64);\n    the_same(5i128);\n    the_same(5isize);\n\n    the_same(5.0f32);\n    the_same(5.0f64);\n}\n\n#[test]\nfn test_slice() {\n    let mut buffer = [0u8; 32];\n    let input: \u0026[u8] = \u0026[1, 2, 3, 4, 5, 6, 7];\n    bincode::encode_into_slice(input, \u0026mut buffer).unwrap();\n    assert_eq!(\u0026buffer[..8], \u0026[7, 1, 2, 3, 4, 5, 6, 7]);\n\n    let output: \u0026[u8] = bincode::decode(\u0026mut buffer[..8]).unwrap();\n    assert_eq!(input, output);\n}\n\n#[test]\nfn test_str() {\n    let mut buffer = [0u8; 32];\n    let input: \u0026str = \"Hello world\";\n    bincode::encode_into_slice(input, \u0026mut buffer).unwrap();\n    assert_eq!(\n        \u0026buffer[..12],\n        \u0026[11, 72, 101, 108, 108, 111, 32, 119, 111, 114, 108, 100]\n    );\n\n    let output: \u0026str = bincode::decode(\u0026mut buffer[..12]).unwrap();\n    assert_eq!(input, output);\n}\n\n#[test]\nfn test_array() {\n    let mut buffer = [0u8; 32];\n    let input: [u8; 10] = [10, 20, 30, 40, 50, 60, 70, 80, 90, 100];\n    bincode::encode_into_slice(input, \u0026mut buffer).unwrap();\n    assert_eq!(\u0026buffer[..10], \u0026[10, 20, 30, 40, 50, 60, 70, 80, 90, 100]);\n\n    let output: [u8; 10] = bincode::decode(\u0026mut buffer[..10]).unwrap();\n    assert_eq!(input, output);\n}\n","traces":[],"covered":0,"coverable":0}]};
    </script>
    <script crossorigin>/** @license React v16.13.1
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
'use strict';(function(d,r){"object"===typeof exports&&"undefined"!==typeof module?r(exports):"function"===typeof define&&define.amd?define(["exports"],r):(d=d||self,r(d.React={}))})(this,function(d){function r(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function w(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function da(){}function L(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function ea(a,b,c){var g,e={},fa=null,d=null;if(null!=b)for(g in void 0!==b.ref&&(d=b.ref),void 0!==b.key&&(fa=""+b.key),b)ha.call(b,g)&&!ia.hasOwnProperty(g)&&(e[g]=b[g]);var h=arguments.length-2;if(1===h)e.children=c;else if(1<h){for(var k=Array(h),f=0;f<h;f++)k[f]=arguments[f+2];e.children=k}if(a&&a.defaultProps)for(g in h=a.defaultProps,
h)void 0===e[g]&&(e[g]=h[g]);return{$$typeof:x,type:a,key:fa,ref:d,props:e,_owner:M.current}}function va(a,b){return{$$typeof:x,type:a.type,key:b,ref:a.ref,props:a.props,_owner:a._owner}}function N(a){return"object"===typeof a&&null!==a&&a.$$typeof===x}function wa(a){var b={"=":"=0",":":"=2"};return"$"+(""+a).replace(/[=:]/g,function(a){return b[a]})}function ja(a,b,c,g){if(C.length){var e=C.pop();e.result=a;e.keyPrefix=b;e.func=c;e.context=g;e.count=0;return e}return{result:a,keyPrefix:b,func:c,
context:g,count:0}}function ka(a){a.result=null;a.keyPrefix=null;a.func=null;a.context=null;a.count=0;10>C.length&&C.push(a)}function O(a,b,c,g){var e=typeof a;if("undefined"===e||"boolean"===e)a=null;var d=!1;if(null===a)d=!0;else switch(e){case "string":case "number":d=!0;break;case "object":switch(a.$$typeof){case x:case xa:d=!0}}if(d)return c(g,a,""===b?"."+P(a,0):b),1;d=0;b=""===b?".":b+":";if(Array.isArray(a))for(var f=0;f<a.length;f++){e=a[f];var h=b+P(e,f);d+=O(e,h,c,g)}else if(null===a||
"object"!==typeof a?h=null:(h=la&&a[la]||a["@@iterator"],h="function"===typeof h?h:null),"function"===typeof h)for(a=h.call(a),f=0;!(e=a.next()).done;)e=e.value,h=b+P(e,f++),d+=O(e,h,c,g);else if("object"===e)throw c=""+a,Error(r(31,"[object Object]"===c?"object with keys {"+Object.keys(a).join(", ")+"}":c,""));return d}function Q(a,b,c){return null==a?0:O(a,"",b,c)}function P(a,b){return"object"===typeof a&&null!==a&&null!=a.key?wa(a.key):b.toString(36)}function ya(a,b,c){a.func.call(a.context,b,
a.count++)}function za(a,b,c){var g=a.result,e=a.keyPrefix;a=a.func.call(a.context,b,a.count++);Array.isArray(a)?R(a,g,c,function(a){return a}):null!=a&&(N(a)&&(a=va(a,e+(!a.key||b&&b.key===a.key?"":(""+a.key).replace(ma,"$&/")+"/")+c)),g.push(a))}function R(a,b,c,g,e){var d="";null!=c&&(d=(""+c).replace(ma,"$&/")+"/");b=ja(b,d,g,e);Q(a,za,b);ka(b)}function t(){var a=na.current;if(null===a)throw Error(r(321));return a}function S(a,b){var c=a.length;a.push(b);a:for(;;){var g=c-1>>>1,e=a[g];if(void 0!==
e&&0<D(e,b))a[g]=b,a[c]=e,c=g;else break a}}function n(a){a=a[0];return void 0===a?null:a}function E(a){var b=a[0];if(void 0!==b){var c=a.pop();if(c!==b){a[0]=c;a:for(var g=0,e=a.length;g<e;){var d=2*(g+1)-1,f=a[d],h=d+1,k=a[h];if(void 0!==f&&0>D(f,c))void 0!==k&&0>D(k,f)?(a[g]=k,a[h]=c,g=h):(a[g]=f,a[d]=c,g=d);else if(void 0!==k&&0>D(k,c))a[g]=k,a[h]=c,g=h;else break a}}return b}return null}function D(a,b){var c=a.sortIndex-b.sortIndex;return 0!==c?c:a.id-b.id}function F(a){for(var b=n(u);null!==
b;){if(null===b.callback)E(u);else if(b.startTime<=a)E(u),b.sortIndex=b.expirationTime,S(p,b);else break;b=n(u)}}function T(a){y=!1;F(a);if(!v)if(null!==n(p))v=!0,z(U);else{var b=n(u);null!==b&&G(T,b.startTime-a)}}function U(a,b){v=!1;y&&(y=!1,V());H=!0;var c=m;try{F(b);for(l=n(p);null!==l&&(!(l.expirationTime>b)||a&&!W());){var g=l.callback;if(null!==g){l.callback=null;m=l.priorityLevel;var e=g(l.expirationTime<=b);b=q();"function"===typeof e?l.callback=e:l===n(p)&&E(p);F(b)}else E(p);l=n(p)}if(null!==
l)var d=!0;else{var f=n(u);null!==f&&G(T,f.startTime-b);d=!1}return d}finally{l=null,m=c,H=!1}}function oa(a){switch(a){case 1:return-1;case 2:return 250;case 5:return 1073741823;case 4:return 1E4;default:return 5E3}}var f="function"===typeof Symbol&&Symbol.for,x=f?Symbol.for("react.element"):60103,xa=f?Symbol.for("react.portal"):60106,Aa=f?Symbol.for("react.fragment"):60107,Ba=f?Symbol.for("react.strict_mode"):60108,Ca=f?Symbol.for("react.profiler"):60114,Da=f?Symbol.for("react.provider"):60109,
Ea=f?Symbol.for("react.context"):60110,Fa=f?Symbol.for("react.forward_ref"):60112,Ga=f?Symbol.for("react.suspense"):60113,Ha=f?Symbol.for("react.memo"):60115,Ia=f?Symbol.for("react.lazy"):60116,la="function"===typeof Symbol&&Symbol.iterator,pa=Object.getOwnPropertySymbols,Ja=Object.prototype.hasOwnProperty,Ka=Object.prototype.propertyIsEnumerable,I=function(){try{if(!Object.assign)return!1;var a=new String("abc");a[5]="de";if("5"===Object.getOwnPropertyNames(a)[0])return!1;var b={};for(a=0;10>a;a++)b["_"+
String.fromCharCode(a)]=a;if("0123456789"!==Object.getOwnPropertyNames(b).map(function(a){return b[a]}).join(""))return!1;var c={};"abcdefghijklmnopqrst".split("").forEach(function(a){c[a]=a});return"abcdefghijklmnopqrst"!==Object.keys(Object.assign({},c)).join("")?!1:!0}catch(g){return!1}}()?Object.assign:function(a,b){if(null===a||void 0===a)throw new TypeError("Object.assign cannot be called with null or undefined");var c=Object(a);for(var g,e=1;e<arguments.length;e++){var d=Object(arguments[e]);
for(var f in d)Ja.call(d,f)&&(c[f]=d[f]);if(pa){g=pa(d);for(var h=0;h<g.length;h++)Ka.call(d,g[h])&&(c[g[h]]=d[g[h]])}}return c},ca={isMounted:function(a){return!1},enqueueForceUpdate:function(a,b,c){},enqueueReplaceState:function(a,b,c,d){},enqueueSetState:function(a,b,c,d){}},ba={};w.prototype.isReactComponent={};w.prototype.setState=function(a,b){if("object"!==typeof a&&"function"!==typeof a&&null!=a)throw Error(r(85));this.updater.enqueueSetState(this,a,b,"setState")};w.prototype.forceUpdate=
function(a){this.updater.enqueueForceUpdate(this,a,"forceUpdate")};da.prototype=w.prototype;f=L.prototype=new da;f.constructor=L;I(f,w.prototype);f.isPureReactComponent=!0;var M={current:null},ha=Object.prototype.hasOwnProperty,ia={key:!0,ref:!0,__self:!0,__source:!0},ma=/\/+/g,C=[],na={current:null},X;if("undefined"===typeof window||"function"!==typeof MessageChannel){var A=null,qa=null,ra=function(){if(null!==A)try{var a=q();A(!0,a);A=null}catch(b){throw setTimeout(ra,0),b;}},La=Date.now();var q=
function(){return Date.now()-La};var z=function(a){null!==A?setTimeout(z,0,a):(A=a,setTimeout(ra,0))};var G=function(a,b){qa=setTimeout(a,b)};var V=function(){clearTimeout(qa)};var W=function(){return!1};f=X=function(){}}else{var Y=window.performance,sa=window.Date,Ma=window.setTimeout,Na=window.clearTimeout;"undefined"!==typeof console&&(f=window.cancelAnimationFrame,"function"!==typeof window.requestAnimationFrame&&console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"),
"function"!==typeof f&&console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"));if("object"===typeof Y&&"function"===typeof Y.now)q=function(){return Y.now()};else{var Oa=sa.now();q=function(){return sa.now()-Oa}}var J=!1,K=null,Z=-1,ta=5,ua=0;W=function(){return q()>=ua};f=function(){};X=function(a){0>a||125<a?console.error("forceFrameRate takes a positive int between 0 and 125, forcing framerates higher than 125 fps is not unsupported"):
ta=0<a?Math.floor(1E3/a):5};var B=new MessageChannel,aa=B.port2;B.port1.onmessage=function(){if(null!==K){var a=q();ua=a+ta;try{K(!0,a)?aa.postMessage(null):(J=!1,K=null)}catch(b){throw aa.postMessage(null),b;}}else J=!1};z=function(a){K=a;J||(J=!0,aa.postMessage(null))};G=function(a,b){Z=Ma(function(){a(q())},b)};V=function(){Na(Z);Z=-1}}var p=[],u=[],Pa=1,l=null,m=3,H=!1,v=!1,y=!1,Qa=0;B={ReactCurrentDispatcher:na,ReactCurrentOwner:M,IsSomeRendererActing:{current:!1},assign:I};I(B,{Scheduler:{__proto__:null,
unstable_ImmediatePriority:1,unstable_UserBlockingPriority:2,unstable_NormalPriority:3,unstable_IdlePriority:5,unstable_LowPriority:4,unstable_runWithPriority:function(a,b){switch(a){case 1:case 2:case 3:case 4:case 5:break;default:a=3}var c=m;m=a;try{return b()}finally{m=c}},unstable_next:function(a){switch(m){case 1:case 2:case 3:var b=3;break;default:b=m}var c=m;m=b;try{return a()}finally{m=c}},unstable_scheduleCallback:function(a,b,c){var d=q();if("object"===typeof c&&null!==c){var e=c.delay;
e="number"===typeof e&&0<e?d+e:d;c="number"===typeof c.timeout?c.timeout:oa(a)}else c=oa(a),e=d;c=e+c;a={id:Pa++,callback:b,priorityLevel:a,startTime:e,expirationTime:c,sortIndex:-1};e>d?(a.sortIndex=e,S(u,a),null===n(p)&&a===n(u)&&(y?V():y=!0,G(T,e-d))):(a.sortIndex=c,S(p,a),v||H||(v=!0,z(U)));return a},unstable_cancelCallback:function(a){a.callback=null},unstable_wrapCallback:function(a){var b=m;return function(){var c=m;m=b;try{return a.apply(this,arguments)}finally{m=c}}},unstable_getCurrentPriorityLevel:function(){return m},
unstable_shouldYield:function(){var a=q();F(a);var b=n(p);return b!==l&&null!==l&&null!==b&&null!==b.callback&&b.startTime<=a&&b.expirationTime<l.expirationTime||W()},unstable_requestPaint:f,unstable_continueExecution:function(){v||H||(v=!0,z(U))},unstable_pauseExecution:function(){},unstable_getFirstCallbackNode:function(){return n(p)},get unstable_now(){return q},get unstable_forceFrameRate(){return X},unstable_Profiling:null},SchedulerTracing:{__proto__:null,__interactionsRef:null,__subscriberRef:null,
unstable_clear:function(a){return a()},unstable_getCurrent:function(){return null},unstable_getThreadID:function(){return++Qa},unstable_trace:function(a,b,c){return c()},unstable_wrap:function(a){return a},unstable_subscribe:function(a){},unstable_unsubscribe:function(a){}}});d.Children={map:function(a,b,c){if(null==a)return a;var d=[];R(a,d,null,b,c);return d},forEach:function(a,b,c){if(null==a)return a;b=ja(null,null,b,c);Q(a,ya,b);ka(b)},count:function(a){return Q(a,function(){return null},null)},
toArray:function(a){var b=[];R(a,b,null,function(a){return a});return b},only:function(a){if(!N(a))throw Error(r(143));return a}};d.Component=w;d.Fragment=Aa;d.Profiler=Ca;d.PureComponent=L;d.StrictMode=Ba;d.Suspense=Ga;d.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=B;d.cloneElement=function(a,b,c){if(null===a||void 0===a)throw Error(r(267,a));var d=I({},a.props),e=a.key,f=a.ref,m=a._owner;if(null!=b){void 0!==b.ref&&(f=b.ref,m=M.current);void 0!==b.key&&(e=""+b.key);if(a.type&&a.type.defaultProps)var h=
a.type.defaultProps;for(k in b)ha.call(b,k)&&!ia.hasOwnProperty(k)&&(d[k]=void 0===b[k]&&void 0!==h?h[k]:b[k])}var k=arguments.length-2;if(1===k)d.children=c;else if(1<k){h=Array(k);for(var l=0;l<k;l++)h[l]=arguments[l+2];d.children=h}return{$$typeof:x,type:a.type,key:e,ref:f,props:d,_owner:m}};d.createContext=function(a,b){void 0===b&&(b=null);a={$$typeof:Ea,_calculateChangedBits:b,_currentValue:a,_currentValue2:a,_threadCount:0,Provider:null,Consumer:null};a.Provider={$$typeof:Da,_context:a};return a.Consumer=
a};d.createElement=ea;d.createFactory=function(a){var b=ea.bind(null,a);b.type=a;return b};d.createRef=function(){return{current:null}};d.forwardRef=function(a){return{$$typeof:Fa,render:a}};d.isValidElement=N;d.lazy=function(a){return{$$typeof:Ia,_ctor:a,_status:-1,_result:null}};d.memo=function(a,b){return{$$typeof:Ha,type:a,compare:void 0===b?null:b}};d.useCallback=function(a,b){return t().useCallback(a,b)};d.useContext=function(a,b){return t().useContext(a,b)};d.useDebugValue=function(a,b){};
d.useEffect=function(a,b){return t().useEffect(a,b)};d.useImperativeHandle=function(a,b,c){return t().useImperativeHandle(a,b,c)};d.useLayoutEffect=function(a,b){return t().useLayoutEffect(a,b)};d.useMemo=function(a,b){return t().useMemo(a,b)};d.useReducer=function(a,b,c){return t().useReducer(a,b,c)};d.useRef=function(a){return t().useRef(a)};d.useState=function(a){return t().useState(a)};d.version="16.13.1"});
</script>
    <script crossorigin>/** @license React v16.13.1
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/*
 Modernizr 3.0.0pre (Custom Build) | MIT
*/
'use strict';(function(I,ea){"object"===typeof exports&&"undefined"!==typeof module?ea(exports,require("react")):"function"===typeof define&&define.amd?define(["exports","react"],ea):(I=I||self,ea(I.ReactDOM={},I.React))})(this,function(I,ea){function k(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function ji(a,b,c,d,e,f,g,h,m){yb=!1;gc=null;ki.apply(li,arguments)}function mi(a,b,c,d,e,f,g,h,m){ji.apply(this,arguments);if(yb){if(yb){var n=gc;yb=!1;gc=null}else throw Error(k(198));hc||(hc=!0,pd=n)}}function lf(a,b,c){var d=a.type||"unknown-event";a.currentTarget=mf(c);mi(d,b,void 0,a);a.currentTarget=null}function nf(){if(ic)for(var a in cb){var b=cb[a],c=ic.indexOf(a);if(!(-1<c))throw Error(k(96,a));if(!jc[c]){if(!b.extractEvents)throw Error(k(97,a));jc[c]=b;c=b.eventTypes;for(var d in c){var e=
void 0;var f=c[d],g=b,h=d;if(qd.hasOwnProperty(h))throw Error(k(99,h));qd[h]=f;var m=f.phasedRegistrationNames;if(m){for(e in m)m.hasOwnProperty(e)&&of(m[e],g,h);e=!0}else f.registrationName?(of(f.registrationName,g,h),e=!0):e=!1;if(!e)throw Error(k(98,d,a));}}}}function of(a,b,c){if(db[a])throw Error(k(100,a));db[a]=b;rd[a]=b.eventTypes[c].dependencies}function pf(a){var b=!1,c;for(c in a)if(a.hasOwnProperty(c)){var d=a[c];if(!cb.hasOwnProperty(c)||cb[c]!==d){if(cb[c])throw Error(k(102,c));cb[c]=
d;b=!0}}b&&nf()}function qf(a){if(a=rf(a)){if("function"!==typeof sd)throw Error(k(280));var b=a.stateNode;b&&(b=td(b),sd(a.stateNode,a.type,b))}}function sf(a){eb?fb?fb.push(a):fb=[a]:eb=a}function tf(){if(eb){var a=eb,b=fb;fb=eb=null;qf(a);if(b)for(a=0;a<b.length;a++)qf(b[a])}}function ud(){if(null!==eb||null!==fb)vd(),tf()}function uf(a,b,c){if(wd)return a(b,c);wd=!0;try{return vf(a,b,c)}finally{wd=!1,ud()}}function ni(a){if(wf.call(xf,a))return!0;if(wf.call(yf,a))return!1;if(oi.test(a))return xf[a]=
!0;yf[a]=!0;return!1}function pi(a,b,c,d){if(null!==c&&0===c.type)return!1;switch(typeof b){case "function":case "symbol":return!0;case "boolean":if(d)return!1;if(null!==c)return!c.acceptsBooleans;a=a.toLowerCase().slice(0,5);return"data-"!==a&&"aria-"!==a;default:return!1}}function qi(a,b,c,d){if(null===b||"undefined"===typeof b||pi(a,b,c,d))return!0;if(d)return!1;if(null!==c)switch(c.type){case 3:return!b;case 4:return!1===b;case 5:return isNaN(b);case 6:return isNaN(b)||1>b}return!1}function L(a,
b,c,d,e,f){this.acceptsBooleans=2===b||3===b||4===b;this.attributeName=d;this.attributeNamespace=e;this.mustUseProperty=c;this.propertyName=a;this.type=b;this.sanitizeURL=f}function xd(a,b,c,d){var e=E.hasOwnProperty(b)?E[b]:null;var f=null!==e?0===e.type:d?!1:!(2<b.length)||"o"!==b[0]&&"O"!==b[0]||"n"!==b[1]&&"N"!==b[1]?!1:!0;f||(qi(b,c,e,d)&&(c=null),d||null===e?ni(b)&&(null===c?a.removeAttribute(b):a.setAttribute(b,""+c)):e.mustUseProperty?a[e.propertyName]=null===c?3===e.type?!1:"":c:(b=e.attributeName,
d=e.attributeNamespace,null===c?a.removeAttribute(b):(e=e.type,c=3===e||4===e&&!0===c?"":""+c,d?a.setAttributeNS(d,b,c):a.setAttribute(b,c))))}function zb(a){if(null===a||"object"!==typeof a)return null;a=zf&&a[zf]||a["@@iterator"];return"function"===typeof a?a:null}function ri(a){if(-1===a._status){a._status=0;var b=a._ctor;b=b();a._result=b;b.then(function(b){0===a._status&&(b=b.default,a._status=1,a._result=b)},function(b){0===a._status&&(a._status=2,a._result=b)})}}function na(a){if(null==a)return null;
if("function"===typeof a)return a.displayName||a.name||null;if("string"===typeof a)return a;switch(a){case Ma:return"Fragment";case gb:return"Portal";case kc:return"Profiler";case Af:return"StrictMode";case lc:return"Suspense";case yd:return"SuspenseList"}if("object"===typeof a)switch(a.$$typeof){case Bf:return"Context.Consumer";case Cf:return"Context.Provider";case zd:var b=a.render;b=b.displayName||b.name||"";return a.displayName||(""!==b?"ForwardRef("+b+")":"ForwardRef");case Ad:return na(a.type);
case Df:return na(a.render);case Ef:if(a=1===a._status?a._result:null)return na(a)}return null}function Bd(a){var b="";do{a:switch(a.tag){case 3:case 4:case 6:case 7:case 10:case 9:var c="";break a;default:var d=a._debugOwner,e=a._debugSource,f=na(a.type);c=null;d&&(c=na(d.type));d=f;f="";e?f=" (at "+e.fileName.replace(si,"")+":"+e.lineNumber+")":c&&(f=" (created by "+c+")");c="\n    in "+(d||"Unknown")+f}b+=c;a=a.return}while(a);return b}function va(a){switch(typeof a){case "boolean":case "number":case "object":case "string":case "undefined":return a;
default:return""}}function Ff(a){var b=a.type;return(a=a.nodeName)&&"input"===a.toLowerCase()&&("checkbox"===b||"radio"===b)}function ti(a){var b=Ff(a)?"checked":"value",c=Object.getOwnPropertyDescriptor(a.constructor.prototype,b),d=""+a[b];if(!a.hasOwnProperty(b)&&"undefined"!==typeof c&&"function"===typeof c.get&&"function"===typeof c.set){var e=c.get,f=c.set;Object.defineProperty(a,b,{configurable:!0,get:function(){return e.call(this)},set:function(a){d=""+a;f.call(this,a)}});Object.defineProperty(a,
b,{enumerable:c.enumerable});return{getValue:function(){return d},setValue:function(a){d=""+a},stopTracking:function(){a._valueTracker=null;delete a[b]}}}}function mc(a){a._valueTracker||(a._valueTracker=ti(a))}function Gf(a){if(!a)return!1;var b=a._valueTracker;if(!b)return!0;var c=b.getValue();var d="";a&&(d=Ff(a)?a.checked?"true":"false":a.value);a=d;return a!==c?(b.setValue(a),!0):!1}function Cd(a,b){var c=b.checked;return M({},b,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:null!=
c?c:a._wrapperState.initialChecked})}function Hf(a,b){var c=null==b.defaultValue?"":b.defaultValue,d=null!=b.checked?b.checked:b.defaultChecked;c=va(null!=b.value?b.value:c);a._wrapperState={initialChecked:d,initialValue:c,controlled:"checkbox"===b.type||"radio"===b.type?null!=b.checked:null!=b.value}}function If(a,b){b=b.checked;null!=b&&xd(a,"checked",b,!1)}function Dd(a,b){If(a,b);var c=va(b.value),d=b.type;if(null!=c)if("number"===d){if(0===c&&""===a.value||a.value!=c)a.value=""+c}else a.value!==
""+c&&(a.value=""+c);else if("submit"===d||"reset"===d){a.removeAttribute("value");return}b.hasOwnProperty("value")?Ed(a,b.type,c):b.hasOwnProperty("defaultValue")&&Ed(a,b.type,va(b.defaultValue));null==b.checked&&null!=b.defaultChecked&&(a.defaultChecked=!!b.defaultChecked)}function Jf(a,b,c){if(b.hasOwnProperty("value")||b.hasOwnProperty("defaultValue")){var d=b.type;if(!("submit"!==d&&"reset"!==d||void 0!==b.value&&null!==b.value))return;b=""+a._wrapperState.initialValue;c||b===a.value||(a.value=
b);a.defaultValue=b}c=a.name;""!==c&&(a.name="");a.defaultChecked=!!a._wrapperState.initialChecked;""!==c&&(a.name=c)}function Ed(a,b,c){if("number"!==b||a.ownerDocument.activeElement!==a)null==c?a.defaultValue=""+a._wrapperState.initialValue:a.defaultValue!==""+c&&(a.defaultValue=""+c)}function ui(a){var b="";ea.Children.forEach(a,function(a){null!=a&&(b+=a)});return b}function Fd(a,b){a=M({children:void 0},b);if(b=ui(b.children))a.children=b;return a}function hb(a,b,c,d){a=a.options;if(b){b={};
for(var e=0;e<c.length;e++)b["$"+c[e]]=!0;for(c=0;c<a.length;c++)e=b.hasOwnProperty("$"+a[c].value),a[c].selected!==e&&(a[c].selected=e),e&&d&&(a[c].defaultSelected=!0)}else{c=""+va(c);b=null;for(e=0;e<a.length;e++){if(a[e].value===c){a[e].selected=!0;d&&(a[e].defaultSelected=!0);return}null!==b||a[e].disabled||(b=a[e])}null!==b&&(b.selected=!0)}}function Gd(a,b){if(null!=b.dangerouslySetInnerHTML)throw Error(k(91));return M({},b,{value:void 0,defaultValue:void 0,children:""+a._wrapperState.initialValue})}
function Kf(a,b){var c=b.value;if(null==c){c=b.children;b=b.defaultValue;if(null!=c){if(null!=b)throw Error(k(92));if(Array.isArray(c)){if(!(1>=c.length))throw Error(k(93));c=c[0]}b=c}null==b&&(b="");c=b}a._wrapperState={initialValue:va(c)}}function Lf(a,b){var c=va(b.value),d=va(b.defaultValue);null!=c&&(c=""+c,c!==a.value&&(a.value=c),null==b.defaultValue&&a.defaultValue!==c&&(a.defaultValue=c));null!=d&&(a.defaultValue=""+d)}function Mf(a,b){b=a.textContent;b===a._wrapperState.initialValue&&""!==
b&&null!==b&&(a.value=b)}function Nf(a){switch(a){case "svg":return"http://www.w3.org/2000/svg";case "math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function Hd(a,b){return null==a||"http://www.w3.org/1999/xhtml"===a?Nf(b):"http://www.w3.org/2000/svg"===a&&"foreignObject"===b?"http://www.w3.org/1999/xhtml":a}function nc(a,b){var c={};c[a.toLowerCase()]=b.toLowerCase();c["Webkit"+a]="webkit"+b;c["Moz"+a]="moz"+b;return c}function oc(a){if(Id[a])return Id[a];
if(!ib[a])return a;var b=ib[a],c;for(c in b)if(b.hasOwnProperty(c)&&c in Of)return Id[a]=b[c];return a}function Jd(a){var b=Pf.get(a);void 0===b&&(b=new Map,Pf.set(a,b));return b}function Na(a){var b=a,c=a;if(a.alternate)for(;b.return;)b=b.return;else{a=b;do b=a,0!==(b.effectTag&1026)&&(c=b.return),a=b.return;while(a)}return 3===b.tag?c:null}function Qf(a){if(13===a.tag){var b=a.memoizedState;null===b&&(a=a.alternate,null!==a&&(b=a.memoizedState));if(null!==b)return b.dehydrated}return null}function Rf(a){if(Na(a)!==
a)throw Error(k(188));}function vi(a){var b=a.alternate;if(!b){b=Na(a);if(null===b)throw Error(k(188));return b!==a?null:a}for(var c=a,d=b;;){var e=c.return;if(null===e)break;var f=e.alternate;if(null===f){d=e.return;if(null!==d){c=d;continue}break}if(e.child===f.child){for(f=e.child;f;){if(f===c)return Rf(e),a;if(f===d)return Rf(e),b;f=f.sibling}throw Error(k(188));}if(c.return!==d.return)c=e,d=f;else{for(var g=!1,h=e.child;h;){if(h===c){g=!0;c=e;d=f;break}if(h===d){g=!0;d=e;c=f;break}h=h.sibling}if(!g){for(h=
f.child;h;){if(h===c){g=!0;c=f;d=e;break}if(h===d){g=!0;d=f;c=e;break}h=h.sibling}if(!g)throw Error(k(189));}}if(c.alternate!==d)throw Error(k(190));}if(3!==c.tag)throw Error(k(188));return c.stateNode.current===c?a:b}function Sf(a){a=vi(a);if(!a)return null;for(var b=a;;){if(5===b.tag||6===b.tag)return b;if(b.child)b.child.return=b,b=b.child;else{if(b===a)break;for(;!b.sibling;){if(!b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}}return null}function jb(a,b){if(null==
b)throw Error(k(30));if(null==a)return b;if(Array.isArray(a)){if(Array.isArray(b))return a.push.apply(a,b),a;a.push(b);return a}return Array.isArray(b)?[a].concat(b):[a,b]}function Kd(a,b,c){Array.isArray(a)?a.forEach(b,c):a&&b.call(c,a)}function pc(a){null!==a&&(Ab=jb(Ab,a));a=Ab;Ab=null;if(a){Kd(a,wi);if(Ab)throw Error(k(95));if(hc)throw a=pd,hc=!1,pd=null,a;}}function Ld(a){a=a.target||a.srcElement||window;a.correspondingUseElement&&(a=a.correspondingUseElement);return 3===a.nodeType?a.parentNode:
a}function Tf(a){if(!wa)return!1;a="on"+a;var b=a in document;b||(b=document.createElement("div"),b.setAttribute(a,"return;"),b="function"===typeof b[a]);return b}function Uf(a){a.topLevelType=null;a.nativeEvent=null;a.targetInst=null;a.ancestors.length=0;10>qc.length&&qc.push(a)}function Vf(a,b,c,d){if(qc.length){var e=qc.pop();e.topLevelType=a;e.eventSystemFlags=d;e.nativeEvent=b;e.targetInst=c;return e}return{topLevelType:a,eventSystemFlags:d,nativeEvent:b,targetInst:c,ancestors:[]}}function Wf(a){var b=
a.targetInst,c=b;do{if(!c){a.ancestors.push(c);break}var d=c;if(3===d.tag)d=d.stateNode.containerInfo;else{for(;d.return;)d=d.return;d=3!==d.tag?null:d.stateNode.containerInfo}if(!d)break;b=c.tag;5!==b&&6!==b||a.ancestors.push(c);c=Bb(d)}while(c);for(c=0;c<a.ancestors.length;c++){b=a.ancestors[c];var e=Ld(a.nativeEvent);d=a.topLevelType;var f=a.nativeEvent,g=a.eventSystemFlags;0===c&&(g|=64);for(var h=null,m=0;m<jc.length;m++){var n=jc[m];n&&(n=n.extractEvents(d,b,f,e,g))&&(h=jb(h,n))}pc(h)}}function Md(a,
b,c){if(!c.has(a)){switch(a){case "scroll":Cb(b,"scroll",!0);break;case "focus":case "blur":Cb(b,"focus",!0);Cb(b,"blur",!0);c.set("blur",null);c.set("focus",null);break;case "cancel":case "close":Tf(a)&&Cb(b,a,!0);break;case "invalid":case "submit":case "reset":break;default:-1===Db.indexOf(a)&&w(a,b)}c.set(a,null)}}function xi(a,b){var c=Jd(b);Nd.forEach(function(a){Md(a,b,c)});yi.forEach(function(a){Md(a,b,c)})}function Od(a,b,c,d,e){return{blockedOn:a,topLevelType:b,eventSystemFlags:c|32,nativeEvent:e,
container:d}}function Xf(a,b){switch(a){case "focus":case "blur":xa=null;break;case "dragenter":case "dragleave":ya=null;break;case "mouseover":case "mouseout":za=null;break;case "pointerover":case "pointerout":Eb.delete(b.pointerId);break;case "gotpointercapture":case "lostpointercapture":Fb.delete(b.pointerId)}}function Gb(a,b,c,d,e,f){if(null===a||a.nativeEvent!==f)return a=Od(b,c,d,e,f),null!==b&&(b=Hb(b),null!==b&&Yf(b)),a;a.eventSystemFlags|=d;return a}function zi(a,b,c,d,e){switch(b){case "focus":return xa=
Gb(xa,a,b,c,d,e),!0;case "dragenter":return ya=Gb(ya,a,b,c,d,e),!0;case "mouseover":return za=Gb(za,a,b,c,d,e),!0;case "pointerover":var f=e.pointerId;Eb.set(f,Gb(Eb.get(f)||null,a,b,c,d,e));return!0;case "gotpointercapture":return f=e.pointerId,Fb.set(f,Gb(Fb.get(f)||null,a,b,c,d,e)),!0}return!1}function Ai(a){var b=Bb(a.target);if(null!==b){var c=Na(b);if(null!==c)if(b=c.tag,13===b){if(b=Qf(c),null!==b){a.blockedOn=b;Pd(a.priority,function(){Bi(c)});return}}else if(3===b&&c.stateNode.hydrate){a.blockedOn=
3===c.tag?c.stateNode.containerInfo:null;return}}a.blockedOn=null}function rc(a){if(null!==a.blockedOn)return!1;var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);if(null!==b){var c=Hb(b);null!==c&&Yf(c);a.blockedOn=b;return!1}return!0}function Zf(a,b,c){rc(a)&&c.delete(b)}function Ci(){for(Rd=!1;0<fa.length;){var a=fa[0];if(null!==a.blockedOn){a=Hb(a.blockedOn);null!==a&&Di(a);break}var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);null!==b?a.blockedOn=b:fa.shift()}null!==
xa&&rc(xa)&&(xa=null);null!==ya&&rc(ya)&&(ya=null);null!==za&&rc(za)&&(za=null);Eb.forEach(Zf);Fb.forEach(Zf)}function Ib(a,b){a.blockedOn===b&&(a.blockedOn=null,Rd||(Rd=!0,$f(ag,Ci)))}function bg(a){if(0<fa.length){Ib(fa[0],a);for(var b=1;b<fa.length;b++){var c=fa[b];c.blockedOn===a&&(c.blockedOn=null)}}null!==xa&&Ib(xa,a);null!==ya&&Ib(ya,a);null!==za&&Ib(za,a);b=function(b){return Ib(b,a)};Eb.forEach(b);Fb.forEach(b);for(b=0;b<Jb.length;b++)c=Jb[b],c.blockedOn===a&&(c.blockedOn=null);for(;0<Jb.length&&
(b=Jb[0],null===b.blockedOn);)Ai(b),null===b.blockedOn&&Jb.shift()}function Sd(a,b){for(var c=0;c<a.length;c+=2){var d=a[c],e=a[c+1],f="on"+(e[0].toUpperCase()+e.slice(1));f={phasedRegistrationNames:{bubbled:f,captured:f+"Capture"},dependencies:[d],eventPriority:b};Td.set(d,b);cg.set(d,f);dg[e]=f}}function w(a,b){Cb(b,a,!1)}function Cb(a,b,c){var d=Td.get(b);switch(void 0===d?2:d){case 0:d=Ei.bind(null,b,1,a);break;case 1:d=Fi.bind(null,b,1,a);break;default:d=sc.bind(null,b,1,a)}c?a.addEventListener(b,
d,!0):a.addEventListener(b,d,!1)}function Ei(a,b,c,d){Oa||vd();var e=sc,f=Oa;Oa=!0;try{eg(e,a,b,c,d)}finally{(Oa=f)||ud()}}function Fi(a,b,c,d){Gi(Hi,sc.bind(null,a,b,c,d))}function sc(a,b,c,d){if(tc)if(0<fa.length&&-1<Nd.indexOf(a))a=Od(null,a,b,c,d),fa.push(a);else{var e=Qd(a,b,c,d);if(null===e)Xf(a,d);else if(-1<Nd.indexOf(a))a=Od(e,a,b,c,d),fa.push(a);else if(!zi(e,a,b,c,d)){Xf(a,d);a=Vf(a,d,null,b);try{uf(Wf,a)}finally{Uf(a)}}}}function Qd(a,b,c,d){c=Ld(d);c=Bb(c);if(null!==c){var e=Na(c);if(null===
e)c=null;else{var f=e.tag;if(13===f){c=Qf(e);if(null!==c)return c;c=null}else if(3===f){if(e.stateNode.hydrate)return 3===e.tag?e.stateNode.containerInfo:null;c=null}else e!==c&&(c=null)}}a=Vf(a,d,c,b);try{uf(Wf,a)}finally{Uf(a)}return null}function fg(a,b,c){return null==b||"boolean"===typeof b||""===b?"":c||"number"!==typeof b||0===b||Kb.hasOwnProperty(a)&&Kb[a]?(""+b).trim():b+"px"}function gg(a,b){a=a.style;for(var c in b)if(b.hasOwnProperty(c)){var d=0===c.indexOf("--"),e=fg(c,b[c],d);"float"===
c&&(c="cssFloat");d?a.setProperty(c,e):a[c]=e}}function Ud(a,b){if(b){if(Ii[a]&&(null!=b.children||null!=b.dangerouslySetInnerHTML))throw Error(k(137,a,""));if(null!=b.dangerouslySetInnerHTML){if(null!=b.children)throw Error(k(60));if(!("object"===typeof b.dangerouslySetInnerHTML&&"__html"in b.dangerouslySetInnerHTML))throw Error(k(61));}if(null!=b.style&&"object"!==typeof b.style)throw Error(k(62,""));}}function Vd(a,b){if(-1===a.indexOf("-"))return"string"===typeof b.is;switch(a){case "annotation-xml":case "color-profile":case "font-face":case "font-face-src":case "font-face-uri":case "font-face-format":case "font-face-name":case "missing-glyph":return!1;
default:return!0}}function oa(a,b){a=9===a.nodeType||11===a.nodeType?a:a.ownerDocument;var c=Jd(a);b=rd[b];for(var d=0;d<b.length;d++)Md(b[d],a,c)}function uc(){}function Wd(a){a=a||("undefined"!==typeof document?document:void 0);if("undefined"===typeof a)return null;try{return a.activeElement||a.body}catch(b){return a.body}}function hg(a){for(;a&&a.firstChild;)a=a.firstChild;return a}function ig(a,b){var c=hg(a);a=0;for(var d;c;){if(3===c.nodeType){d=a+c.textContent.length;if(a<=b&&d>=b)return{node:c,
offset:b-a};a=d}a:{for(;c;){if(c.nextSibling){c=c.nextSibling;break a}c=c.parentNode}c=void 0}c=hg(c)}}function jg(a,b){return a&&b?a===b?!0:a&&3===a.nodeType?!1:b&&3===b.nodeType?jg(a,b.parentNode):"contains"in a?a.contains(b):a.compareDocumentPosition?!!(a.compareDocumentPosition(b)&16):!1:!1}function kg(){for(var a=window,b=Wd();b instanceof a.HTMLIFrameElement;){try{var c="string"===typeof b.contentWindow.location.href}catch(d){c=!1}if(c)a=b.contentWindow;else break;b=Wd(a.document)}return b}
function Xd(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return b&&("input"===b&&("text"===a.type||"search"===a.type||"tel"===a.type||"url"===a.type||"password"===a.type)||"textarea"===b||"true"===a.contentEditable)}function lg(a,b){switch(a){case "button":case "input":case "select":case "textarea":return!!b.autoFocus}return!1}function Yd(a,b){return"textarea"===a||"option"===a||"noscript"===a||"string"===typeof b.children||"number"===typeof b.children||"object"===typeof b.dangerouslySetInnerHTML&&
null!==b.dangerouslySetInnerHTML&&null!=b.dangerouslySetInnerHTML.__html}function kb(a){for(;null!=a;a=a.nextSibling){var b=a.nodeType;if(1===b||3===b)break}return a}function mg(a){a=a.previousSibling;for(var b=0;a;){if(8===a.nodeType){var c=a.data;if(c===ng||c===Zd||c===$d){if(0===b)return a;b--}else c===og&&b++}a=a.previousSibling}return null}function Bb(a){var b=a[Aa];if(b)return b;for(var c=a.parentNode;c;){if(b=c[Lb]||c[Aa]){c=b.alternate;if(null!==b.child||null!==c&&null!==c.child)for(a=mg(a);null!==
a;){if(c=a[Aa])return c;a=mg(a)}return b}a=c;c=a.parentNode}return null}function Hb(a){a=a[Aa]||a[Lb];return!a||5!==a.tag&&6!==a.tag&&13!==a.tag&&3!==a.tag?null:a}function Pa(a){if(5===a.tag||6===a.tag)return a.stateNode;throw Error(k(33));}function ae(a){return a[vc]||null}function pa(a){do a=a.return;while(a&&5!==a.tag);return a?a:null}function pg(a,b){var c=a.stateNode;if(!c)return null;var d=td(c);if(!d)return null;c=d[b];a:switch(b){case "onClick":case "onClickCapture":case "onDoubleClick":case "onDoubleClickCapture":case "onMouseDown":case "onMouseDownCapture":case "onMouseMove":case "onMouseMoveCapture":case "onMouseUp":case "onMouseUpCapture":case "onMouseEnter":(d=
!d.disabled)||(a=a.type,d=!("button"===a||"input"===a||"select"===a||"textarea"===a));a=!d;break a;default:a=!1}if(a)return null;if(c&&"function"!==typeof c)throw Error(k(231,b,typeof c));return c}function qg(a,b,c){if(b=pg(a,c.dispatchConfig.phasedRegistrationNames[b]))c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a)}function Ji(a){if(a&&a.dispatchConfig.phasedRegistrationNames){for(var b=a._targetInst,c=[];b;)c.push(b),b=pa(b);for(b=c.length;0<b--;)qg(c[b],
"captured",a);for(b=0;b<c.length;b++)qg(c[b],"bubbled",a)}}function be(a,b,c){a&&c&&c.dispatchConfig.registrationName&&(b=pg(a,c.dispatchConfig.registrationName))&&(c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a))}function Ki(a){a&&a.dispatchConfig.registrationName&&be(a._targetInst,null,a)}function lb(a){Kd(a,Ji)}function rg(){if(wc)return wc;var a,b=ce,c=b.length,d,e="value"in Ba?Ba.value:Ba.textContent,f=e.length;for(a=0;a<c&&b[a]===e[a];a++);var g=
c-a;for(d=1;d<=g&&b[c-d]===e[f-d];d++);return wc=e.slice(a,1<d?1-d:void 0)}function xc(){return!0}function yc(){return!1}function R(a,b,c,d){this.dispatchConfig=a;this._targetInst=b;this.nativeEvent=c;a=this.constructor.Interface;for(var e in a)a.hasOwnProperty(e)&&((b=a[e])?this[e]=b(c):"target"===e?this.target=d:this[e]=c[e]);this.isDefaultPrevented=(null!=c.defaultPrevented?c.defaultPrevented:!1===c.returnValue)?xc:yc;this.isPropagationStopped=yc;return this}function Li(a,b,c,d){if(this.eventPool.length){var e=
this.eventPool.pop();this.call(e,a,b,c,d);return e}return new this(a,b,c,d)}function Mi(a){if(!(a instanceof this))throw Error(k(279));a.destructor();10>this.eventPool.length&&this.eventPool.push(a)}function sg(a){a.eventPool=[];a.getPooled=Li;a.release=Mi}function tg(a,b){switch(a){case "keyup":return-1!==Ni.indexOf(b.keyCode);case "keydown":return 229!==b.keyCode;case "keypress":case "mousedown":case "blur":return!0;default:return!1}}function ug(a){a=a.detail;return"object"===typeof a&&"data"in
a?a.data:null}function Oi(a,b){switch(a){case "compositionend":return ug(b);case "keypress":if(32!==b.which)return null;vg=!0;return wg;case "textInput":return a=b.data,a===wg&&vg?null:a;default:return null}}function Pi(a,b){if(mb)return"compositionend"===a||!de&&tg(a,b)?(a=rg(),wc=ce=Ba=null,mb=!1,a):null;switch(a){case "paste":return null;case "keypress":if(!(b.ctrlKey||b.altKey||b.metaKey)||b.ctrlKey&&b.altKey){if(b.char&&1<b.char.length)return b.char;if(b.which)return String.fromCharCode(b.which)}return null;
case "compositionend":return xg&&"ko"!==b.locale?null:b.data;default:return null}}function yg(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return"input"===b?!!Qi[a.type]:"textarea"===b?!0:!1}function zg(a,b,c){a=R.getPooled(Ag.change,a,b,c);a.type="change";sf(c);lb(a);return a}function Ri(a){pc(a)}function zc(a){var b=Pa(a);if(Gf(b))return a}function Si(a,b){if("change"===a)return b}function Bg(){Mb&&(Mb.detachEvent("onpropertychange",Cg),Nb=Mb=null)}function Cg(a){if("value"===a.propertyName&&
zc(Nb))if(a=zg(Nb,a,Ld(a)),Oa)pc(a);else{Oa=!0;try{ee(Ri,a)}finally{Oa=!1,ud()}}}function Ti(a,b,c){"focus"===a?(Bg(),Mb=b,Nb=c,Mb.attachEvent("onpropertychange",Cg)):"blur"===a&&Bg()}function Ui(a,b){if("selectionchange"===a||"keyup"===a||"keydown"===a)return zc(Nb)}function Vi(a,b){if("click"===a)return zc(b)}function Wi(a,b){if("input"===a||"change"===a)return zc(b)}function Xi(a){var b=this.nativeEvent;return b.getModifierState?b.getModifierState(a):(a=Yi[a])?!!b[a]:!1}function fe(a){return Xi}
function Zi(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}function Ob(a,b){if(Qa(a,b))return!0;if("object"!==typeof a||null===a||"object"!==typeof b||null===b)return!1;var c=Object.keys(a),d=Object.keys(b);if(c.length!==d.length)return!1;for(d=0;d<c.length;d++)if(!$i.call(b,c[d])||!Qa(a[c[d]],b[c[d]]))return!1;return!0}function Dg(a,b){var c=b.window===b?b.document:9===b.nodeType?b:b.ownerDocument;if(ge||null==nb||nb!==Wd(c))return null;c=nb;"selectionStart"in c&&Xd(c)?c={start:c.selectionStart,
end:c.selectionEnd}:(c=(c.ownerDocument&&c.ownerDocument.defaultView||window).getSelection(),c={anchorNode:c.anchorNode,anchorOffset:c.anchorOffset,focusNode:c.focusNode,focusOffset:c.focusOffset});return Pb&&Ob(Pb,c)?null:(Pb=c,a=R.getPooled(Eg.select,he,a,b),a.type="select",a.target=nb,lb(a),a)}function Ac(a){var b=a.keyCode;"charCode"in a?(a=a.charCode,0===a&&13===b&&(a=13)):a=b;10===a&&(a=13);return 32<=a||13===a?a:0}function q(a,b){0>ob||(a.current=ie[ob],ie[ob]=null,ob--)}function y(a,b,c){ob++;
ie[ob]=a.current;a.current=b}function pb(a,b){var c=a.type.contextTypes;if(!c)return Ca;var d=a.stateNode;if(d&&d.__reactInternalMemoizedUnmaskedChildContext===b)return d.__reactInternalMemoizedMaskedChildContext;var e={},f;for(f in c)e[f]=b[f];d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=b,a.__reactInternalMemoizedMaskedChildContext=e);return e}function N(a){a=a.childContextTypes;return null!==a&&void 0!==a}function Fg(a,b,c){if(B.current!==Ca)throw Error(k(168));y(B,b);y(G,c)}
function Gg(a,b,c){var d=a.stateNode;a=b.childContextTypes;if("function"!==typeof d.getChildContext)return c;d=d.getChildContext();for(var e in d)if(!(e in a))throw Error(k(108,na(b)||"Unknown",e));return M({},c,{},d)}function Bc(a){a=(a=a.stateNode)&&a.__reactInternalMemoizedMergedChildContext||Ca;Ra=B.current;y(B,a);y(G,G.current);return!0}function Hg(a,b,c){var d=a.stateNode;if(!d)throw Error(k(169));c?(a=Gg(a,b,Ra),d.__reactInternalMemoizedMergedChildContext=a,q(G),q(B),y(B,a)):q(G);y(G,c)}function Cc(){switch(aj()){case Dc:return 99;
case Ig:return 98;case Jg:return 97;case Kg:return 96;case Lg:return 95;default:throw Error(k(332));}}function Mg(a){switch(a){case 99:return Dc;case 98:return Ig;case 97:return Jg;case 96:return Kg;case 95:return Lg;default:throw Error(k(332));}}function Da(a,b){a=Mg(a);return bj(a,b)}function Ng(a,b,c){a=Mg(a);return je(a,b,c)}function Og(a){null===qa?(qa=[a],Ec=je(Dc,Pg)):qa.push(a);return Qg}function ha(){if(null!==Ec){var a=Ec;Ec=null;Rg(a)}Pg()}function Pg(){if(!ke&&null!==qa){ke=!0;var a=0;
try{var b=qa;Da(99,function(){for(;a<b.length;a++){var c=b[a];do c=c(!0);while(null!==c)}});qa=null}catch(c){throw null!==qa&&(qa=qa.slice(a+1)),je(Dc,ha),c;}finally{ke=!1}}}function Fc(a,b,c){c/=10;return 1073741821-(((1073741821-a+b/10)/c|0)+1)*c}function aa(a,b){if(a&&a.defaultProps){b=M({},b);a=a.defaultProps;for(var c in a)void 0===b[c]&&(b[c]=a[c])}return b}function le(){Gc=qb=Hc=null}function me(a){var b=Ic.current;q(Ic);a.type._context._currentValue=b}function Sg(a,b){for(;null!==a;){var c=
a.alternate;if(a.childExpirationTime<b)a.childExpirationTime=b,null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);else if(null!==c&&c.childExpirationTime<b)c.childExpirationTime=b;else break;a=a.return}}function rb(a,b){Hc=a;Gc=qb=null;a=a.dependencies;null!==a&&null!==a.firstContext&&(a.expirationTime>=b&&(ia=!0),a.firstContext=null)}function W(a,b){if(Gc!==a&&!1!==b&&0!==b){if("number"!==typeof b||1073741823===b)Gc=a,b=1073741823;b={context:a,observedBits:b,next:null};if(null===qb){if(null===
Hc)throw Error(k(308));qb=b;Hc.dependencies={expirationTime:0,firstContext:b,responders:null}}else qb=qb.next=b}return a._currentValue}function ne(a){a.updateQueue={baseState:a.memoizedState,baseQueue:null,shared:{pending:null},effects:null}}function oe(a,b){a=a.updateQueue;b.updateQueue===a&&(b.updateQueue={baseState:a.baseState,baseQueue:a.baseQueue,shared:a.shared,effects:a.effects})}function Ea(a,b){a={expirationTime:a,suspenseConfig:b,tag:Tg,payload:null,callback:null,next:null};return a.next=
a}function Fa(a,b){a=a.updateQueue;if(null!==a){a=a.shared;var c=a.pending;null===c?b.next=b:(b.next=c.next,c.next=b);a.pending=b}}function Ug(a,b){var c=a.alternate;null!==c&&oe(c,a);a=a.updateQueue;c=a.baseQueue;null===c?(a.baseQueue=b.next=b,b.next=b):(b.next=c.next,c.next=b)}function Qb(a,b,c,d){var e=a.updateQueue;Ga=!1;var f=e.baseQueue,g=e.shared.pending;if(null!==g){if(null!==f){var h=f.next;f.next=g.next;g.next=h}f=g;e.shared.pending=null;h=a.alternate;null!==h&&(h=h.updateQueue,null!==h&&
(h.baseQueue=g))}if(null!==f){h=f.next;var m=e.baseState,n=0,k=null,ba=null,l=null;if(null!==h){var p=h;do{g=p.expirationTime;if(g<d){var t={expirationTime:p.expirationTime,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null};null===l?(ba=l=t,k=m):l=l.next=t;g>n&&(n=g)}else{null!==l&&(l=l.next={expirationTime:1073741823,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null});Vg(g,p.suspenseConfig);a:{var q=a,r=p;g=b;t=c;switch(r.tag){case 1:q=
r.payload;if("function"===typeof q){m=q.call(t,m,g);break a}m=q;break a;case 3:q.effectTag=q.effectTag&-4097|64;case Tg:q=r.payload;g="function"===typeof q?q.call(t,m,g):q;if(null===g||void 0===g)break a;m=M({},m,g);break a;case Jc:Ga=!0}}null!==p.callback&&(a.effectTag|=32,g=e.effects,null===g?e.effects=[p]:g.push(p))}p=p.next;if(null===p||p===h)if(g=e.shared.pending,null===g)break;else p=f.next=g.next,g.next=h,e.baseQueue=f=g,e.shared.pending=null}while(1)}null===l?k=m:l.next=ba;e.baseState=k;e.baseQueue=
l;Kc(n);a.expirationTime=n;a.memoizedState=m}}function Wg(a,b,c){a=b.effects;b.effects=null;if(null!==a)for(b=0;b<a.length;b++){var d=a[b],e=d.callback;if(null!==e){d.callback=null;d=e;e=c;if("function"!==typeof d)throw Error(k(191,d));d.call(e)}}}function Lc(a,b,c,d){b=a.memoizedState;c=c(d,b);c=null===c||void 0===c?b:M({},b,c);a.memoizedState=c;0===a.expirationTime&&(a.updateQueue.baseState=c)}function Xg(a,b,c,d,e,f,g){a=a.stateNode;return"function"===typeof a.shouldComponentUpdate?a.shouldComponentUpdate(d,
f,g):b.prototype&&b.prototype.isPureReactComponent?!Ob(c,d)||!Ob(e,f):!0}function Yg(a,b,c){var d=!1,e=Ca;var f=b.contextType;"object"===typeof f&&null!==f?f=W(f):(e=N(b)?Ra:B.current,d=b.contextTypes,f=(d=null!==d&&void 0!==d)?pb(a,e):Ca);b=new b(c,f);a.memoizedState=null!==b.state&&void 0!==b.state?b.state:null;b.updater=Mc;a.stateNode=b;b._reactInternalFiber=a;d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=e,a.__reactInternalMemoizedMaskedChildContext=f);return b}function Zg(a,
b,c,d){a=b.state;"function"===typeof b.componentWillReceiveProps&&b.componentWillReceiveProps(c,d);"function"===typeof b.UNSAFE_componentWillReceiveProps&&b.UNSAFE_componentWillReceiveProps(c,d);b.state!==a&&Mc.enqueueReplaceState(b,b.state,null)}function pe(a,b,c,d){var e=a.stateNode;e.props=c;e.state=a.memoizedState;e.refs=$g;ne(a);var f=b.contextType;"object"===typeof f&&null!==f?e.context=W(f):(f=N(b)?Ra:B.current,e.context=pb(a,f));Qb(a,c,e,d);e.state=a.memoizedState;f=b.getDerivedStateFromProps;
"function"===typeof f&&(Lc(a,b,f,c),e.state=a.memoizedState);"function"===typeof b.getDerivedStateFromProps||"function"===typeof e.getSnapshotBeforeUpdate||"function"!==typeof e.UNSAFE_componentWillMount&&"function"!==typeof e.componentWillMount||(b=e.state,"function"===typeof e.componentWillMount&&e.componentWillMount(),"function"===typeof e.UNSAFE_componentWillMount&&e.UNSAFE_componentWillMount(),b!==e.state&&Mc.enqueueReplaceState(e,e.state,null),Qb(a,c,e,d),e.state=a.memoizedState);"function"===
typeof e.componentDidMount&&(a.effectTag|=4)}function Rb(a,b,c){a=c.ref;if(null!==a&&"function"!==typeof a&&"object"!==typeof a){if(c._owner){c=c._owner;if(c){if(1!==c.tag)throw Error(k(309));var d=c.stateNode}if(!d)throw Error(k(147,a));var e=""+a;if(null!==b&&null!==b.ref&&"function"===typeof b.ref&&b.ref._stringRef===e)return b.ref;b=function(a){var b=d.refs;b===$g&&(b=d.refs={});null===a?delete b[e]:b[e]=a};b._stringRef=e;return b}if("string"!==typeof a)throw Error(k(284));if(!c._owner)throw Error(k(290,
a));}return a}function Nc(a,b){if("textarea"!==a.type)throw Error(k(31,"[object Object]"===Object.prototype.toString.call(b)?"object with keys {"+Object.keys(b).join(", ")+"}":b,""));}function ah(a){function b(b,c){if(a){var d=b.lastEffect;null!==d?(d.nextEffect=c,b.lastEffect=c):b.firstEffect=b.lastEffect=c;c.nextEffect=null;c.effectTag=8}}function c(c,d){if(!a)return null;for(;null!==d;)b(c,d),d=d.sibling;return null}function d(a,b){for(a=new Map;null!==b;)null!==b.key?a.set(b.key,b):a.set(b.index,
b),b=b.sibling;return a}function e(a,b){a=Sa(a,b);a.index=0;a.sibling=null;return a}function f(b,c,d){b.index=d;if(!a)return c;d=b.alternate;if(null!==d)return d=d.index,d<c?(b.effectTag=2,c):d;b.effectTag=2;return c}function g(b){a&&null===b.alternate&&(b.effectTag=2);return b}function h(a,b,c,d){if(null===b||6!==b.tag)return b=qe(c,a.mode,d),b.return=a,b;b=e(b,c);b.return=a;return b}function m(a,b,c,d){if(null!==b&&b.elementType===c.type)return d=e(b,c.props),d.ref=Rb(a,b,c),d.return=a,d;d=Oc(c.type,
c.key,c.props,null,a.mode,d);d.ref=Rb(a,b,c);d.return=a;return d}function n(a,b,c,d){if(null===b||4!==b.tag||b.stateNode.containerInfo!==c.containerInfo||b.stateNode.implementation!==c.implementation)return b=re(c,a.mode,d),b.return=a,b;b=e(b,c.children||[]);b.return=a;return b}function l(a,b,c,d,f){if(null===b||7!==b.tag)return b=Ha(c,a.mode,d,f),b.return=a,b;b=e(b,c);b.return=a;return b}function ba(a,b,c){if("string"===typeof b||"number"===typeof b)return b=qe(""+b,a.mode,c),b.return=a,b;if("object"===
typeof b&&null!==b){switch(b.$$typeof){case Pc:return c=Oc(b.type,b.key,b.props,null,a.mode,c),c.ref=Rb(a,null,b),c.return=a,c;case gb:return b=re(b,a.mode,c),b.return=a,b}if(Qc(b)||zb(b))return b=Ha(b,a.mode,c,null),b.return=a,b;Nc(a,b)}return null}function p(a,b,c,d){var e=null!==b?b.key:null;if("string"===typeof c||"number"===typeof c)return null!==e?null:h(a,b,""+c,d);if("object"===typeof c&&null!==c){switch(c.$$typeof){case Pc:return c.key===e?c.type===Ma?l(a,b,c.props.children,d,e):m(a,b,c,
d):null;case gb:return c.key===e?n(a,b,c,d):null}if(Qc(c)||zb(c))return null!==e?null:l(a,b,c,d,null);Nc(a,c)}return null}function t(a,b,c,d,e){if("string"===typeof d||"number"===typeof d)return a=a.get(c)||null,h(b,a,""+d,e);if("object"===typeof d&&null!==d){switch(d.$$typeof){case Pc:return a=a.get(null===d.key?c:d.key)||null,d.type===Ma?l(b,a,d.props.children,e,d.key):m(b,a,d,e);case gb:return a=a.get(null===d.key?c:d.key)||null,n(b,a,d,e)}if(Qc(d)||zb(d))return a=a.get(c)||null,l(b,a,d,e,null);
Nc(b,d)}return null}function q(e,g,h,m){for(var n=null,k=null,l=g,r=g=0,C=null;null!==l&&r<h.length;r++){l.index>r?(C=l,l=null):C=l.sibling;var O=p(e,l,h[r],m);if(null===O){null===l&&(l=C);break}a&&l&&null===O.alternate&&b(e,l);g=f(O,g,r);null===k?n=O:k.sibling=O;k=O;l=C}if(r===h.length)return c(e,l),n;if(null===l){for(;r<h.length;r++)l=ba(e,h[r],m),null!==l&&(g=f(l,g,r),null===k?n=l:k.sibling=l,k=l);return n}for(l=d(e,l);r<h.length;r++)C=t(l,e,r,h[r],m),null!==C&&(a&&null!==C.alternate&&l.delete(null===
C.key?r:C.key),g=f(C,g,r),null===k?n=C:k.sibling=C,k=C);a&&l.forEach(function(a){return b(e,a)});return n}function w(e,g,h,n){var m=zb(h);if("function"!==typeof m)throw Error(k(150));h=m.call(h);if(null==h)throw Error(k(151));for(var l=m=null,r=g,C=g=0,O=null,v=h.next();null!==r&&!v.done;C++,v=h.next()){r.index>C?(O=r,r=null):O=r.sibling;var q=p(e,r,v.value,n);if(null===q){null===r&&(r=O);break}a&&r&&null===q.alternate&&b(e,r);g=f(q,g,C);null===l?m=q:l.sibling=q;l=q;r=O}if(v.done)return c(e,r),m;
if(null===r){for(;!v.done;C++,v=h.next())v=ba(e,v.value,n),null!==v&&(g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);return m}for(r=d(e,r);!v.done;C++,v=h.next())v=t(r,e,C,v.value,n),null!==v&&(a&&null!==v.alternate&&r.delete(null===v.key?C:v.key),g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);a&&r.forEach(function(a){return b(e,a)});return m}return function(a,d,f,h){var m="object"===typeof f&&null!==f&&f.type===Ma&&null===f.key;m&&(f=f.props.children);var n="object"===typeof f&&null!==f;if(n)switch(f.$$typeof){case Pc:a:{n=
f.key;for(m=d;null!==m;){if(m.key===n){switch(m.tag){case 7:if(f.type===Ma){c(a,m.sibling);d=e(m,f.props.children);d.return=a;a=d;break a}break;default:if(m.elementType===f.type){c(a,m.sibling);d=e(m,f.props);d.ref=Rb(a,m,f);d.return=a;a=d;break a}}c(a,m);break}else b(a,m);m=m.sibling}f.type===Ma?(d=Ha(f.props.children,a.mode,h,f.key),d.return=a,a=d):(h=Oc(f.type,f.key,f.props,null,a.mode,h),h.ref=Rb(a,d,f),h.return=a,a=h)}return g(a);case gb:a:{for(m=f.key;null!==d;){if(d.key===m)if(4===d.tag&&d.stateNode.containerInfo===
f.containerInfo&&d.stateNode.implementation===f.implementation){c(a,d.sibling);d=e(d,f.children||[]);d.return=a;a=d;break a}else{c(a,d);break}else b(a,d);d=d.sibling}d=re(f,a.mode,h);d.return=a;a=d}return g(a)}if("string"===typeof f||"number"===typeof f)return f=""+f,null!==d&&6===d.tag?(c(a,d.sibling),d=e(d,f),d.return=a,a=d):(c(a,d),d=qe(f,a.mode,h),d.return=a,a=d),g(a);if(Qc(f))return q(a,d,f,h);if(zb(f))return w(a,d,f,h);n&&Nc(a,f);if("undefined"===typeof f&&!m)switch(a.tag){case 1:case 0:throw a=
a.type,Error(k(152,a.displayName||a.name||"Component"));}return c(a,d)}}function Ta(a){if(a===Sb)throw Error(k(174));return a}function se(a,b){y(Tb,b);y(Ub,a);y(ja,Sb);a=b.nodeType;switch(a){case 9:case 11:b=(b=b.documentElement)?b.namespaceURI:Hd(null,"");break;default:a=8===a?b.parentNode:b,b=a.namespaceURI||null,a=a.tagName,b=Hd(b,a)}q(ja);y(ja,b)}function tb(a){q(ja);q(Ub);q(Tb)}function bh(a){Ta(Tb.current);var b=Ta(ja.current);var c=Hd(b,a.type);b!==c&&(y(Ub,a),y(ja,c))}function te(a){Ub.current===
a&&(q(ja),q(Ub))}function Rc(a){for(var b=a;null!==b;){if(13===b.tag){var c=b.memoizedState;if(null!==c&&(c=c.dehydrated,null===c||c.data===$d||c.data===Zd))return b}else if(19===b.tag&&void 0!==b.memoizedProps.revealOrder){if(0!==(b.effectTag&64))return b}else if(null!==b.child){b.child.return=b;b=b.child;continue}if(b===a)break;for(;null===b.sibling;){if(null===b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}return null}function ue(a,b){return{responder:a,props:b}}
function S(){throw Error(k(321));}function ve(a,b){if(null===b)return!1;for(var c=0;c<b.length&&c<a.length;c++)if(!Qa(a[c],b[c]))return!1;return!0}function we(a,b,c,d,e,f){Ia=f;z=b;b.memoizedState=null;b.updateQueue=null;b.expirationTime=0;Sc.current=null===a||null===a.memoizedState?dj:ej;a=c(d,e);if(b.expirationTime===Ia){f=0;do{b.expirationTime=0;if(!(25>f))throw Error(k(301));f+=1;J=K=null;b.updateQueue=null;Sc.current=fj;a=c(d,e)}while(b.expirationTime===Ia)}Sc.current=Tc;b=null!==K&&null!==K.next;
Ia=0;J=K=z=null;Uc=!1;if(b)throw Error(k(300));return a}function ub(){var a={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};null===J?z.memoizedState=J=a:J=J.next=a;return J}function vb(){if(null===K){var a=z.alternate;a=null!==a?a.memoizedState:null}else a=K.next;var b=null===J?z.memoizedState:J.next;if(null!==b)J=b,K=a;else{if(null===a)throw Error(k(310));K=a;a={memoizedState:K.memoizedState,baseState:K.baseState,baseQueue:K.baseQueue,queue:K.queue,next:null};null===J?z.memoizedState=
J=a:J=J.next=a}return J}function Ua(a,b){return"function"===typeof b?b(a):b}function Vc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=K,e=d.baseQueue,f=c.pending;if(null!==f){if(null!==e){var g=e.next;e.next=f.next;f.next=g}d.baseQueue=e=f;c.pending=null}if(null!==e){e=e.next;d=d.baseState;var h=g=f=null,m=e;do{var n=m.expirationTime;if(n<Ia){var l={expirationTime:m.expirationTime,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,
next:null};null===h?(g=h=l,f=d):h=h.next=l;n>z.expirationTime&&(z.expirationTime=n,Kc(n))}else null!==h&&(h=h.next={expirationTime:1073741823,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,next:null}),Vg(n,m.suspenseConfig),d=m.eagerReducer===a?m.eagerState:a(d,m.action);m=m.next}while(null!==m&&m!==e);null===h?f=d:h.next=g;Qa(d,b.memoizedState)||(ia=!0);b.memoizedState=d;b.baseState=f;b.baseQueue=h;c.lastRenderedState=d}return[b.memoizedState,
c.dispatch]}function Wc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=c.dispatch,e=c.pending,f=b.memoizedState;if(null!==e){c.pending=null;var g=e=e.next;do f=a(f,g.action),g=g.next;while(g!==e);Qa(f,b.memoizedState)||(ia=!0);b.memoizedState=f;null===b.baseQueue&&(b.baseState=f);c.lastRenderedState=f}return[f,d]}function xe(a){var b=ub();"function"===typeof a&&(a=a());b.memoizedState=b.baseState=a;a=b.queue={pending:null,dispatch:null,lastRenderedReducer:Ua,
lastRenderedState:a};a=a.dispatch=ch.bind(null,z,a);return[b.memoizedState,a]}function ye(a,b,c,d){a={tag:a,create:b,destroy:c,deps:d,next:null};b=z.updateQueue;null===b?(b={lastEffect:null},z.updateQueue=b,b.lastEffect=a.next=a):(c=b.lastEffect,null===c?b.lastEffect=a.next=a:(d=c.next,c.next=a,a.next=d,b.lastEffect=a));return a}function dh(a){return vb().memoizedState}function ze(a,b,c,d){var e=ub();z.effectTag|=a;e.memoizedState=ye(1|b,c,void 0,void 0===d?null:d)}function Ae(a,b,c,d){var e=vb();
d=void 0===d?null:d;var f=void 0;if(null!==K){var g=K.memoizedState;f=g.destroy;if(null!==d&&ve(d,g.deps)){ye(b,c,f,d);return}}z.effectTag|=a;e.memoizedState=ye(1|b,c,f,d)}function eh(a,b){return ze(516,4,a,b)}function Xc(a,b){return Ae(516,4,a,b)}function fh(a,b){return Ae(4,2,a,b)}function gh(a,b){if("function"===typeof b)return a=a(),b(a),function(){b(null)};if(null!==b&&void 0!==b)return a=a(),b.current=a,function(){b.current=null}}function hh(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;
return Ae(4,2,gh.bind(null,b,a),c)}function Be(a,b){}function ih(a,b){ub().memoizedState=[a,void 0===b?null:b];return a}function Yc(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];c.memoizedState=[a,b];return a}function jh(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];a=a();c.memoizedState=[a,b];return a}function Ce(a,b,c){var d=Cc();Da(98>d?98:d,function(){a(!0)});Da(97<d?97:d,function(){var d=
X.suspense;X.suspense=void 0===b?null:b;try{a(!1),c()}finally{X.suspense=d}})}function ch(a,b,c){var d=ka(),e=Vb.suspense;d=Va(d,a,e);e={expirationTime:d,suspenseConfig:e,action:c,eagerReducer:null,eagerState:null,next:null};var f=b.pending;null===f?e.next=e:(e.next=f.next,f.next=e);b.pending=e;f=a.alternate;if(a===z||null!==f&&f===z)Uc=!0,e.expirationTime=Ia,z.expirationTime=Ia;else{if(0===a.expirationTime&&(null===f||0===f.expirationTime)&&(f=b.lastRenderedReducer,null!==f))try{var g=b.lastRenderedState,
h=f(g,c);e.eagerReducer=f;e.eagerState=h;if(Qa(h,g))return}catch(m){}finally{}Ja(a,d)}}function kh(a,b){var c=la(5,null,null,0);c.elementType="DELETED";c.type="DELETED";c.stateNode=b;c.return=a;c.effectTag=8;null!==a.lastEffect?(a.lastEffect.nextEffect=c,a.lastEffect=c):a.firstEffect=a.lastEffect=c}function lh(a,b){switch(a.tag){case 5:var c=a.type;b=1!==b.nodeType||c.toLowerCase()!==b.nodeName.toLowerCase()?null:b;return null!==b?(a.stateNode=b,!0):!1;case 6:return b=""===a.pendingProps||3!==b.nodeType?
null:b,null!==b?(a.stateNode=b,!0):!1;case 13:return!1;default:return!1}}function De(a){if(Wa){var b=Ka;if(b){var c=b;if(!lh(a,b)){b=kb(c.nextSibling);if(!b||!lh(a,b)){a.effectTag=a.effectTag&-1025|2;Wa=!1;ra=a;return}kh(ra,c)}ra=a;Ka=kb(b.firstChild)}else a.effectTag=a.effectTag&-1025|2,Wa=!1,ra=a}}function mh(a){for(a=a.return;null!==a&&5!==a.tag&&3!==a.tag&&13!==a.tag;)a=a.return;ra=a}function Zc(a){if(a!==ra)return!1;if(!Wa)return mh(a),Wa=!0,!1;var b=a.type;if(5!==a.tag||"head"!==b&&"body"!==
b&&!Yd(b,a.memoizedProps))for(b=Ka;b;)kh(a,b),b=kb(b.nextSibling);mh(a);if(13===a.tag){a=a.memoizedState;a=null!==a?a.dehydrated:null;if(!a)throw Error(k(317));a:{a=a.nextSibling;for(b=0;a;){if(8===a.nodeType){var c=a.data;if(c===og){if(0===b){Ka=kb(a.nextSibling);break a}b--}else c!==ng&&c!==Zd&&c!==$d||b++}a=a.nextSibling}Ka=null}}else Ka=ra?kb(a.stateNode.nextSibling):null;return!0}function Ee(){Ka=ra=null;Wa=!1}function T(a,b,c,d){b.child=null===a?Fe(b,null,c,d):wb(b,a.child,c,d)}function nh(a,
b,c,d,e){c=c.render;var f=b.ref;rb(b,e);d=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,d,e);return b.child}function oh(a,b,c,d,e,f){if(null===a){var g=c.type;if("function"===typeof g&&!Ge(g)&&void 0===g.defaultProps&&null===c.compare&&void 0===c.defaultProps)return b.tag=15,b.type=g,ph(a,b,g,d,e,f);a=Oc(c.type,null,d,null,b.mode,f);a.ref=b.ref;a.return=b;return b.child=a}g=a.child;if(e<
f&&(e=g.memoizedProps,c=c.compare,c=null!==c?c:Ob,c(e,d)&&a.ref===b.ref))return sa(a,b,f);b.effectTag|=1;a=Sa(g,d);a.ref=b.ref;a.return=b;return b.child=a}function ph(a,b,c,d,e,f){return null!==a&&Ob(a.memoizedProps,d)&&a.ref===b.ref&&(ia=!1,e<f)?(b.expirationTime=a.expirationTime,sa(a,b,f)):He(a,b,c,d,f)}function qh(a,b){var c=b.ref;if(null===a&&null!==c||null!==a&&a.ref!==c)b.effectTag|=128}function He(a,b,c,d,e){var f=N(c)?Ra:B.current;f=pb(b,f);rb(b,e);c=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=
a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,c,e);return b.child}function rh(a,b,c,d,e){if(N(c)){var f=!0;Bc(b)}else f=!1;rb(b,e);if(null===b.stateNode)null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),Yg(b,c,d),pe(b,c,d,e),d=!0;else if(null===a){var g=b.stateNode,h=b.memoizedProps;g.props=h;var m=g.context,n=c.contextType;"object"===typeof n&&null!==n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n));var l=c.getDerivedStateFromProps,k="function"===
typeof l||"function"===typeof g.getSnapshotBeforeUpdate;k||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n);Ga=!1;var p=b.memoizedState;g.state=p;Qb(b,d,g,e);m=b.memoizedState;h!==d||p!==m||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),m=b.memoizedState),(h=Ga||Xg(b,c,h,d,p,m,n))?(k||"function"!==typeof g.UNSAFE_componentWillMount&&"function"!==typeof g.componentWillMount||("function"===typeof g.componentWillMount&&
g.componentWillMount(),"function"===typeof g.UNSAFE_componentWillMount&&g.UNSAFE_componentWillMount()),"function"===typeof g.componentDidMount&&(b.effectTag|=4)):("function"===typeof g.componentDidMount&&(b.effectTag|=4),b.memoizedProps=d,b.memoizedState=m),g.props=d,g.state=m,g.context=n,d=h):("function"===typeof g.componentDidMount&&(b.effectTag|=4),d=!1)}else g=b.stateNode,oe(a,b),h=b.memoizedProps,g.props=b.type===b.elementType?h:aa(b.type,h),m=g.context,n=c.contextType,"object"===typeof n&&null!==
n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n)),l=c.getDerivedStateFromProps,(k="function"===typeof l||"function"===typeof g.getSnapshotBeforeUpdate)||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n),Ga=!1,m=b.memoizedState,g.state=m,Qb(b,d,g,e),p=b.memoizedState,h!==d||m!==p||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),p=b.memoizedState),(l=Ga||Xg(b,c,h,d,m,p,n))?(k||"function"!==typeof g.UNSAFE_componentWillUpdate&&
"function"!==typeof g.componentWillUpdate||("function"===typeof g.componentWillUpdate&&g.componentWillUpdate(d,p,n),"function"===typeof g.UNSAFE_componentWillUpdate&&g.UNSAFE_componentWillUpdate(d,p,n)),"function"===typeof g.componentDidUpdate&&(b.effectTag|=4),"function"===typeof g.getSnapshotBeforeUpdate&&(b.effectTag|=256)):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===
a.memoizedState||(b.effectTag|=256),b.memoizedProps=d,b.memoizedState=p),g.props=d,g.state=p,g.context=n,d=l):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=256),d=!1);return Ie(a,b,c,d,f,e)}function Ie(a,b,c,d,e,f){qh(a,b);var g=0!==(b.effectTag&64);if(!d&&!g)return e&&Hg(b,c,!1),sa(a,b,f);d=b.stateNode;gj.current=b;var h=g&&"function"!==typeof c.getDerivedStateFromError?
null:d.render();b.effectTag|=1;null!==a&&g?(b.child=wb(b,a.child,null,f),b.child=wb(b,null,h,f)):T(a,b,h,f);b.memoizedState=d.state;e&&Hg(b,c,!0);return b.child}function sh(a){var b=a.stateNode;b.pendingContext?Fg(a,b.pendingContext,b.pendingContext!==b.context):b.context&&Fg(a,b.context,!1);se(a,b.containerInfo)}function th(a,b,c){var d=b.mode,e=b.pendingProps,f=D.current,g=!1,h;(h=0!==(b.effectTag&64))||(h=0!==(f&2)&&(null===a||null!==a.memoizedState));h?(g=!0,b.effectTag&=-65):null!==a&&null===
a.memoizedState||void 0===e.fallback||!0===e.unstable_avoidThisFallback||(f|=1);y(D,f&1);if(null===a){void 0!==e.fallback&&De(b);if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;b.memoizedState=Je;b.child=e;return c}d=e.children;b.memoizedState=null;return b.child=Fe(b,null,d,c)}if(null!==a.memoizedState){a=a.child;d=a.sibling;if(g){e=e.fallback;
c=Sa(a,a.pendingProps);c.return=b;if(0===(b.mode&2)&&(g=null!==b.memoizedState?b.child.child:b.child,g!==a.child))for(c.child=g;null!==g;)g.return=c,g=g.sibling;d=Sa(d,e);d.return=b;c.sibling=d;c.childExpirationTime=0;b.memoizedState=Je;b.child=c;return d}c=wb(b,a.child,e.children,c);b.memoizedState=null;return b.child=c}a=a.child;if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;e.child=a;null!==a&&(a.return=e);if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==
a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;c.effectTag|=2;e.childExpirationTime=0;b.memoizedState=Je;b.child=e;return c}b.memoizedState=null;return b.child=wb(b,a,e.children,c)}function uh(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);Sg(a.return,b)}function Ke(a,b,c,d,e,f){var g=a.memoizedState;null===g?a.memoizedState={isBackwards:b,rendering:null,renderingStartTime:0,last:d,tail:c,tailExpiration:0,tailMode:e,
lastEffect:f}:(g.isBackwards=b,g.rendering=null,g.renderingStartTime=0,g.last=d,g.tail=c,g.tailExpiration=0,g.tailMode=e,g.lastEffect=f)}function vh(a,b,c){var d=b.pendingProps,e=d.revealOrder,f=d.tail;T(a,b,d.children,c);d=D.current;if(0!==(d&2))d=d&1|2,b.effectTag|=64;else{if(null!==a&&0!==(a.effectTag&64))a:for(a=b.child;null!==a;){if(13===a.tag)null!==a.memoizedState&&uh(a,c);else if(19===a.tag)uh(a,c);else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===b)break a;for(;null===a.sibling;){if(null===
a.return||a.return===b)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}d&=1}y(D,d);if(0===(b.mode&2))b.memoizedState=null;else switch(e){case "forwards":c=b.child;for(e=null;null!==c;)a=c.alternate,null!==a&&null===Rc(a)&&(e=c),c=c.sibling;c=e;null===c?(e=b.child,b.child=null):(e=c.sibling,c.sibling=null);Ke(b,!1,e,c,f,b.lastEffect);break;case "backwards":c=null;e=b.child;for(b.child=null;null!==e;){a=e.alternate;if(null!==a&&null===Rc(a)){b.child=e;break}a=e.sibling;e.sibling=c;c=e;e=a}Ke(b,
!0,c,null,f,b.lastEffect);break;case "together":Ke(b,!1,null,null,void 0,b.lastEffect);break;default:b.memoizedState=null}return b.child}function sa(a,b,c){null!==a&&(b.dependencies=a.dependencies);var d=b.expirationTime;0!==d&&Kc(d);if(b.childExpirationTime<c)return null;if(null!==a&&b.child!==a.child)throw Error(k(153));if(null!==b.child){a=b.child;c=Sa(a,a.pendingProps);b.child=c;for(c.return=b;null!==a.sibling;)a=a.sibling,c=c.sibling=Sa(a,a.pendingProps),c.return=b;c.sibling=null}return b.child}
function $c(a,b){switch(a.tailMode){case "hidden":b=a.tail;for(var c=null;null!==b;)null!==b.alternate&&(c=b),b=b.sibling;null===c?a.tail=null:c.sibling=null;break;case "collapsed":c=a.tail;for(var d=null;null!==c;)null!==c.alternate&&(d=c),c=c.sibling;null===d?b||null===a.tail?a.tail=null:a.tail.sibling=null:d.sibling=null}}function hj(a,b,c){var d=b.pendingProps;switch(b.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return null;case 1:return N(b.type)&&(q(G),q(B)),
null;case 3:return tb(),q(G),q(B),c=b.stateNode,c.pendingContext&&(c.context=c.pendingContext,c.pendingContext=null),null!==a&&null!==a.child||!Zc(b)||(b.effectTag|=4),wh(b),null;case 5:te(b);c=Ta(Tb.current);var e=b.type;if(null!==a&&null!=b.stateNode)ij(a,b,e,d,c),a.ref!==b.ref&&(b.effectTag|=128);else{if(!d){if(null===b.stateNode)throw Error(k(166));return null}a=Ta(ja.current);if(Zc(b)){d=b.stateNode;e=b.type;var f=b.memoizedProps;d[Aa]=b;d[vc]=f;switch(e){case "iframe":case "object":case "embed":w("load",
d);break;case "video":case "audio":for(a=0;a<Db.length;a++)w(Db[a],d);break;case "source":w("error",d);break;case "img":case "image":case "link":w("error",d);w("load",d);break;case "form":w("reset",d);w("submit",d);break;case "details":w("toggle",d);break;case "input":Hf(d,f);w("invalid",d);oa(c,"onChange");break;case "select":d._wrapperState={wasMultiple:!!f.multiple};w("invalid",d);oa(c,"onChange");break;case "textarea":Kf(d,f),w("invalid",d),oa(c,"onChange")}Ud(e,f);a=null;for(var g in f)if(f.hasOwnProperty(g)){var h=
f[g];"children"===g?"string"===typeof h?d.textContent!==h&&(a=["children",h]):"number"===typeof h&&d.textContent!==""+h&&(a=["children",""+h]):db.hasOwnProperty(g)&&null!=h&&oa(c,g)}switch(e){case "input":mc(d);Jf(d,f,!0);break;case "textarea":mc(d);Mf(d);break;case "select":case "option":break;default:"function"===typeof f.onClick&&(d.onclick=uc)}c=a;b.updateQueue=c;null!==c&&(b.effectTag|=4)}else{g=9===c.nodeType?c:c.ownerDocument;"http://www.w3.org/1999/xhtml"===a&&(a=Nf(e));"http://www.w3.org/1999/xhtml"===
a?"script"===e?(a=g.createElement("div"),a.innerHTML="<script>\x3c/script>",a=a.removeChild(a.firstChild)):"string"===typeof d.is?a=g.createElement(e,{is:d.is}):(a=g.createElement(e),"select"===e&&(g=a,d.multiple?g.multiple=!0:d.size&&(g.size=d.size))):a=g.createElementNS(a,e);a[Aa]=b;a[vc]=d;jj(a,b,!1,!1);b.stateNode=a;g=Vd(e,d);switch(e){case "iframe":case "object":case "embed":w("load",a);h=d;break;case "video":case "audio":for(h=0;h<Db.length;h++)w(Db[h],a);h=d;break;case "source":w("error",a);
h=d;break;case "img":case "image":case "link":w("error",a);w("load",a);h=d;break;case "form":w("reset",a);w("submit",a);h=d;break;case "details":w("toggle",a);h=d;break;case "input":Hf(a,d);h=Cd(a,d);w("invalid",a);oa(c,"onChange");break;case "option":h=Fd(a,d);break;case "select":a._wrapperState={wasMultiple:!!d.multiple};h=M({},d,{value:void 0});w("invalid",a);oa(c,"onChange");break;case "textarea":Kf(a,d);h=Gd(a,d);w("invalid",a);oa(c,"onChange");break;default:h=d}Ud(e,h);var m=h;for(f in m)if(m.hasOwnProperty(f)){var n=
m[f];"style"===f?gg(a,n):"dangerouslySetInnerHTML"===f?(n=n?n.__html:void 0,null!=n&&xh(a,n)):"children"===f?"string"===typeof n?("textarea"!==e||""!==n)&&Wb(a,n):"number"===typeof n&&Wb(a,""+n):"suppressContentEditableWarning"!==f&&"suppressHydrationWarning"!==f&&"autoFocus"!==f&&(db.hasOwnProperty(f)?null!=n&&oa(c,f):null!=n&&xd(a,f,n,g))}switch(e){case "input":mc(a);Jf(a,d,!1);break;case "textarea":mc(a);Mf(a);break;case "option":null!=d.value&&a.setAttribute("value",""+va(d.value));break;case "select":a.multiple=
!!d.multiple;c=d.value;null!=c?hb(a,!!d.multiple,c,!1):null!=d.defaultValue&&hb(a,!!d.multiple,d.defaultValue,!0);break;default:"function"===typeof h.onClick&&(a.onclick=uc)}lg(e,d)&&(b.effectTag|=4)}null!==b.ref&&(b.effectTag|=128)}return null;case 6:if(a&&null!=b.stateNode)kj(a,b,a.memoizedProps,d);else{if("string"!==typeof d&&null===b.stateNode)throw Error(k(166));c=Ta(Tb.current);Ta(ja.current);Zc(b)?(c=b.stateNode,d=b.memoizedProps,c[Aa]=b,c.nodeValue!==d&&(b.effectTag|=4)):(c=(9===c.nodeType?
c:c.ownerDocument).createTextNode(d),c[Aa]=b,b.stateNode=c)}return null;case 13:q(D);d=b.memoizedState;if(0!==(b.effectTag&64))return b.expirationTime=c,b;c=null!==d;d=!1;null===a?void 0!==b.memoizedProps.fallback&&Zc(b):(e=a.memoizedState,d=null!==e,c||null===e||(e=a.child.sibling,null!==e&&(f=b.firstEffect,null!==f?(b.firstEffect=e,e.nextEffect=f):(b.firstEffect=b.lastEffect=e,e.nextEffect=null),e.effectTag=8)));if(c&&!d&&0!==(b.mode&2))if(null===a&&!0!==b.memoizedProps.unstable_avoidThisFallback||
0!==(D.current&1))F===Xa&&(F=ad);else{if(F===Xa||F===ad)F=bd;0!==Xb&&null!==U&&(Ya(U,P),yh(U,Xb))}if(c||d)b.effectTag|=4;return null;case 4:return tb(),wh(b),null;case 10:return me(b),null;case 17:return N(b.type)&&(q(G),q(B)),null;case 19:q(D);d=b.memoizedState;if(null===d)return null;e=0!==(b.effectTag&64);f=d.rendering;if(null===f)if(e)$c(d,!1);else{if(F!==Xa||null!==a&&0!==(a.effectTag&64))for(f=b.child;null!==f;){a=Rc(f);if(null!==a){b.effectTag|=64;$c(d,!1);e=a.updateQueue;null!==e&&(b.updateQueue=
e,b.effectTag|=4);null===d.lastEffect&&(b.firstEffect=null);b.lastEffect=d.lastEffect;for(d=b.child;null!==d;)e=d,f=c,e.effectTag&=2,e.nextEffect=null,e.firstEffect=null,e.lastEffect=null,a=e.alternate,null===a?(e.childExpirationTime=0,e.expirationTime=f,e.child=null,e.memoizedProps=null,e.memoizedState=null,e.updateQueue=null,e.dependencies=null):(e.childExpirationTime=a.childExpirationTime,e.expirationTime=a.expirationTime,e.child=a.child,e.memoizedProps=a.memoizedProps,e.memoizedState=a.memoizedState,
e.updateQueue=a.updateQueue,f=a.dependencies,e.dependencies=null===f?null:{expirationTime:f.expirationTime,firstContext:f.firstContext,responders:f.responders}),d=d.sibling;y(D,D.current&1|2);return b.child}f=f.sibling}}else{if(!e)if(a=Rc(f),null!==a){if(b.effectTag|=64,e=!0,c=a.updateQueue,null!==c&&(b.updateQueue=c,b.effectTag|=4),$c(d,!0),null===d.tail&&"hidden"===d.tailMode&&!f.alternate)return b=b.lastEffect=d.lastEffect,null!==b&&(b.nextEffect=null),null}else 2*Y()-d.renderingStartTime>d.tailExpiration&&
1<c&&(b.effectTag|=64,e=!0,$c(d,!1),b.expirationTime=b.childExpirationTime=c-1);d.isBackwards?(f.sibling=b.child,b.child=f):(c=d.last,null!==c?c.sibling=f:b.child=f,d.last=f)}return null!==d.tail?(0===d.tailExpiration&&(d.tailExpiration=Y()+500),c=d.tail,d.rendering=c,d.tail=c.sibling,d.lastEffect=b.lastEffect,d.renderingStartTime=Y(),c.sibling=null,b=D.current,y(D,e?b&1|2:b&1),c):null}throw Error(k(156,b.tag));}function lj(a,b){switch(a.tag){case 1:return N(a.type)&&(q(G),q(B)),b=a.effectTag,b&4096?
(a.effectTag=b&-4097|64,a):null;case 3:tb();q(G);q(B);b=a.effectTag;if(0!==(b&64))throw Error(k(285));a.effectTag=b&-4097|64;return a;case 5:return te(a),null;case 13:return q(D),b=a.effectTag,b&4096?(a.effectTag=b&-4097|64,a):null;case 19:return q(D),null;case 4:return tb(),null;case 10:return me(a),null;default:return null}}function Le(a,b){return{value:a,source:b,stack:Bd(b)}}function Me(a,b){var c=b.source,d=b.stack;null===d&&null!==c&&(d=Bd(c));null!==c&&na(c.type);b=b.value;null!==a&&1===a.tag&&
na(a.type);try{console.error(b)}catch(e){setTimeout(function(){throw e;})}}function mj(a,b){try{b.props=a.memoizedProps,b.state=a.memoizedState,b.componentWillUnmount()}catch(c){Za(a,c)}}function zh(a){var b=a.ref;if(null!==b)if("function"===typeof b)try{b(null)}catch(c){Za(a,c)}else b.current=null}function nj(a,b){switch(b.tag){case 0:case 11:case 15:case 22:return;case 1:if(b.effectTag&256&&null!==a){var c=a.memoizedProps,d=a.memoizedState;a=b.stateNode;b=a.getSnapshotBeforeUpdate(b.elementType===
b.type?c:aa(b.type,c),d);a.__reactInternalSnapshotBeforeUpdate=b}return;case 3:case 5:case 6:case 4:case 17:return}throw Error(k(163));}function Ah(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.destroy;c.destroy=void 0;void 0!==d&&d()}c=c.next}while(c!==b)}}function Bh(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.create;c.destroy=d()}c=c.next}while(c!==b)}}function oj(a,b,c,d){switch(c.tag){case 0:case 11:case 15:case 22:Bh(3,
c);return;case 1:a=c.stateNode;c.effectTag&4&&(null===b?a.componentDidMount():(d=c.elementType===c.type?b.memoizedProps:aa(c.type,b.memoizedProps),a.componentDidUpdate(d,b.memoizedState,a.__reactInternalSnapshotBeforeUpdate)));b=c.updateQueue;null!==b&&Wg(c,b,a);return;case 3:b=c.updateQueue;if(null!==b){a=null;if(null!==c.child)switch(c.child.tag){case 5:a=c.child.stateNode;break;case 1:a=c.child.stateNode}Wg(c,b,a)}return;case 5:a=c.stateNode;null===b&&c.effectTag&4&&lg(c.type,c.memoizedProps)&&
a.focus();return;case 6:return;case 4:return;case 12:return;case 13:null===c.memoizedState&&(c=c.alternate,null!==c&&(c=c.memoizedState,null!==c&&(c=c.dehydrated,null!==c&&bg(c))));return;case 19:case 17:case 20:case 21:return}throw Error(k(163));}function Ch(a,b,c){"function"===typeof Ne&&Ne(b);switch(b.tag){case 0:case 11:case 14:case 15:case 22:a=b.updateQueue;if(null!==a&&(a=a.lastEffect,null!==a)){var d=a.next;Da(97<c?97:c,function(){var a=d;do{var c=a.destroy;if(void 0!==c){var g=b;try{c()}catch(h){Za(g,
h)}}a=a.next}while(a!==d)})}break;case 1:zh(b);c=b.stateNode;"function"===typeof c.componentWillUnmount&&mj(b,c);break;case 5:zh(b);break;case 4:Dh(a,b,c)}}function Eh(a){var b=a.alternate;a.return=null;a.child=null;a.memoizedState=null;a.updateQueue=null;a.dependencies=null;a.alternate=null;a.firstEffect=null;a.lastEffect=null;a.pendingProps=null;a.memoizedProps=null;a.stateNode=null;null!==b&&Eh(b)}function Fh(a){return 5===a.tag||3===a.tag||4===a.tag}function Gh(a){a:{for(var b=a.return;null!==
b;){if(Fh(b)){var c=b;break a}b=b.return}throw Error(k(160));}b=c.stateNode;switch(c.tag){case 5:var d=!1;break;case 3:b=b.containerInfo;d=!0;break;case 4:b=b.containerInfo;d=!0;break;default:throw Error(k(161));}c.effectTag&16&&(Wb(b,""),c.effectTag&=-17);a:b:for(c=a;;){for(;null===c.sibling;){if(null===c.return||Fh(c.return)){c=null;break a}c=c.return}c.sibling.return=c.return;for(c=c.sibling;5!==c.tag&&6!==c.tag&&18!==c.tag;){if(c.effectTag&2)continue b;if(null===c.child||4===c.tag)continue b;
else c.child.return=c,c=c.child}if(!(c.effectTag&2)){c=c.stateNode;break a}}d?Oe(a,c,b):Pe(a,c,b)}function Oe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?8===c.nodeType?c.parentNode.insertBefore(a,b):c.insertBefore(a,b):(8===c.nodeType?(b=c.parentNode,b.insertBefore(a,c)):(b=c,b.appendChild(a)),c=c._reactRootContainer,null!==c&&void 0!==c||null!==b.onclick||(b.onclick=uc));else if(4!==d&&(a=a.child,null!==a))for(Oe(a,b,c),a=a.sibling;null!==a;)Oe(a,b,c),a=a.sibling}
function Pe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?c.insertBefore(a,b):c.appendChild(a);else if(4!==d&&(a=a.child,null!==a))for(Pe(a,b,c),a=a.sibling;null!==a;)Pe(a,b,c),a=a.sibling}function Dh(a,b,c){for(var d=b,e=!1,f,g;;){if(!e){e=d.return;a:for(;;){if(null===e)throw Error(k(160));f=e.stateNode;switch(e.tag){case 5:g=!1;break a;case 3:f=f.containerInfo;g=!0;break a;case 4:f=f.containerInfo;g=!0;break a}e=e.return}e=!0}if(5===d.tag||6===d.tag){a:for(var h=
a,m=d,n=c,l=m;;)if(Ch(h,l,n),null!==l.child&&4!==l.tag)l.child.return=l,l=l.child;else{if(l===m)break a;for(;null===l.sibling;){if(null===l.return||l.return===m)break a;l=l.return}l.sibling.return=l.return;l=l.sibling}g?(h=f,m=d.stateNode,8===h.nodeType?h.parentNode.removeChild(m):h.removeChild(m)):f.removeChild(d.stateNode)}else if(4===d.tag){if(null!==d.child){f=d.stateNode.containerInfo;g=!0;d.child.return=d;d=d.child;continue}}else if(Ch(a,d,c),null!==d.child){d.child.return=d;d=d.child;continue}if(d===
b)break;for(;null===d.sibling;){if(null===d.return||d.return===b)return;d=d.return;4===d.tag&&(e=!1)}d.sibling.return=d.return;d=d.sibling}}function Qe(a,b){switch(b.tag){case 0:case 11:case 14:case 15:case 22:Ah(3,b);return;case 1:return;case 5:var c=b.stateNode;if(null!=c){var d=b.memoizedProps,e=null!==a?a.memoizedProps:d;a=b.type;var f=b.updateQueue;b.updateQueue=null;if(null!==f){c[vc]=d;"input"===a&&"radio"===d.type&&null!=d.name&&If(c,d);Vd(a,e);b=Vd(a,d);for(e=0;e<f.length;e+=2){var g=f[e],
h=f[e+1];"style"===g?gg(c,h):"dangerouslySetInnerHTML"===g?xh(c,h):"children"===g?Wb(c,h):xd(c,g,h,b)}switch(a){case "input":Dd(c,d);break;case "textarea":Lf(c,d);break;case "select":b=c._wrapperState.wasMultiple,c._wrapperState.wasMultiple=!!d.multiple,a=d.value,null!=a?hb(c,!!d.multiple,a,!1):b!==!!d.multiple&&(null!=d.defaultValue?hb(c,!!d.multiple,d.defaultValue,!0):hb(c,!!d.multiple,d.multiple?[]:"",!1))}}}return;case 6:if(null===b.stateNode)throw Error(k(162));b.stateNode.nodeValue=b.memoizedProps;
return;case 3:b=b.stateNode;b.hydrate&&(b.hydrate=!1,bg(b.containerInfo));return;case 12:return;case 13:c=b;null===b.memoizedState?d=!1:(d=!0,c=b.child,Re=Y());if(null!==c)a:for(a=c;;){if(5===a.tag)f=a.stateNode,d?(f=f.style,"function"===typeof f.setProperty?f.setProperty("display","none","important"):f.display="none"):(f=a.stateNode,e=a.memoizedProps.style,e=void 0!==e&&null!==e&&e.hasOwnProperty("display")?e.display:null,f.style.display=fg("display",e));else if(6===a.tag)a.stateNode.nodeValue=d?
"":a.memoizedProps;else if(13===a.tag&&null!==a.memoizedState&&null===a.memoizedState.dehydrated){f=a.child.sibling;f.return=a;a=f;continue}else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===c)break;for(;null===a.sibling;){if(null===a.return||a.return===c)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}Hh(b);return;case 19:Hh(b);return;case 17:return}throw Error(k(163));}function Hh(a){var b=a.updateQueue;if(null!==b){a.updateQueue=null;var c=a.stateNode;null===c&&(c=a.stateNode=
new pj);b.forEach(function(b){var d=qj.bind(null,a,b);c.has(b)||(c.add(b),b.then(d,d))})}}function Ih(a,b,c){c=Ea(c,null);c.tag=3;c.payload={element:null};var d=b.value;c.callback=function(){cd||(cd=!0,Se=d);Me(a,b)};return c}function Jh(a,b,c){c=Ea(c,null);c.tag=3;var d=a.type.getDerivedStateFromError;if("function"===typeof d){var e=b.value;c.payload=function(){Me(a,b);return d(e)}}var f=a.stateNode;null!==f&&"function"===typeof f.componentDidCatch&&(c.callback=function(){"function"!==typeof d&&
(null===La?La=new Set([this]):La.add(this),Me(a,b));var c=b.stack;this.componentDidCatch(b.value,{componentStack:null!==c?c:""})});return c}function ka(){return(p&(ca|ma))!==H?1073741821-(Y()/10|0):0!==dd?dd:dd=1073741821-(Y()/10|0)}function Va(a,b,c){b=b.mode;if(0===(b&2))return 1073741823;var d=Cc();if(0===(b&4))return 99===d?1073741823:1073741822;if((p&ca)!==H)return P;if(null!==c)a=Fc(a,c.timeoutMs|0||5E3,250);else switch(d){case 99:a=1073741823;break;case 98:a=Fc(a,150,100);break;case 97:case 96:a=
Fc(a,5E3,250);break;case 95:a=2;break;default:throw Error(k(326));}null!==U&&a===P&&--a;return a}function ed(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);var d=a.return,e=null;if(null===d&&3===a.tag)e=a.stateNode;else for(;null!==d;){c=d.alternate;d.childExpirationTime<b&&(d.childExpirationTime=b);null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);if(null===d.return&&3===d.tag){e=d.stateNode;break}d=d.return}null!==e&&
(U===e&&(Kc(b),F===bd&&Ya(e,P)),yh(e,b));return e}function fd(a){var b=a.lastExpiredTime;if(0!==b)return b;b=a.firstPendingTime;if(!Kh(a,b))return b;var c=a.lastPingedTime;a=a.nextKnownPendingLevel;a=c>a?c:a;return 2>=a&&b!==a?0:a}function V(a){if(0!==a.lastExpiredTime)a.callbackExpirationTime=1073741823,a.callbackPriority=99,a.callbackNode=Og(Te.bind(null,a));else{var b=fd(a),c=a.callbackNode;if(0===b)null!==c&&(a.callbackNode=null,a.callbackExpirationTime=0,a.callbackPriority=90);else{var d=ka();
1073741823===b?d=99:1===b||2===b?d=95:(d=10*(1073741821-b)-10*(1073741821-d),d=0>=d?99:250>=d?98:5250>=d?97:95);if(null!==c){var e=a.callbackPriority;if(a.callbackExpirationTime===b&&e>=d)return;c!==Qg&&Rg(c)}a.callbackExpirationTime=b;a.callbackPriority=d;b=1073741823===b?Og(Te.bind(null,a)):Ng(d,Lh.bind(null,a),{timeout:10*(1073741821-b)-Y()});a.callbackNode=b}}}function Lh(a,b){dd=0;if(b)return b=ka(),Ue(a,b),V(a),null;var c=fd(a);if(0!==c){b=a.callbackNode;if((p&(ca|ma))!==H)throw Error(k(327));
xb();a===U&&c===P||$a(a,c);if(null!==t){var d=p;p|=ca;var e=Mh();do try{rj();break}catch(h){Nh(a,h)}while(1);le();p=d;gd.current=e;if(F===hd)throw b=id,$a(a,c),Ya(a,c),V(a),b;if(null===t)switch(e=a.finishedWork=a.current.alternate,a.finishedExpirationTime=c,d=F,U=null,d){case Xa:case hd:throw Error(k(345));case Oh:Ue(a,2<c?2:c);break;case ad:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(1073741823===ta&&(e=Re+Ph-Y(),10<e)){if(jd){var f=a.lastPingedTime;if(0===f||f>=c){a.lastPingedTime=
c;$a(a,c);break}}f=fd(a);if(0!==f&&f!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}a.timeoutHandle=We(ab.bind(null,a),e);break}ab(a);break;case bd:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(jd&&(e=a.lastPingedTime,0===e||e>=c)){a.lastPingedTime=c;$a(a,c);break}e=fd(a);if(0!==e&&e!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}1073741823!==Yb?d=10*(1073741821-Yb)-Y():1073741823===ta?d=0:(d=10*(1073741821-ta)-5E3,e=Y(),c=10*(1073741821-c)-e,d=e-d,0>d&&(d=0),d=
(120>d?120:480>d?480:1080>d?1080:1920>d?1920:3E3>d?3E3:4320>d?4320:1960*sj(d/1960))-d,c<d&&(d=c));if(10<d){a.timeoutHandle=We(ab.bind(null,a),d);break}ab(a);break;case Xe:if(1073741823!==ta&&null!==kd){f=ta;var g=kd;d=g.busyMinDurationMs|0;0>=d?d=0:(e=g.busyDelayMs|0,f=Y()-(10*(1073741821-f)-(g.timeoutMs|0||5E3)),d=f<=e?0:e+d-f);if(10<d){Ya(a,c);a.timeoutHandle=We(ab.bind(null,a),d);break}}ab(a);break;default:throw Error(k(329));}V(a);if(a.callbackNode===b)return Lh.bind(null,a)}}return null}function Te(a){var b=
a.lastExpiredTime;b=0!==b?b:1073741823;if((p&(ca|ma))!==H)throw Error(k(327));xb();a===U&&b===P||$a(a,b);if(null!==t){var c=p;p|=ca;var d=Mh();do try{tj();break}catch(e){Nh(a,e)}while(1);le();p=c;gd.current=d;if(F===hd)throw c=id,$a(a,b),Ya(a,b),V(a),c;if(null!==t)throw Error(k(261));a.finishedWork=a.current.alternate;a.finishedExpirationTime=b;U=null;ab(a);V(a)}return null}function uj(){if(null!==bb){var a=bb;bb=null;a.forEach(function(a,c){Ue(c,a);V(c)});ha()}}function Qh(a,b){var c=p;p|=1;try{return a(b)}finally{p=
c,p===H&&ha()}}function Rh(a,b){var c=p;p&=-2;p|=Ye;try{return a(b)}finally{p=c,p===H&&ha()}}function $a(a,b){a.finishedWork=null;a.finishedExpirationTime=0;var c=a.timeoutHandle;-1!==c&&(a.timeoutHandle=-1,vj(c));if(null!==t)for(c=t.return;null!==c;){var d=c;switch(d.tag){case 1:d=d.type.childContextTypes;null!==d&&void 0!==d&&(q(G),q(B));break;case 3:tb();q(G);q(B);break;case 5:te(d);break;case 4:tb();break;case 13:q(D);break;case 19:q(D);break;case 10:me(d)}c=c.return}U=a;t=Sa(a.current,null);
P=b;F=Xa;id=null;Yb=ta=1073741823;kd=null;Xb=0;jd=!1}function Nh(a,b){do{try{le();Sc.current=Tc;if(Uc)for(var c=z.memoizedState;null!==c;){var d=c.queue;null!==d&&(d.pending=null);c=c.next}Ia=0;J=K=z=null;Uc=!1;if(null===t||null===t.return)return F=hd,id=b,t=null;a:{var e=a,f=t.return,g=t,h=b;b=P;g.effectTag|=2048;g.firstEffect=g.lastEffect=null;if(null!==h&&"object"===typeof h&&"function"===typeof h.then){var m=h;if(0===(g.mode&2)){var n=g.alternate;n?(g.updateQueue=n.updateQueue,g.memoizedState=
n.memoizedState,g.expirationTime=n.expirationTime):(g.updateQueue=null,g.memoizedState=null)}var l=0!==(D.current&1),k=f;do{var p;if(p=13===k.tag){var q=k.memoizedState;if(null!==q)p=null!==q.dehydrated?!0:!1;else{var w=k.memoizedProps;p=void 0===w.fallback?!1:!0!==w.unstable_avoidThisFallback?!0:l?!1:!0}}if(p){var y=k.updateQueue;if(null===y){var r=new Set;r.add(m);k.updateQueue=r}else y.add(m);if(0===(k.mode&2)){k.effectTag|=64;g.effectTag&=-2981;if(1===g.tag)if(null===g.alternate)g.tag=17;else{var O=
Ea(1073741823,null);O.tag=Jc;Fa(g,O)}g.expirationTime=1073741823;break a}h=void 0;g=b;var v=e.pingCache;null===v?(v=e.pingCache=new wj,h=new Set,v.set(m,h)):(h=v.get(m),void 0===h&&(h=new Set,v.set(m,h)));if(!h.has(g)){h.add(g);var x=xj.bind(null,e,m,g);m.then(x,x)}k.effectTag|=4096;k.expirationTime=b;break a}k=k.return}while(null!==k);h=Error((na(g.type)||"A React component")+" suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display."+
Bd(g))}F!==Xe&&(F=Oh);h=Le(h,g);k=f;do{switch(k.tag){case 3:m=h;k.effectTag|=4096;k.expirationTime=b;var A=Ih(k,m,b);Ug(k,A);break a;case 1:m=h;var u=k.type,B=k.stateNode;if(0===(k.effectTag&64)&&("function"===typeof u.getDerivedStateFromError||null!==B&&"function"===typeof B.componentDidCatch&&(null===La||!La.has(B)))){k.effectTag|=4096;k.expirationTime=b;var H=Jh(k,m,b);Ug(k,H);break a}}k=k.return}while(null!==k)}t=Sh(t)}catch(cj){b=cj;continue}break}while(1)}function Mh(a){a=gd.current;gd.current=
Tc;return null===a?Tc:a}function Vg(a,b){a<ta&&2<a&&(ta=a);null!==b&&a<Yb&&2<a&&(Yb=a,kd=b)}function Kc(a){a>Xb&&(Xb=a)}function tj(){for(;null!==t;)t=Th(t)}function rj(){for(;null!==t&&!yj();)t=Th(t)}function Th(a){var b=zj(a.alternate,a,P);a.memoizedProps=a.pendingProps;null===b&&(b=Sh(a));Uh.current=null;return b}function Sh(a){t=a;do{var b=t.alternate;a=t.return;if(0===(t.effectTag&2048)){b=hj(b,t,P);if(1===P||1!==t.childExpirationTime){for(var c=0,d=t.child;null!==d;){var e=d.expirationTime,
f=d.childExpirationTime;e>c&&(c=e);f>c&&(c=f);d=d.sibling}t.childExpirationTime=c}if(null!==b)return b;null!==a&&0===(a.effectTag&2048)&&(null===a.firstEffect&&(a.firstEffect=t.firstEffect),null!==t.lastEffect&&(null!==a.lastEffect&&(a.lastEffect.nextEffect=t.firstEffect),a.lastEffect=t.lastEffect),1<t.effectTag&&(null!==a.lastEffect?a.lastEffect.nextEffect=t:a.firstEffect=t,a.lastEffect=t))}else{b=lj(t);if(null!==b)return b.effectTag&=2047,b;null!==a&&(a.firstEffect=a.lastEffect=null,a.effectTag|=
2048)}b=t.sibling;if(null!==b)return b;t=a}while(null!==t);F===Xa&&(F=Xe);return null}function Ve(a){var b=a.expirationTime;a=a.childExpirationTime;return b>a?b:a}function ab(a){var b=Cc();Da(99,Aj.bind(null,a,b));return null}function Aj(a,b){do xb();while(null!==Zb);if((p&(ca|ma))!==H)throw Error(k(327));var c=a.finishedWork,d=a.finishedExpirationTime;if(null===c)return null;a.finishedWork=null;a.finishedExpirationTime=0;if(c===a.current)throw Error(k(177));a.callbackNode=null;a.callbackExpirationTime=
0;a.callbackPriority=90;a.nextKnownPendingLevel=0;var e=Ve(c);a.firstPendingTime=e;d<=a.lastSuspendedTime?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:d<=a.firstSuspendedTime&&(a.firstSuspendedTime=d-1);d<=a.lastPingedTime&&(a.lastPingedTime=0);d<=a.lastExpiredTime&&(a.lastExpiredTime=0);a===U&&(t=U=null,P=0);1<c.effectTag?null!==c.lastEffect?(c.lastEffect.nextEffect=c,e=c.firstEffect):e=c:e=c.firstEffect;if(null!==e){var f=p;p|=ma;Uh.current=null;Ze=tc;var g=kg();if(Xd(g)){if("selectionStart"in
g)var h={start:g.selectionStart,end:g.selectionEnd};else a:{h=(h=g.ownerDocument)&&h.defaultView||window;var m=h.getSelection&&h.getSelection();if(m&&0!==m.rangeCount){h=m.anchorNode;var n=m.anchorOffset,q=m.focusNode;m=m.focusOffset;try{h.nodeType,q.nodeType}catch(sb){h=null;break a}var ba=0,w=-1,y=-1,B=0,D=0,r=g,z=null;b:for(;;){for(var v;;){r!==h||0!==n&&3!==r.nodeType||(w=ba+n);r!==q||0!==m&&3!==r.nodeType||(y=ba+m);3===r.nodeType&&(ba+=r.nodeValue.length);if(null===(v=r.firstChild))break;z=r;
r=v}for(;;){if(r===g)break b;z===h&&++B===n&&(w=ba);z===q&&++D===m&&(y=ba);if(null!==(v=r.nextSibling))break;r=z;z=r.parentNode}r=v}h=-1===w||-1===y?null:{start:w,end:y}}else h=null}h=h||{start:0,end:0}}else h=null;$e={activeElementDetached:null,focusedElem:g,selectionRange:h};tc=!1;l=e;do try{Bj()}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=e;do try{for(g=a,h=b;null!==l;){var x=l.effectTag;x&16&&Wb(l.stateNode,"");if(x&128){var A=l.alternate;if(null!==A){var u=
A.ref;null!==u&&("function"===typeof u?u(null):u.current=null)}}switch(x&1038){case 2:Gh(l);l.effectTag&=-3;break;case 6:Gh(l);l.effectTag&=-3;Qe(l.alternate,l);break;case 1024:l.effectTag&=-1025;break;case 1028:l.effectTag&=-1025;Qe(l.alternate,l);break;case 4:Qe(l.alternate,l);break;case 8:n=l,Dh(g,n,h),Eh(n)}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);u=$e;A=kg();x=u.focusedElem;h=u.selectionRange;if(A!==x&&x&&x.ownerDocument&&jg(x.ownerDocument.documentElement,
x)){null!==h&&Xd(x)&&(A=h.start,u=h.end,void 0===u&&(u=A),"selectionStart"in x?(x.selectionStart=A,x.selectionEnd=Math.min(u,x.value.length)):(u=(A=x.ownerDocument||document)&&A.defaultView||window,u.getSelection&&(u=u.getSelection(),n=x.textContent.length,g=Math.min(h.start,n),h=void 0===h.end?g:Math.min(h.end,n),!u.extend&&g>h&&(n=h,h=g,g=n),n=ig(x,g),q=ig(x,h),n&&q&&(1!==u.rangeCount||u.anchorNode!==n.node||u.anchorOffset!==n.offset||u.focusNode!==q.node||u.focusOffset!==q.offset)&&(A=A.createRange(),
A.setStart(n.node,n.offset),u.removeAllRanges(),g>h?(u.addRange(A),u.extend(q.node,q.offset)):(A.setEnd(q.node,q.offset),u.addRange(A))))));A=[];for(u=x;u=u.parentNode;)1===u.nodeType&&A.push({element:u,left:u.scrollLeft,top:u.scrollTop});"function"===typeof x.focus&&x.focus();for(x=0;x<A.length;x++)u=A[x],u.element.scrollLeft=u.left,u.element.scrollTop=u.top}tc=!!Ze;$e=Ze=null;a.current=c;l=e;do try{for(x=a;null!==l;){var F=l.effectTag;F&36&&oj(x,l.alternate,l);if(F&128){A=void 0;var E=l.ref;if(null!==
E){var G=l.stateNode;switch(l.tag){case 5:A=G;break;default:A=G}"function"===typeof E?E(A):E.current=A}}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=null;Cj();p=f}else a.current=c;if(ld)ld=!1,Zb=a,$b=b;else for(l=e;null!==l;)b=l.nextEffect,l.nextEffect=null,l=b;b=a.firstPendingTime;0===b&&(La=null);1073741823===b?a===af?ac++:(ac=0,af=a):ac=0;"function"===typeof bf&&bf(c.stateNode,d);V(a);if(cd)throw cd=!1,a=Se,Se=null,a;if((p&Ye)!==H)return null;
ha();return null}function Bj(){for(;null!==l;){var a=l.effectTag;0!==(a&256)&&nj(l.alternate,l);0===(a&512)||ld||(ld=!0,Ng(97,function(){xb();return null}));l=l.nextEffect}}function xb(){if(90!==$b){var a=97<$b?97:$b;$b=90;return Da(a,Dj)}}function Dj(){if(null===Zb)return!1;var a=Zb;Zb=null;if((p&(ca|ma))!==H)throw Error(k(331));var b=p;p|=ma;for(a=a.current.firstEffect;null!==a;){try{var c=a;if(0!==(c.effectTag&512))switch(c.tag){case 0:case 11:case 15:case 22:Ah(5,c),Bh(5,c)}}catch(d){if(null===
a)throw Error(k(330));Za(a,d)}c=a.nextEffect;a.nextEffect=null;a=c}p=b;ha();return!0}function Vh(a,b,c){b=Le(c,b);b=Ih(a,b,1073741823);Fa(a,b);a=ed(a,1073741823);null!==a&&V(a)}function Za(a,b){if(3===a.tag)Vh(a,a,b);else for(var c=a.return;null!==c;){if(3===c.tag){Vh(c,a,b);break}else if(1===c.tag){var d=c.stateNode;if("function"===typeof c.type.getDerivedStateFromError||"function"===typeof d.componentDidCatch&&(null===La||!La.has(d))){a=Le(b,a);a=Jh(c,a,1073741823);Fa(c,a);c=ed(c,1073741823);null!==
c&&V(c);break}}c=c.return}}function xj(a,b,c){var d=a.pingCache;null!==d&&d.delete(b);U===a&&P===c?F===bd||F===ad&&1073741823===ta&&Y()-Re<Ph?$a(a,P):jd=!0:Kh(a,c)&&(b=a.lastPingedTime,0!==b&&b<c||(a.lastPingedTime=c,V(a)))}function qj(a,b){var c=a.stateNode;null!==c&&c.delete(b);b=0;0===b&&(b=ka(),b=Va(b,a,null));a=ed(a,b);null!==a&&V(a)}function Ej(a){if("undefined"===typeof __REACT_DEVTOOLS_GLOBAL_HOOK__)return!1;var b=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(b.isDisabled||!b.supportsFiber)return!0;try{var c=
b.inject(a);bf=function(a,e){try{b.onCommitFiberRoot(c,a,void 0,64===(a.current.effectTag&64))}catch(f){}};Ne=function(a){try{b.onCommitFiberUnmount(c,a)}catch(e){}}}catch(d){}return!0}function Fj(a,b,c,d){this.tag=a;this.key=c;this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null;this.index=0;this.ref=null;this.pendingProps=b;this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null;this.mode=d;this.effectTag=0;this.lastEffect=this.firstEffect=this.nextEffect=
null;this.childExpirationTime=this.expirationTime=0;this.alternate=null}function Ge(a){a=a.prototype;return!(!a||!a.isReactComponent)}function Gj(a){if("function"===typeof a)return Ge(a)?1:0;if(void 0!==a&&null!==a){a=a.$$typeof;if(a===zd)return 11;if(a===Ad)return 14}return 2}function Sa(a,b){var c=a.alternate;null===c?(c=la(a.tag,b,a.key,a.mode),c.elementType=a.elementType,c.type=a.type,c.stateNode=a.stateNode,c.alternate=a,a.alternate=c):(c.pendingProps=b,c.effectTag=0,c.nextEffect=null,c.firstEffect=
null,c.lastEffect=null);c.childExpirationTime=a.childExpirationTime;c.expirationTime=a.expirationTime;c.child=a.child;c.memoizedProps=a.memoizedProps;c.memoizedState=a.memoizedState;c.updateQueue=a.updateQueue;b=a.dependencies;c.dependencies=null===b?null:{expirationTime:b.expirationTime,firstContext:b.firstContext,responders:b.responders};c.sibling=a.sibling;c.index=a.index;c.ref=a.ref;return c}function Oc(a,b,c,d,e,f){var g=2;d=a;if("function"===typeof a)Ge(a)&&(g=1);else if("string"===typeof a)g=
5;else a:switch(a){case Ma:return Ha(c.children,e,f,b);case Hj:g=8;e|=7;break;case Af:g=8;e|=1;break;case kc:return a=la(12,c,b,e|8),a.elementType=kc,a.type=kc,a.expirationTime=f,a;case lc:return a=la(13,c,b,e),a.type=lc,a.elementType=lc,a.expirationTime=f,a;case yd:return a=la(19,c,b,e),a.elementType=yd,a.expirationTime=f,a;default:if("object"===typeof a&&null!==a)switch(a.$$typeof){case Cf:g=10;break a;case Bf:g=9;break a;case zd:g=11;break a;case Ad:g=14;break a;case Ef:g=16;d=null;break a;case Df:g=
22;break a}throw Error(k(130,null==a?a:typeof a,""));}b=la(g,c,b,e);b.elementType=a;b.type=d;b.expirationTime=f;return b}function Ha(a,b,c,d){a=la(7,a,d,b);a.expirationTime=c;return a}function qe(a,b,c){a=la(6,a,null,b);a.expirationTime=c;return a}function re(a,b,c){b=la(4,null!==a.children?a.children:[],a.key,b);b.expirationTime=c;b.stateNode={containerInfo:a.containerInfo,pendingChildren:null,implementation:a.implementation};return b}function Ij(a,b,c){this.tag=b;this.current=null;this.containerInfo=
a;this.pingCache=this.pendingChildren=null;this.finishedExpirationTime=0;this.finishedWork=null;this.timeoutHandle=-1;this.pendingContext=this.context=null;this.hydrate=c;this.callbackNode=null;this.callbackPriority=90;this.lastExpiredTime=this.lastPingedTime=this.nextKnownPendingLevel=this.lastSuspendedTime=this.firstSuspendedTime=this.firstPendingTime=0}function Kh(a,b){var c=a.firstSuspendedTime;a=a.lastSuspendedTime;return 0!==c&&c>=b&&a<=b}function Ya(a,b){var c=a.firstSuspendedTime,d=a.lastSuspendedTime;
c<b&&(a.firstSuspendedTime=b);if(d>b||0===c)a.lastSuspendedTime=b;b<=a.lastPingedTime&&(a.lastPingedTime=0);b<=a.lastExpiredTime&&(a.lastExpiredTime=0)}function yh(a,b){b>a.firstPendingTime&&(a.firstPendingTime=b);var c=a.firstSuspendedTime;0!==c&&(b>=c?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:b>=a.lastSuspendedTime&&(a.lastSuspendedTime=b+1),b>a.nextKnownPendingLevel&&(a.nextKnownPendingLevel=b))}function Ue(a,b){var c=a.lastExpiredTime;if(0===c||c>b)a.lastExpiredTime=b}
function md(a,b,c,d){var e=b.current,f=ka(),g=Vb.suspense;f=Va(f,e,g);a:if(c){c=c._reactInternalFiber;b:{if(Na(c)!==c||1!==c.tag)throw Error(k(170));var h=c;do{switch(h.tag){case 3:h=h.stateNode.context;break b;case 1:if(N(h.type)){h=h.stateNode.__reactInternalMemoizedMergedChildContext;break b}}h=h.return}while(null!==h);throw Error(k(171));}if(1===c.tag){var m=c.type;if(N(m)){c=Gg(c,m,h);break a}}c=h}else c=Ca;null===b.context?b.context=c:b.pendingContext=c;b=Ea(f,g);b.payload={element:a};d=void 0===
d?null:d;null!==d&&(b.callback=d);Fa(e,b);Ja(e,f);return f}function cf(a){a=a.current;if(!a.child)return null;switch(a.child.tag){case 5:return a.child.stateNode;default:return a.child.stateNode}}function Wh(a,b){a=a.memoizedState;null!==a&&null!==a.dehydrated&&a.retryTime<b&&(a.retryTime=b)}function df(a,b){Wh(a,b);(a=a.alternate)&&Wh(a,b)}function ef(a,b,c){c=null!=c&&!0===c.hydrate;var d=new Ij(a,b,c),e=la(3,null,null,2===b?7:1===b?3:0);d.current=e;e.stateNode=d;ne(e);a[Lb]=d.current;c&&0!==b&&
xi(a,9===a.nodeType?a:a.ownerDocument);this._internalRoot=d}function bc(a){return!(!a||1!==a.nodeType&&9!==a.nodeType&&11!==a.nodeType&&(8!==a.nodeType||" react-mount-point-unstable "!==a.nodeValue))}function Jj(a,b){b||(b=a?9===a.nodeType?a.documentElement:a.firstChild:null,b=!(!b||1!==b.nodeType||!b.hasAttribute("data-reactroot")));if(!b)for(var c;c=a.lastChild;)a.removeChild(c);return new ef(a,0,b?{hydrate:!0}:void 0)}function nd(a,b,c,d,e){var f=c._reactRootContainer;if(f){var g=f._internalRoot;
if("function"===typeof e){var h=e;e=function(){var a=cf(g);h.call(a)}}md(b,g,a,e)}else{f=c._reactRootContainer=Jj(c,d);g=f._internalRoot;if("function"===typeof e){var m=e;e=function(){var a=cf(g);m.call(a)}}Rh(function(){md(b,g,a,e)})}return cf(g)}function Kj(a,b,c){var d=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:gb,key:null==d?null:""+d,children:a,containerInfo:b,implementation:c}}function Xh(a,b){var c=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;
if(!bc(b))throw Error(k(200));return Kj(a,b,null,c)}if(!ea)throw Error(k(227));var ki=function(a,b,c,d,e,f,g,h,m){var n=Array.prototype.slice.call(arguments,3);try{b.apply(c,n)}catch(C){this.onError(C)}},yb=!1,gc=null,hc=!1,pd=null,li={onError:function(a){yb=!0;gc=a}},td=null,rf=null,mf=null,ic=null,cb={},jc=[],qd={},db={},rd={},wa=!("undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement),M=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.assign,
sd=null,eb=null,fb=null,ee=function(a,b){return a(b)},eg=function(a,b,c,d,e){return a(b,c,d,e)},vd=function(){},vf=ee,Oa=!1,wd=!1,Z=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.Scheduler,Lj=Z.unstable_cancelCallback,ff=Z.unstable_now,$f=Z.unstable_scheduleCallback,Mj=Z.unstable_shouldYield,Yh=Z.unstable_requestPaint,Pd=Z.unstable_runWithPriority,Nj=Z.unstable_getCurrentPriorityLevel,Oj=Z.unstable_ImmediatePriority,Zh=Z.unstable_UserBlockingPriority,ag=Z.unstable_NormalPriority,Pj=Z.unstable_LowPriority,
Qj=Z.unstable_IdlePriority,oi=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,wf=Object.prototype.hasOwnProperty,yf={},xf={},E={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a){E[a]=
new L(a,0,!1,a,null,!1)});[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(a){var b=a[0];E[b]=new L(b,1,!1,a[1],null,!1)});["contentEditable","draggable","spellCheck","value"].forEach(function(a){E[a]=new L(a,2,!1,a.toLowerCase(),null,!1)});["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(a){E[a]=new L(a,2,!1,a,null,!1)});"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a){E[a]=
new L(a,3,!1,a.toLowerCase(),null,!1)});["checked","multiple","muted","selected"].forEach(function(a){E[a]=new L(a,3,!0,a,null,!1)});["capture","download"].forEach(function(a){E[a]=new L(a,4,!1,a,null,!1)});["cols","rows","size","span"].forEach(function(a){E[a]=new L(a,6,!1,a,null,!1)});["rowSpan","start"].forEach(function(a){E[a]=new L(a,5,!1,a.toLowerCase(),null,!1)});var gf=/[\-:]([a-z])/g,hf=function(a){return a[1].toUpperCase()};"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a){var b=
a.replace(gf,hf);E[b]=new L(b,1,!1,a,null,!1)});"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/1999/xlink",!1)});["xml:base","xml:lang","xml:space"].forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/XML/1998/namespace",!1)});["tabIndex","crossOrigin"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!1)});E.xlinkHref=new L("xlinkHref",1,
!1,"xlink:href","http://www.w3.org/1999/xlink",!0);["src","href","action","formAction"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!0)});var da=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;da.hasOwnProperty("ReactCurrentDispatcher")||(da.ReactCurrentDispatcher={current:null});da.hasOwnProperty("ReactCurrentBatchConfig")||(da.ReactCurrentBatchConfig={suspense:null});var si=/^(.*)[\\\/]/,Q="function"===typeof Symbol&&Symbol.for,Pc=Q?Symbol.for("react.element"):60103,gb=Q?Symbol.for("react.portal"):
60106,Ma=Q?Symbol.for("react.fragment"):60107,Af=Q?Symbol.for("react.strict_mode"):60108,kc=Q?Symbol.for("react.profiler"):60114,Cf=Q?Symbol.for("react.provider"):60109,Bf=Q?Symbol.for("react.context"):60110,Hj=Q?Symbol.for("react.concurrent_mode"):60111,zd=Q?Symbol.for("react.forward_ref"):60112,lc=Q?Symbol.for("react.suspense"):60113,yd=Q?Symbol.for("react.suspense_list"):60120,Ad=Q?Symbol.for("react.memo"):60115,Ef=Q?Symbol.for("react.lazy"):60116,Df=Q?Symbol.for("react.block"):60121,zf="function"===
typeof Symbol&&Symbol.iterator,od,xh=function(a){return"undefined"!==typeof MSApp&&MSApp.execUnsafeLocalFunction?function(b,c,d,e){MSApp.execUnsafeLocalFunction(function(){return a(b,c,d,e)})}:a}(function(a,b){if("http://www.w3.org/2000/svg"!==a.namespaceURI||"innerHTML"in a)a.innerHTML=b;else{od=od||document.createElement("div");od.innerHTML="<svg>"+b.valueOf().toString()+"</svg>";for(b=od.firstChild;a.firstChild;)a.removeChild(a.firstChild);for(;b.firstChild;)a.appendChild(b.firstChild)}}),Wb=function(a,
b){if(b){var c=a.firstChild;if(c&&c===a.lastChild&&3===c.nodeType){c.nodeValue=b;return}}a.textContent=b},ib={animationend:nc("Animation","AnimationEnd"),animationiteration:nc("Animation","AnimationIteration"),animationstart:nc("Animation","AnimationStart"),transitionend:nc("Transition","TransitionEnd")},Id={},Of={};wa&&(Of=document.createElement("div").style,"AnimationEvent"in window||(delete ib.animationend.animation,delete ib.animationiteration.animation,delete ib.animationstart.animation),"TransitionEvent"in
window||delete ib.transitionend.transition);var $h=oc("animationend"),ai=oc("animationiteration"),bi=oc("animationstart"),ci=oc("transitionend"),Db="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),Pf=new ("function"===typeof WeakMap?WeakMap:Map),Ab=null,wi=function(a){if(a){var b=a._dispatchListeners,c=a._dispatchInstances;
if(Array.isArray(b))for(var d=0;d<b.length&&!a.isPropagationStopped();d++)lf(a,b[d],c[d]);else b&&lf(a,b,c);a._dispatchListeners=null;a._dispatchInstances=null;a.isPersistent()||a.constructor.release(a)}},qc=[],Rd=!1,fa=[],xa=null,ya=null,za=null,Eb=new Map,Fb=new Map,Jb=[],Nd="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput close cancel copy cut paste click change contextmenu reset submit".split(" "),
yi="focus blur dragenter dragleave mouseover mouseout pointerover pointerout gotpointercapture lostpointercapture".split(" "),dg={},cg=new Map,Td=new Map,Rj=["abort","abort",$h,"animationEnd",ai,"animationIteration",bi,"animationStart","canplay","canPlay","canplaythrough","canPlayThrough","durationchange","durationChange","emptied","emptied","encrypted","encrypted","ended","ended","error","error","gotpointercapture","gotPointerCapture","load","load","loadeddata","loadedData","loadedmetadata","loadedMetadata",
"loadstart","loadStart","lostpointercapture","lostPointerCapture","playing","playing","progress","progress","seeking","seeking","stalled","stalled","suspend","suspend","timeupdate","timeUpdate",ci,"transitionEnd","waiting","waiting"];Sd("blur blur cancel cancel click click close close contextmenu contextMenu copy copy cut cut auxclick auxClick dblclick doubleClick dragend dragEnd dragstart dragStart drop drop focus focus input input invalid invalid keydown keyDown keypress keyPress keyup keyUp mousedown mouseDown mouseup mouseUp paste paste pause pause play play pointercancel pointerCancel pointerdown pointerDown pointerup pointerUp ratechange rateChange reset reset seeked seeked submit submit touchcancel touchCancel touchend touchEnd touchstart touchStart volumechange volumeChange".split(" "),
0);Sd("drag drag dragenter dragEnter dragexit dragExit dragleave dragLeave dragover dragOver mousemove mouseMove mouseout mouseOut mouseover mouseOver pointermove pointerMove pointerout pointerOut pointerover pointerOver scroll scroll toggle toggle touchmove touchMove wheel wheel".split(" "),1);Sd(Rj,2);(function(a,b){for(var c=0;c<a.length;c++)Td.set(a[c],b)})("change selectionchange textInput compositionstart compositionend compositionupdate".split(" "),0);var Hi=Zh,Gi=Pd,tc=!0,Kb={animationIterationCount:!0,
borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,
strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},Sj=["Webkit","ms","Moz","O"];Object.keys(Kb).forEach(function(a){Sj.forEach(function(b){b=b+a.charAt(0).toUpperCase()+a.substring(1);Kb[b]=Kb[a]})});var Ii=M({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0}),ng="$",og="/$",$d="$?",Zd="$!",Ze=null,$e=null,We="function"===typeof setTimeout?setTimeout:void 0,vj="function"===
typeof clearTimeout?clearTimeout:void 0,jf=Math.random().toString(36).slice(2),Aa="__reactInternalInstance$"+jf,vc="__reactEventHandlers$"+jf,Lb="__reactContainere$"+jf,Ba=null,ce=null,wc=null;M(R.prototype,{preventDefault:function(){this.defaultPrevented=!0;var a=this.nativeEvent;a&&(a.preventDefault?a.preventDefault():"unknown"!==typeof a.returnValue&&(a.returnValue=!1),this.isDefaultPrevented=xc)},stopPropagation:function(){var a=this.nativeEvent;a&&(a.stopPropagation?a.stopPropagation():"unknown"!==
typeof a.cancelBubble&&(a.cancelBubble=!0),this.isPropagationStopped=xc)},persist:function(){this.isPersistent=xc},isPersistent:yc,destructor:function(){var a=this.constructor.Interface,b;for(b in a)this[b]=null;this.nativeEvent=this._targetInst=this.dispatchConfig=null;this.isPropagationStopped=this.isDefaultPrevented=yc;this._dispatchInstances=this._dispatchListeners=null}});R.Interface={type:null,target:null,currentTarget:function(){return null},eventPhase:null,bubbles:null,cancelable:null,timeStamp:function(a){return a.timeStamp||
Date.now()},defaultPrevented:null,isTrusted:null};R.extend=function(a){function b(){return c.apply(this,arguments)}var c=this,d=function(){};d.prototype=c.prototype;d=new d;M(d,b.prototype);b.prototype=d;b.prototype.constructor=b;b.Interface=M({},c.Interface,a);b.extend=c.extend;sg(b);return b};sg(R);var Tj=R.extend({data:null}),Uj=R.extend({data:null}),Ni=[9,13,27,32],de=wa&&"CompositionEvent"in window,cc=null;wa&&"documentMode"in document&&(cc=document.documentMode);var Vj=wa&&"TextEvent"in window&&
!cc,xg=wa&&(!de||cc&&8<cc&&11>=cc),wg=String.fromCharCode(32),ua={beforeInput:{phasedRegistrationNames:{bubbled:"onBeforeInput",captured:"onBeforeInputCapture"},dependencies:["compositionend","keypress","textInput","paste"]},compositionEnd:{phasedRegistrationNames:{bubbled:"onCompositionEnd",captured:"onCompositionEndCapture"},dependencies:"blur compositionend keydown keypress keyup mousedown".split(" ")},compositionStart:{phasedRegistrationNames:{bubbled:"onCompositionStart",captured:"onCompositionStartCapture"},
dependencies:"blur compositionstart keydown keypress keyup mousedown".split(" ")},compositionUpdate:{phasedRegistrationNames:{bubbled:"onCompositionUpdate",captured:"onCompositionUpdateCapture"},dependencies:"blur compositionupdate keydown keypress keyup mousedown".split(" ")}},vg=!1,mb=!1,Wj={eventTypes:ua,extractEvents:function(a,b,c,d,e){var f;if(de)b:{switch(a){case "compositionstart":var g=ua.compositionStart;break b;case "compositionend":g=ua.compositionEnd;break b;case "compositionupdate":g=
ua.compositionUpdate;break b}g=void 0}else mb?tg(a,c)&&(g=ua.compositionEnd):"keydown"===a&&229===c.keyCode&&(g=ua.compositionStart);g?(xg&&"ko"!==c.locale&&(mb||g!==ua.compositionStart?g===ua.compositionEnd&&mb&&(f=rg()):(Ba=d,ce="value"in Ba?Ba.value:Ba.textContent,mb=!0)),e=Tj.getPooled(g,b,c,d),f?e.data=f:(f=ug(c),null!==f&&(e.data=f)),lb(e),f=e):f=null;(a=Vj?Oi(a,c):Pi(a,c))?(b=Uj.getPooled(ua.beforeInput,b,c,d),b.data=a,lb(b)):b=null;return null===f?b:null===b?f:[f,b]}},Qi={color:!0,date:!0,
datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0},Ag={change:{phasedRegistrationNames:{bubbled:"onChange",captured:"onChangeCapture"},dependencies:"blur change click focus input keydown keyup selectionchange".split(" ")}},Mb=null,Nb=null,kf=!1;wa&&(kf=Tf("input")&&(!document.documentMode||9<document.documentMode));var Xj={eventTypes:Ag,_isInputEventSupported:kf,extractEvents:function(a,b,c,d,e){e=b?Pa(b):window;var f=
e.nodeName&&e.nodeName.toLowerCase();if("select"===f||"input"===f&&"file"===e.type)var g=Si;else if(yg(e))if(kf)g=Wi;else{g=Ui;var h=Ti}else(f=e.nodeName)&&"input"===f.toLowerCase()&&("checkbox"===e.type||"radio"===e.type)&&(g=Vi);if(g&&(g=g(a,b)))return zg(g,c,d);h&&h(a,e,b);"blur"===a&&(a=e._wrapperState)&&a.controlled&&"number"===e.type&&Ed(e,"number",e.value)}},dc=R.extend({view:null,detail:null}),Yi={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"},di=0,ei=0,fi=!1,gi=!1,ec=dc.extend({screenX:null,
screenY:null,clientX:null,clientY:null,pageX:null,pageY:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,getModifierState:fe,button:null,buttons:null,relatedTarget:function(a){return a.relatedTarget||(a.fromElement===a.srcElement?a.toElement:a.fromElement)},movementX:function(a){if("movementX"in a)return a.movementX;var b=di;di=a.screenX;return fi?"mousemove"===a.type?a.screenX-b:0:(fi=!0,0)},movementY:function(a){if("movementY"in a)return a.movementY;var b=ei;ei=a.screenY;return gi?"mousemove"===
a.type?a.screenY-b:0:(gi=!0,0)}}),hi=ec.extend({pointerId:null,width:null,height:null,pressure:null,tangentialPressure:null,tiltX:null,tiltY:null,twist:null,pointerType:null,isPrimary:null}),fc={mouseEnter:{registrationName:"onMouseEnter",dependencies:["mouseout","mouseover"]},mouseLeave:{registrationName:"onMouseLeave",dependencies:["mouseout","mouseover"]},pointerEnter:{registrationName:"onPointerEnter",dependencies:["pointerout","pointerover"]},pointerLeave:{registrationName:"onPointerLeave",dependencies:["pointerout",
"pointerover"]}},Yj={eventTypes:fc,extractEvents:function(a,b,c,d,e){var f="mouseover"===a||"pointerover"===a,g="mouseout"===a||"pointerout"===a;if(f&&0===(e&32)&&(c.relatedTarget||c.fromElement)||!g&&!f)return null;f=d.window===d?d:(f=d.ownerDocument)?f.defaultView||f.parentWindow:window;if(g){if(g=b,b=(b=c.relatedTarget||c.toElement)?Bb(b):null,null!==b){var h=Na(b);if(b!==h||5!==b.tag&&6!==b.tag)b=null}}else g=null;if(g===b)return null;if("mouseout"===a||"mouseover"===a){var m=ec;var n=fc.mouseLeave;
var l=fc.mouseEnter;var k="mouse"}else if("pointerout"===a||"pointerover"===a)m=hi,n=fc.pointerLeave,l=fc.pointerEnter,k="pointer";a=null==g?f:Pa(g);f=null==b?f:Pa(b);n=m.getPooled(n,g,c,d);n.type=k+"leave";n.target=a;n.relatedTarget=f;c=m.getPooled(l,b,c,d);c.type=k+"enter";c.target=f;c.relatedTarget=a;d=g;k=b;if(d&&k)a:{m=d;l=k;g=0;for(a=m;a;a=pa(a))g++;a=0;for(b=l;b;b=pa(b))a++;for(;0<g-a;)m=pa(m),g--;for(;0<a-g;)l=pa(l),a--;for(;g--;){if(m===l||m===l.alternate)break a;m=pa(m);l=pa(l)}m=null}else m=
null;l=m;for(m=[];d&&d!==l;){g=d.alternate;if(null!==g&&g===l)break;m.push(d);d=pa(d)}for(d=[];k&&k!==l;){g=k.alternate;if(null!==g&&g===l)break;d.push(k);k=pa(k)}for(k=0;k<m.length;k++)be(m[k],"bubbled",n);for(k=d.length;0<k--;)be(d[k],"captured",c);return 0===(e&64)?[n]:[n,c]}},Qa="function"===typeof Object.is?Object.is:Zi,$i=Object.prototype.hasOwnProperty,Zj=wa&&"documentMode"in document&&11>=document.documentMode,Eg={select:{phasedRegistrationNames:{bubbled:"onSelect",captured:"onSelectCapture"},
dependencies:"blur contextmenu dragend focus keydown keyup mousedown mouseup selectionchange".split(" ")}},nb=null,he=null,Pb=null,ge=!1,ak={eventTypes:Eg,extractEvents:function(a,b,c,d,e,f){e=f||(d.window===d?d.document:9===d.nodeType?d:d.ownerDocument);if(!(f=!e)){a:{e=Jd(e);f=rd.onSelect;for(var g=0;g<f.length;g++)if(!e.has(f[g])){e=!1;break a}e=!0}f=!e}if(f)return null;e=b?Pa(b):window;switch(a){case "focus":if(yg(e)||"true"===e.contentEditable)nb=e,he=b,Pb=null;break;case "blur":Pb=he=nb=null;
break;case "mousedown":ge=!0;break;case "contextmenu":case "mouseup":case "dragend":return ge=!1,Dg(c,d);case "selectionchange":if(Zj)break;case "keydown":case "keyup":return Dg(c,d)}return null}},bk=R.extend({animationName:null,elapsedTime:null,pseudoElement:null}),ck=R.extend({clipboardData:function(a){return"clipboardData"in a?a.clipboardData:window.clipboardData}}),dk=dc.extend({relatedTarget:null}),ek={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",
Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},fk={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",
224:"Meta"},gk=dc.extend({key:function(a){if(a.key){var b=ek[a.key]||a.key;if("Unidentified"!==b)return b}return"keypress"===a.type?(a=Ac(a),13===a?"Enter":String.fromCharCode(a)):"keydown"===a.type||"keyup"===a.type?fk[a.keyCode]||"Unidentified":""},location:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,repeat:null,locale:null,getModifierState:fe,charCode:function(a){return"keypress"===a.type?Ac(a):0},keyCode:function(a){return"keydown"===a.type||"keyup"===a.type?a.keyCode:0},which:function(a){return"keypress"===
a.type?Ac(a):"keydown"===a.type||"keyup"===a.type?a.keyCode:0}}),hk=ec.extend({dataTransfer:null}),ik=dc.extend({touches:null,targetTouches:null,changedTouches:null,altKey:null,metaKey:null,ctrlKey:null,shiftKey:null,getModifierState:fe}),jk=R.extend({propertyName:null,elapsedTime:null,pseudoElement:null}),kk=ec.extend({deltaX:function(a){return"deltaX"in a?a.deltaX:"wheelDeltaX"in a?-a.wheelDeltaX:0},deltaY:function(a){return"deltaY"in a?a.deltaY:"wheelDeltaY"in a?-a.wheelDeltaY:"wheelDelta"in a?
-a.wheelDelta:0},deltaZ:null,deltaMode:null}),lk={eventTypes:dg,extractEvents:function(a,b,c,d,e){e=cg.get(a);if(!e)return null;switch(a){case "keypress":if(0===Ac(c))return null;case "keydown":case "keyup":a=gk;break;case "blur":case "focus":a=dk;break;case "click":if(2===c.button)return null;case "auxclick":case "dblclick":case "mousedown":case "mousemove":case "mouseup":case "mouseout":case "mouseover":case "contextmenu":a=ec;break;case "drag":case "dragend":case "dragenter":case "dragexit":case "dragleave":case "dragover":case "dragstart":case "drop":a=
hk;break;case "touchcancel":case "touchend":case "touchmove":case "touchstart":a=ik;break;case $h:case ai:case bi:a=bk;break;case ci:a=jk;break;case "scroll":a=dc;break;case "wheel":a=kk;break;case "copy":case "cut":case "paste":a=ck;break;case "gotpointercapture":case "lostpointercapture":case "pointercancel":case "pointerdown":case "pointermove":case "pointerout":case "pointerover":case "pointerup":a=hi;break;default:a=R}b=a.getPooled(e,b,c,d);lb(b);return b}};(function(a){if(ic)throw Error(k(101));
ic=Array.prototype.slice.call(a);nf()})("ResponderEventPlugin SimpleEventPlugin EnterLeaveEventPlugin ChangeEventPlugin SelectEventPlugin BeforeInputEventPlugin".split(" "));(function(a,b,c){td=a;rf=b;mf=c})(ae,Hb,Pa);pf({SimpleEventPlugin:lk,EnterLeaveEventPlugin:Yj,ChangeEventPlugin:Xj,SelectEventPlugin:ak,BeforeInputEventPlugin:Wj});var ie=[],ob=-1,Ca={},B={current:Ca},G={current:!1},Ra=Ca,bj=Pd,je=$f,Rg=Lj,aj=Nj,Dc=Oj,Ig=Zh,Jg=ag,Kg=Pj,Lg=Qj,Qg={},yj=Mj,Cj=void 0!==Yh?Yh:function(){},qa=null,
Ec=null,ke=!1,ii=ff(),Y=1E4>ii?ff:function(){return ff()-ii},Ic={current:null},Hc=null,qb=null,Gc=null,Tg=0,Jc=2,Ga=!1,Vb=da.ReactCurrentBatchConfig,$g=(new ea.Component).refs,Mc={isMounted:function(a){return(a=a._reactInternalFiber)?Na(a)===a:!1},enqueueSetState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;d=Va(d,a,e);e=Ea(d,e);e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueReplaceState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;
d=Va(d,a,e);e=Ea(d,e);e.tag=1;e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueForceUpdate:function(a,b){a=a._reactInternalFiber;var c=ka(),d=Vb.suspense;c=Va(c,a,d);d=Ea(c,d);d.tag=Jc;void 0!==b&&null!==b&&(d.callback=b);Fa(a,d);Ja(a,c)}},Qc=Array.isArray,wb=ah(!0),Fe=ah(!1),Sb={},ja={current:Sb},Ub={current:Sb},Tb={current:Sb},D={current:0},Sc=da.ReactCurrentDispatcher,X=da.ReactCurrentBatchConfig,Ia=0,z=null,K=null,J=null,Uc=!1,Tc={readContext:W,useCallback:S,useContext:S,
useEffect:S,useImperativeHandle:S,useLayoutEffect:S,useMemo:S,useReducer:S,useRef:S,useState:S,useDebugValue:S,useResponder:S,useDeferredValue:S,useTransition:S},dj={readContext:W,useCallback:ih,useContext:W,useEffect:eh,useImperativeHandle:function(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;return ze(4,2,gh.bind(null,b,a),c)},useLayoutEffect:function(a,b){return ze(4,2,a,b)},useMemo:function(a,b){var c=ub();b=void 0===b?null:b;a=a();c.memoizedState=[a,b];return a},useReducer:function(a,b,c){var d=
ub();b=void 0!==c?c(b):b;d.memoizedState=d.baseState=b;a=d.queue={pending:null,dispatch:null,lastRenderedReducer:a,lastRenderedState:b};a=a.dispatch=ch.bind(null,z,a);return[d.memoizedState,a]},useRef:function(a){var b=ub();a={current:a};return b.memoizedState=a},useState:xe,useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=xe(a),d=c[0],e=c[1];eh(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=
xe(!1),c=b[0];b=b[1];return[ih(Ce.bind(null,b,a),[b,a]),c]}},ej={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Vc,useRef:dh,useState:function(a){return Vc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Vc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Vc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,
b,a),[b,a]),c]}},fj={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Wc,useRef:dh,useState:function(a){return Wc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Wc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Wc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,b,a),[b,a]),c]}},ra=null,Ka=null,Wa=
!1,gj=da.ReactCurrentOwner,ia=!1,Je={dehydrated:null,retryTime:0};var jj=function(a,b,c,d){for(c=b.child;null!==c;){if(5===c.tag||6===c.tag)a.appendChild(c.stateNode);else if(4!==c.tag&&null!==c.child){c.child.return=c;c=c.child;continue}if(c===b)break;for(;null===c.sibling;){if(null===c.return||c.return===b)return;c=c.return}c.sibling.return=c.return;c=c.sibling}};var wh=function(a){};var ij=function(a,b,c,d,e){var f=a.memoizedProps;if(f!==d){var g=b.stateNode;Ta(ja.current);a=null;switch(c){case "input":f=
Cd(g,f);d=Cd(g,d);a=[];break;case "option":f=Fd(g,f);d=Fd(g,d);a=[];break;case "select":f=M({},f,{value:void 0});d=M({},d,{value:void 0});a=[];break;case "textarea":f=Gd(g,f);d=Gd(g,d);a=[];break;default:"function"!==typeof f.onClick&&"function"===typeof d.onClick&&(g.onclick=uc)}Ud(c,d);var h,m;c=null;for(h in f)if(!d.hasOwnProperty(h)&&f.hasOwnProperty(h)&&null!=f[h])if("style"===h)for(m in g=f[h],g)g.hasOwnProperty(m)&&(c||(c={}),c[m]="");else"dangerouslySetInnerHTML"!==h&&"children"!==h&&"suppressContentEditableWarning"!==
h&&"suppressHydrationWarning"!==h&&"autoFocus"!==h&&(db.hasOwnProperty(h)?a||(a=[]):(a=a||[]).push(h,null));for(h in d){var k=d[h];g=null!=f?f[h]:void 0;if(d.hasOwnProperty(h)&&k!==g&&(null!=k||null!=g))if("style"===h)if(g){for(m in g)!g.hasOwnProperty(m)||k&&k.hasOwnProperty(m)||(c||(c={}),c[m]="");for(m in k)k.hasOwnProperty(m)&&g[m]!==k[m]&&(c||(c={}),c[m]=k[m])}else c||(a||(a=[]),a.push(h,c)),c=k;else"dangerouslySetInnerHTML"===h?(k=k?k.__html:void 0,g=g?g.__html:void 0,null!=k&&g!==k&&(a=a||
[]).push(h,k)):"children"===h?g===k||"string"!==typeof k&&"number"!==typeof k||(a=a||[]).push(h,""+k):"suppressContentEditableWarning"!==h&&"suppressHydrationWarning"!==h&&(db.hasOwnProperty(h)?(null!=k&&oa(e,h),a||g===k||(a=[])):(a=a||[]).push(h,k))}c&&(a=a||[]).push("style",c);e=a;if(b.updateQueue=e)b.effectTag|=4}};var kj=function(a,b,c,d){c!==d&&(b.effectTag|=4)};var pj="function"===typeof WeakSet?WeakSet:Set,wj="function"===typeof WeakMap?WeakMap:Map,sj=Math.ceil,gd=da.ReactCurrentDispatcher,
Uh=da.ReactCurrentOwner,H=0,Ye=8,ca=16,ma=32,Xa=0,hd=1,Oh=2,ad=3,bd=4,Xe=5,p=H,U=null,t=null,P=0,F=Xa,id=null,ta=1073741823,Yb=1073741823,kd=null,Xb=0,jd=!1,Re=0,Ph=500,l=null,cd=!1,Se=null,La=null,ld=!1,Zb=null,$b=90,bb=null,ac=0,af=null,dd=0,Ja=function(a,b){if(50<ac)throw ac=0,af=null,Error(k(185));a=ed(a,b);if(null!==a){var c=Cc();1073741823===b?(p&Ye)!==H&&(p&(ca|ma))===H?Te(a):(V(a),p===H&&ha()):V(a);(p&4)===H||98!==c&&99!==c||(null===bb?bb=new Map([[a,b]]):(c=bb.get(a),(void 0===c||c>b)&&bb.set(a,
b)))}};var zj=function(a,b,c){var d=b.expirationTime;if(null!==a){var e=b.pendingProps;if(a.memoizedProps!==e||G.current)ia=!0;else{if(d<c){ia=!1;switch(b.tag){case 3:sh(b);Ee();break;case 5:bh(b);if(b.mode&4&&1!==c&&e.hidden)return b.expirationTime=b.childExpirationTime=1,null;break;case 1:N(b.type)&&Bc(b);break;case 4:se(b,b.stateNode.containerInfo);break;case 10:d=b.memoizedProps.value;e=b.type._context;y(Ic,e._currentValue);e._currentValue=d;break;case 13:if(null!==b.memoizedState){d=b.child.childExpirationTime;
if(0!==d&&d>=c)return th(a,b,c);y(D,D.current&1);b=sa(a,b,c);return null!==b?b.sibling:null}y(D,D.current&1);break;case 19:d=b.childExpirationTime>=c;if(0!==(a.effectTag&64)){if(d)return vh(a,b,c);b.effectTag|=64}e=b.memoizedState;null!==e&&(e.rendering=null,e.tail=null);y(D,D.current);if(!d)return null}return sa(a,b,c)}ia=!1}}else ia=!1;b.expirationTime=0;switch(b.tag){case 2:d=b.type;null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;e=pb(b,B.current);rb(b,c);e=we(null,
b,d,a,e,c);b.effectTag|=1;if("object"===typeof e&&null!==e&&"function"===typeof e.render&&void 0===e.$$typeof){b.tag=1;b.memoizedState=null;b.updateQueue=null;if(N(d)){var f=!0;Bc(b)}else f=!1;b.memoizedState=null!==e.state&&void 0!==e.state?e.state:null;ne(b);var g=d.getDerivedStateFromProps;"function"===typeof g&&Lc(b,d,g,a);e.updater=Mc;b.stateNode=e;e._reactInternalFiber=b;pe(b,d,a,c);b=Ie(null,b,d,!0,f,c)}else b.tag=0,T(null,b,e,c),b=b.child;return b;case 16:a:{e=b.elementType;null!==a&&(a.alternate=
null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;ri(e);if(1!==e._status)throw e._result;e=e._result;b.type=e;f=b.tag=Gj(e);a=aa(e,a);switch(f){case 0:b=He(null,b,e,a,c);break a;case 1:b=rh(null,b,e,a,c);break a;case 11:b=nh(null,b,e,a,c);break a;case 14:b=oh(null,b,e,aa(e.type,a),d,c);break a}throw Error(k(306,e,""));}return b;case 0:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),He(a,b,d,e,c);case 1:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),rh(a,b,d,e,c);
case 3:sh(b);d=b.updateQueue;if(null===a||null===d)throw Error(k(282));d=b.pendingProps;e=b.memoizedState;e=null!==e?e.element:null;oe(a,b);Qb(b,d,null,c);d=b.memoizedState.element;if(d===e)Ee(),b=sa(a,b,c);else{if(e=b.stateNode.hydrate)Ka=kb(b.stateNode.containerInfo.firstChild),ra=b,e=Wa=!0;if(e)for(c=Fe(b,null,d,c),b.child=c;c;)c.effectTag=c.effectTag&-3|1024,c=c.sibling;else T(a,b,d,c),Ee();b=b.child}return b;case 5:return bh(b),null===a&&De(b),d=b.type,e=b.pendingProps,f=null!==a?a.memoizedProps:
null,g=e.children,Yd(d,e)?g=null:null!==f&&Yd(d,f)&&(b.effectTag|=16),qh(a,b),b.mode&4&&1!==c&&e.hidden?(b.expirationTime=b.childExpirationTime=1,b=null):(T(a,b,g,c),b=b.child),b;case 6:return null===a&&De(b),null;case 13:return th(a,b,c);case 4:return se(b,b.stateNode.containerInfo),d=b.pendingProps,null===a?b.child=wb(b,null,d,c):T(a,b,d,c),b.child;case 11:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),nh(a,b,d,e,c);case 7:return T(a,b,b.pendingProps,c),b.child;case 8:return T(a,
b,b.pendingProps.children,c),b.child;case 12:return T(a,b,b.pendingProps.children,c),b.child;case 10:a:{d=b.type._context;e=b.pendingProps;g=b.memoizedProps;f=e.value;var h=b.type._context;y(Ic,h._currentValue);h._currentValue=f;if(null!==g)if(h=g.value,f=Qa(h,f)?0:("function"===typeof d._calculateChangedBits?d._calculateChangedBits(h,f):1073741823)|0,0===f){if(g.children===e.children&&!G.current){b=sa(a,b,c);break a}}else for(h=b.child,null!==h&&(h.return=b);null!==h;){var m=h.dependencies;if(null!==
m){g=h.child;for(var l=m.firstContext;null!==l;){if(l.context===d&&0!==(l.observedBits&f)){1===h.tag&&(l=Ea(c,null),l.tag=Jc,Fa(h,l));h.expirationTime<c&&(h.expirationTime=c);l=h.alternate;null!==l&&l.expirationTime<c&&(l.expirationTime=c);Sg(h.return,c);m.expirationTime<c&&(m.expirationTime=c);break}l=l.next}}else g=10===h.tag?h.type===b.type?null:h.child:h.child;if(null!==g)g.return=h;else for(g=h;null!==g;){if(g===b){g=null;break}h=g.sibling;if(null!==h){h.return=g.return;g=h;break}g=g.return}h=
g}T(a,b,e.children,c);b=b.child}return b;case 9:return e=b.type,f=b.pendingProps,d=f.children,rb(b,c),e=W(e,f.unstable_observedBits),d=d(e),b.effectTag|=1,T(a,b,d,c),b.child;case 14:return e=b.type,f=aa(e,b.pendingProps),f=aa(e.type,f),oh(a,b,e,f,d,c);case 15:return ph(a,b,b.type,b.pendingProps,d,c);case 17:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),b.tag=1,N(d)?(a=!0,Bc(b)):a=!1,rb(b,c),Yg(b,d,e),pe(b,d,e,c),Ie(null,
b,d,!0,a,c);case 19:return vh(a,b,c)}throw Error(k(156,b.tag));};var bf=null,Ne=null,la=function(a,b,c,d){return new Fj(a,b,c,d)};ef.prototype.render=function(a){md(a,this._internalRoot,null,null)};ef.prototype.unmount=function(){var a=this._internalRoot,b=a.containerInfo;md(null,a,null,function(){b[Lb]=null})};var Di=function(a){if(13===a.tag){var b=Fc(ka(),150,100);Ja(a,b);df(a,b)}};var Yf=function(a){13===a.tag&&(Ja(a,3),df(a,3))};var Bi=function(a){if(13===a.tag){var b=ka();b=Va(b,a,null);Ja(a,
b);df(a,b)}};sd=function(a,b,c){switch(b){case "input":Dd(a,c);b=c.name;if("radio"===c.type&&null!=b){for(c=a;c.parentNode;)c=c.parentNode;c=c.querySelectorAll("input[name="+JSON.stringify(""+b)+'][type="radio"]');for(b=0;b<c.length;b++){var d=c[b];if(d!==a&&d.form===a.form){var e=ae(d);if(!e)throw Error(k(90));Gf(d);Dd(d,e)}}}break;case "textarea":Lf(a,c);break;case "select":b=c.value,null!=b&&hb(a,!!c.multiple,b,!1)}};(function(a,b,c,d){ee=a;eg=b;vd=c;vf=d})(Qh,function(a,b,c,d,e){var f=p;p|=4;
try{return Da(98,a.bind(null,b,c,d,e))}finally{p=f,p===H&&ha()}},function(){(p&(1|ca|ma))===H&&(uj(),xb())},function(a,b){var c=p;p|=2;try{return a(b)}finally{p=c,p===H&&ha()}});var mk={Events:[Hb,Pa,ae,pf,qd,lb,function(a){Kd(a,Ki)},sf,tf,sc,pc,xb,{current:!1}]};(function(a){var b=a.findFiberByHostInstance;return Ej(M({},a,{overrideHookState:null,overrideProps:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:da.ReactCurrentDispatcher,findHostInstanceByFiber:function(a){a=Sf(a);
return null===a?null:a.stateNode},findFiberByHostInstance:function(a){return b?b(a):null},findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null}))})({findFiberByHostInstance:Bb,bundleType:0,version:"16.13.1",rendererPackageName:"react-dom"});I.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=mk;I.createPortal=Xh;I.findDOMNode=function(a){if(null==a)return null;if(1===a.nodeType)return a;var b=a._reactInternalFiber;if(void 0===
b){if("function"===typeof a.render)throw Error(k(188));throw Error(k(268,Object.keys(a)));}a=Sf(b);a=null===a?null:a.stateNode;return a};I.flushSync=function(a,b){if((p&(ca|ma))!==H)throw Error(k(187));var c=p;p|=1;try{return Da(99,a.bind(null,b))}finally{p=c,ha()}};I.hydrate=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!0,c)};I.render=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!1,c)};I.unmountComponentAtNode=function(a){if(!bc(a))throw Error(k(40));return a._reactRootContainer?
(Rh(function(){nd(null,null,a,!1,function(){a._reactRootContainer=null;a[Lb]=null})}),!0):!1};I.unstable_batchedUpdates=Qh;I.unstable_createPortal=function(a,b){return Xh(a,b,2<arguments.length&&void 0!==arguments[2]?arguments[2]:null)};I.unstable_renderSubtreeIntoContainer=function(a,b,c,d){if(!bc(c))throw Error(k(200));if(null==a||void 0===a._reactInternalFiber)throw Error(k(38));return nd(a,b,c,!1,d)};I.version="16.13.1"});
</script>
    <script>const e = React.createElement;

function pathToString(path) {
  if (path[0] === '/') {
    return '/' + path.slice(1).join('/');
  } else {
    return path.join('/');
  }
}

function findCommonPath(files) {
  if (!files || !files.length) {
    return [];
  }

  function isPrefix(arr, prefix) {
    if (arr.length < prefix.length) {
      return false;
    }
    for (let i = prefix.length - 1; i >= 0; --i) {
      if (arr[i] !== prefix[i]) {
        return false;
      }
    }
    return true;
  }

  let commonPath = files[0].path.slice(0, -1);
  while (commonPath.length) {
    if (files.every(file => isPrefix(file.path, commonPath))) {
      break;
    }
    commonPath.pop();
  }
  return commonPath;
}

function findFolders(files) {
  if (!files || !files.length) {
    return [];
  }

  let folders = files.filter(file => file.path.length > 1).map(file => file.path[0]);
  folders = [...new Set(folders)]; // unique
  folders.sort();

  folders = folders.map(folder => {
    let filesInFolder = files
      .filter(file => file.path[0] === folder)
      .map(file => ({
        ...file,
        path: file.path.slice(1),
        parent: [...file.parent, file.path[0]],
      }));

    const children = findFolders(filesInFolder); // recursion

    return {
      is_folder: true,
      path: [folder],
      parent: files[0].parent,
      children,
      covered: children.reduce((sum, file) => sum + file.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.coverable, 0),
      prevRun: {
        covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
        coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
      }
    };
  });

  return [
    ...folders,
    ...files.filter(file => file.path.length === 1),
  ];
}

class App extends React.Component {
  constructor(...args) {
    super(...args);

    this.state = {
      current: [],
    };
  }

  componentDidMount() {
    this.updateStateFromLocation();
    window.addEventListener("hashchange", () => this.updateStateFromLocation(), false);
  }

  updateStateFromLocation() {
    if (window.location.hash.length > 1) {
      const current = window.location.hash.substr(1).split('/');
      this.setState({current});
    } else {
      this.setState({current: []});
    }
  }

  getCurrentPath() {
    let file = this.props.root;
    let path = [file];
    for (let p of this.state.current) {
      file = file.children.find(file => file.path[0] === p);
      if (!file) {
        return path;
      }
      path.push(file);
    }
    return path;
  }

  render() {
    const path = this.getCurrentPath();
    const file = path[path.length - 1];

    let w = null;
    if (file.is_folder) {
      w = e(FilesList, {
        folder: file,
        onSelectFile: this.selectFile.bind(this),
        onBack: path.length > 1 ? this.back.bind(this) : null,
      });
    } else {
      w = e(DisplayFile, {
        file,
        onBack: this.back.bind(this),
      });
    }

    return e('div', {className: 'app'}, w);
  }

  selectFile(file) {
    this.setState(({current}) => {
      return {current: [...current, file.path[0]]};
    }, () => this.updateHash());
  }

  back(file) {
    this.setState(({current}) => {
      return {current: current.slice(0, current.length - 1)};
    }, () => this.updateHash());
  }

  updateHash() {
    if (!this.state.current || !this.state.current.length) {
      window.location = '#';
    } else {
      window.location = '#' + this.state.current.join('/');
    }
  }
}

function FilesList({folder, onSelectFile, onBack}) {
  let files = folder.children;
  return e('div', {className: 'display-folder'},
    e(FileHeader, {file: folder, onBack}),
    e('table', {className: 'files-list'},
      e('thead', {className: 'files-list__head'},
        e('tr', null,
          e('th', null, "Path"),
          e('th', null, "Coverage")
        )
      ),
      e('tbody', {className: 'files-list__body'},
        files.map(file => e(File, {file, onClick: onSelectFile}))
      )
    )
  );
}

function File({file, onClick}) {
  const coverage = file.coverable ? file.covered / file.coverable * 100 : -1;
  const coverageDelta = file.prevRun &&
    (file.covered / file.coverable * 100 - file.prevRun.covered / file.prevRun.coverable * 100);

  return e('tr', {
      className: 'files-list__file'
        + (coverage >= 0 && coverage < 50 ? ' files-list__file_low': '')
        + (coverage >= 50 && coverage < 80 ? ' files-list__file_medium': '')
        + (coverage >= 80 ? ' files-list__file_high': '')
        + (file.is_folder ? ' files-list__file_folder': ''),
      onClick: () => onClick(file),
    },
    e('td', null, pathToString(file.path)),
    e('td', null,
      file.covered + ' / ' + file.coverable +
      (coverage >= 0 ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e('span', {title: 'Change from the previous run'},
        (coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : ''))
    )
  );
}

function DisplayFile({file, onBack}) {
  return e('div', {className: 'display-file'},
    e(FileHeader, {file, onBack}),
    e(FileContent, {file})
  );
}

function FileHeader({file, onBack}) {
  const coverage = file.covered / file.coverable * 100;
  const coverageDelta = file.prevRun && (coverage - file.prevRun.covered / file.prevRun.coverable * 100);

  return e('div', {className: 'file-header'},
    onBack ? e('a', {className: 'file-header__back', onClick: onBack}, 'Back') : null,
    e('div', {className: 'file-header__name'}, pathToString([...file.parent, ...file.path])),
    e('div', {className: 'file-header__stat'},
      'Covered: ' + file.covered + ' of ' + file.coverable +
      (file.coverable ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e('span', {title: 'Change from the previous run'},
        (coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : ''))
    )
  );
}

function FileContent({file}) {
  return e('div', {className: 'file-content'},
    file.content.split(/\r?\n/).map((line, index) => {
      const trace = file.traces.find(trace => trace.line === index + 1);
      const covered = trace && trace.stats.Line;
      const uncovered = trace && !trace.stats.Line;
      return e('pre', {
          className: 'code-line'
            + (covered ? ' code-line_covered' : '')
            + (uncovered ? ' code-line_uncovered' : ''),
          title: trace ? JSON.stringify(trace.stats, null, 2) : null,
        }, line);
    })
  );
}

(function(){
  const commonPath = findCommonPath(data.files);
  const prevFilesMap = new Map();

  previousData && previousData.files.forEach((file) => {
    const path = file.path.slice(commonPath.length).join('/');
    prevFilesMap.set(path, file);
  });

  const files = data.files.map((file) => {
    const path = file.path.slice(commonPath.length);
    const { covered = 0, coverable = 0 } = prevFilesMap.get(path.join('/')) || {};
    return {
      ...file,
      path,
      parent: commonPath,
      prevRun: { covered, coverable },
    };
  });

  const children = findFolders(files);

  const root = {
    is_folder: true,
    children,
    path: commonPath,
    parent: [],
    covered: children.reduce((sum, file) => sum + file.covered, 0),
    coverable: children.reduce((sum, file) => sum + file.coverable, 0),
    prevRun: {
      covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
    }
  };

  ReactDOM.render(e(App, {root, prevFilesMap}), document.getElementById('root'));
}());
</script>
</body>
</html>